import { j as Y } from "./jsx-runtime-0DLF9kdB.js"; import { g as Hm, r as Mh } from "./index-D8WRu5oy.js"; import { u as Gm } from "./components-B2-GOgf1.js"; import { P as Vm } from "./Page-CsEogIui.js"; import { L as Qs } from "./Layout-Cj-Ff9d7.js"; import { C as Gt } from "./Card-B868ABYJ.js"; import "./index-CZB_Ibz4.js"; import "./context-DyOSZSIO.js"; import "./within-content-context-DIv_5tIU.js"; var to = { exports: {} }, Zm = to.exports, kh; function $m() {
    return kh || (kh = 1, function (Q, ii) {
        (function (Pt, ce) { Pt._Highcharts = ce(), Q.exports = Pt._Highcharts })(typeof window > "u" ? Zm : window, () => (() => {
            var wh; let Pt, ce, Le; var si, oi, ri, Jt, Oe, gt, St, Ee, eo, io, so, oo, ro, ao, no, lo, ho, co, po, uo, go, mo, fo, ai = {}; ai.d = (h, t) => { for (var e in t) ai.o(t, e) && !ai.o(h, e) && Object.defineProperty(h, e, { enumerable: !0, get: t[e] }) }, ai.o = (h, t) => Object.prototype.hasOwnProperty.call(h, t); var ta = {}; ai.d(ta, { default: () => Ym }), function (h) { var t, e, i, s, o, r, a; h.SVG_NS = "http://www.w3.org/2000/svg", h.product = "Highcharts", h.version = "12.3.0", h.win = typeof window < "u" ? window : {}, h.doc = h.win.document, h.svg = !!((i = (e = (t = h.doc) == null ? void 0 : t.createElementNS) == null ? void 0 : e.call(t, h.SVG_NS, "svg")) != null && i.createSVGRect), h.pageLang = (r = (o = (s = h.doc) == null ? void 0 : s.documentElement) == null ? void 0 : o.closest("[lang]")) == null ? void 0 : r.lang, h.userAgent = ((a = h.win.navigator) == null ? void 0 : a.userAgent) || "", h.isChrome = h.win.chrome, h.isFirefox = h.userAgent.indexOf("Firefox") !== -1, h.isMS = /(edge|msie|trident)/i.test(h.userAgent) && !h.win.opera, h.isSafari = !h.isChrome && h.userAgent.indexOf("Safari") !== -1, h.isTouchDevice = /(Mobile|Android|Windows Phone)/.test(h.userAgent), h.isWebKit = h.userAgent.indexOf("AppleWebKit") !== -1, h.deg2rad = 2 * Math.PI / 360, h.marginNames = ["plotTop", "marginRight", "marginBottom", "plotLeft"], h.noop = function () { }, h.supportsPassiveEvents = function () { let n = !1; if (!h.isMS) { let l = Object.defineProperty({}, "passive", { get: function () { n = !0 } }); h.win.addEventListener && h.win.removeEventListener && (h.win.addEventListener("testPassive", h.noop, l), h.win.removeEventListener("testPassive", h.noop, l)) } return n }(), h.charts = [], h.composed = [], h.dateFormats = {}, h.seriesTypes = {}, h.symbolSizes = {}, h.chartCount = 0 }(si || (si = {})); let C = si, { charts: Ch, doc: Ie, win: pe } = C; function ni(h, t, e, i) {
                let s = t ? "Highcharts error" : "Highcharts warning"; h === 32 && (h = `${s}: Deprecated member`); let o = xo(h), r = o ? `${s} #${h}: www.highcharts.com/errors/${h}/` : h.toString(); if (i !== void 0) {
                    let a = ""; o && (r += "?"), ue(i, function (n, l) {
                        a += `
 - ${l}: ${n}`, o && (r += encodeURI(l) + "=" + encodeURI(n))
                    }), r += a
                } la(C, "displayError", { chart: e, code: h, message: r, params: i }, function () { if (t) throw Error(r); pe.console && ni.messages.indexOf(r) === -1 && console.warn(r) }), ni.messages.push(r)
            } function ea(h, t) { return parseInt(h, t || 10) } function li(h) { return typeof h == "string" } function Hi(h) { let t = Object.prototype.toString.call(h); return t === "[object Array]" || t === "[object Array Iterator]" } function De(h, t) { return !!h && typeof h == "object" && (!t || !Hi(h)) } function yo(h) { return De(h) && typeof h.nodeType == "number" } function ia(h) { let t = h == null ? void 0 : h.constructor; return !!(De(h, !0) && !yo(h) && (t != null && t.name) && t.name !== "Object") } function xo(h) { return typeof h == "number" && !isNaN(h) && h < 1 / 0 && h > -1 / 0 } function Be(h) { return h != null } function sa(h, t, e) { let i, s = li(t) && !Be(e), o = (r, a) => { Be(r) ? h.setAttribute(a, r) : s ? (i = h.getAttribute(a)) || a !== "class" || (i = h.getAttribute(a + "Name")) : h.removeAttribute(a) }; return li(t) ? o(e, t) : ue(t, o), i } function oa(h) { return Hi(h) ? h : [h] } function ze(h, t) { let e; for (e in h || (h = {}), t) h[e] = t[e]; return h } function hi() { let h = arguments, t = h.length; for (let e = 0; e < t; e++) { let i = h[e]; if (i != null) return i } } function bo(h, t) { ze(h.style, t) } function ra(h) { return Math.pow(10, Math.floor(Math.log(h) / Math.LN10)) } function aa(h, t) { return h > 1e14 ? h : parseFloat(h.toPrecision(t || 14)) } (ni || (ni = {})).messages = [], Math.easeInOutSine = function (h) { return -.5 * (Math.cos(Math.PI * h) - 1) }; let Th = Array.prototype.find ? function (h, t) { return h.find(t) } : function (h, t) { let e, i = h.length; for (e = 0; e < i; e++)if (t(h[e], e)) return h[e] }; function ue(h, t, e) { for (let i in h) Object.hasOwnProperty.call(h, i) && t.call(e || h[i], h[i], i, h) } function na(h, t, e) { function i(r, a) { let n = h.removeEventListener; n && n.call(h, r, a, !1) } function s(r) { let a, n; h.nodeName && (t ? (a = {})[t] = !0 : a = r, ue(a, function (l, c) { if (r[c]) for (n = r[c].length; n--;)i(c, r[c][n].fn) })) } let o = typeof h == "function" && h.prototype || h; if (Object.hasOwnProperty.call(o, "hcEvents")) { let r = o.hcEvents; if (t) { let a = r[t] || []; e ? (r[t] = a.filter(function (n) { return e !== n.fn }), i(t, e)) : (s(r), r[t] = []) } else s(r), delete o.hcEvents } } function la(h, t, e, i) { if (e = e || {}, (Ie == null ? void 0 : Ie.createEvent) && (h.dispatchEvent || h.fireEvent && h !== C)) { let s = Ie.createEvent("Events"); s.initEvent(t, !0, !0), e = ze(s, e), h.dispatchEvent ? h.dispatchEvent(e) : h.fireEvent(t, e) } else if (h.hcEvents) { e.target || ze(e, { preventDefault: function () { e.defaultPrevented = !0 }, target: h, type: t }); let s = [], o = h, r = !1; for (; o.hcEvents;)Object.hasOwnProperty.call(o, "hcEvents") && o.hcEvents[t] && (s.length && (r = !0), s.unshift.apply(s, o.hcEvents[t])), o = Object.getPrototypeOf(o); r && s.sort((a, n) => a.order - n.order), s.forEach(a => { a.fn.call(h, e) === !1 && e.preventDefault() }) } i && !e.defaultPrevented && i.call(h, e) } let Ph = function () { let h = Math.random().toString(36).substring(2, 9) + "-", t = 0; return function () { return "highcharts-" + (Pt ? "" : h) + t++ } }(); pe.jQuery && (pe.jQuery.fn.highcharts = function () { let h = [].slice.call(arguments); if (this[0]) return h[0] ? (new C[li(h[0]) ? h.shift() : "Chart"](this[0], h[0], h[1]), this) : Ch[sa(this[0], "data-highcharts-chart")] }); let I = { addEvent: function (h, t, e, i = {}) { let s = typeof h == "function" && h.prototype || h; Object.hasOwnProperty.call(s, "hcEvents") || (s.hcEvents = {}); let o = s.hcEvents; C.Point && h instanceof C.Point && h.series && h.series.chart && (h.series.chart.runTrackerClick = !0); let r = h.addEventListener; r && r.call(h, t, e, !!C.supportsPassiveEvents && { passive: i.passive === void 0 ? t.indexOf("touch") !== -1 : i.passive, capture: !1 }), o[t] || (o[t] = []); let a = { fn: e, order: typeof i.order == "number" ? i.order : 1 / 0 }; return o[t].push(a), o[t].sort((n, l) => n.order - l.order), function () { na(h, t, e) } }, arrayMax: function (h) { let t = h.length, e = h[0]; for (; t--;)h[t] > e && (e = h[t]); return e }, arrayMin: function (h) { let t = h.length, e = h[0]; for (; t--;)h[t] < e && (e = h[t]); return e }, attr: sa, clamp: function (h, t, e) { return h > t ? h < e ? h : e : t }, clearTimeout: function (h) { Be(h) && clearTimeout(h) }, correctFloat: aa, createElement: function (h, t, e, i, s) { let o = Ie.createElement(h); return t && ze(o, t), s && bo(o, { padding: "0", border: "none", margin: "0" }), e && bo(o, e), i && i.appendChild(o), o }, crisp: function (h, t = 0, e) { let i = t % 2 / 2, s = e ? -1 : 1; return (Math.round(h * s - i) + i) * s }, css: bo, defined: Be, destroyObjectProperties: function (h, t, e) { ue(h, function (i, s) { i !== t && (i != null && i.destroy) && i.destroy(), (i != null && i.destroy || !e) && delete h[s] }) }, diffObjects: function (h, t, e, i) { let s = {}; return function o(r, a, n, l) { let c = e ? a : r; ue(r, function (d, p) { if (!l && i && i.indexOf(p) > -1 && a[p]) { d = oa(d), n[p] = []; for (let u = 0; u < Math.max(d.length, a[p].length); u++)a[p][u] && (d[u] === void 0 ? n[p][u] = a[p][u] : (n[p][u] = {}, o(d[u], a[p][u], n[p][u], l + 1))) } else De(d, !0) && !d.nodeType ? (n[p] = Hi(d) ? [] : {}, o(d, a[p] || {}, n[p], l + 1), Object.keys(n[p]).length === 0 && (p !== "colorAxis" || l !== 0) && delete n[p]) : (r[p] !== a[p] || p in r && !(p in a)) && p !== "__proto__" && p !== "constructor" && (n[p] = c[p]) }) }(h, t, s, 0), s }, discardElement: function (h) { var t; (t = h == null ? void 0 : h.parentElement) == null || t.removeChild(h) }, erase: function (h, t) { let e = h.length; for (; e--;)if (h[e] === t) { h.splice(e, 1); break } }, error: ni, extend: ze, extendClass: function (h, t) { let e = function () { }; return e.prototype = new h, ze(e.prototype, t), e }, find: Th, fireEvent: la, getAlignFactor: (h = "") => ({ center: .5, right: 1, middle: .5, bottom: 1 })[h] || 0, getClosestDistance: function (h, t) { let e, i, s, o = !t; return h.forEach(r => { if (r.length > 1) for (s = r.length - 1; s > 0; s--)(i = r[s] - r[s - 1]) < 0 && !o ? (t == null || t(), t = void 0) : i && (e === void 0 || i < e) && (e = i) }), e }, getMagnitude: ra, getNestedProperty: function (h, t) { let e = h.split("."); for (; e.length && Be(t);) { let i = e.shift(); if (i === void 0 || i === "__proto__") return; if (i === "this") { let o; return De(t) && (o = t["@this"]), o ?? t } let s = t[i.replace(/[\\'"]/g, "")]; if (!Be(s) || typeof s == "function" || typeof s.nodeType == "number" || s === pe) return; t = s } return t }, getStyle: function h(t, e, i) { var r; let s; if (e === "width") { let a = Math.min(t.offsetWidth, t.scrollWidth), n = (r = t.getBoundingClientRect) == null ? void 0 : r.call(t).width; return n < a && n >= a - 1 && (a = Math.floor(n)), Math.max(0, a - (h(t, "padding-left", !0) || 0) - (h(t, "padding-right", !0) || 0)) } if (e === "height") return Math.max(0, Math.min(t.offsetHeight, t.scrollHeight) - (h(t, "padding-top", !0) || 0) - (h(t, "padding-bottom", !0) || 0)); let o = pe.getComputedStyle(t, void 0); return o && (s = o.getPropertyValue(e), hi(i, e !== "opacity") && (s = ea(s))), s }, insertItem: function (h, t) { let e, i = h.options.index, s = t.length; for (e = h.options.isInternal ? s : 0; e < s + 1; e++)if (!t[e] || xo(i) && i < hi(t[e].options.index, t[e]._i) || t[e].options.isInternal) { t.splice(e, 0, h); break } return e }, isArray: Hi, isClass: ia, isDOMElement: yo, isFunction: function (h) { return typeof h == "function" }, isNumber: xo, isObject: De, isString: li, merge: function (h, ...t) { let e, i = [h, ...t], s = {}, o = function (a, n) { return typeof a != "object" && (a = {}), ue(n, function (l, c) { c !== "__proto__" && c !== "constructor" && (!De(l, !0) || ia(l) || yo(l) ? a[c] = n[c] : a[c] = o(a[c] || {}, l)) }), a }; h === !0 && (s = i[1], i = Array.prototype.slice.call(i, 2)); let r = i.length; for (e = 0; e < r; e++)s = o(s, i[e]); return s }, normalizeTickInterval: function (h, t, e, i, s) { let o, r = h; e = hi(e, ra(h)); let a = h / e; for (!t && (t = s ? [1, 1.2, 1.5, 2, 2.5, 3, 4, 5, 6, 8, 10] : [1, 2, 2.5, 5, 10], i === !1 && (e === 1 ? t = t.filter(function (n) { return n % 1 == 0 }) : e <= .1 && (t = [1 / e]))), o = 0; o < t.length && (r = t[o], (!s || !(r * e >= h)) && (s || !(a <= (t[o] + (t[o + 1] || t[o])) / 2))); o++); return aa(r * e, -Math.round(Math.log(.001) / Math.LN10)) }, objectEach: ue, offset: function (h) { let t = Ie.documentElement, e = h.parentElement || h.parentNode ? h.getBoundingClientRect() : { top: 0, left: 0, width: 0, height: 0 }; return { top: e.top + (pe.pageYOffset || t.scrollTop) - (t.clientTop || 0), left: e.left + (pe.pageXOffset || t.scrollLeft) - (t.clientLeft || 0), width: e.width, height: e.height } }, pad: function (h, t, e) { return Array((t || 2) + 1 - String(h).replace("-", "").length).join(e || "0") + h }, pick: hi, pInt: ea, pushUnique: function (h, t) { return 0 > h.indexOf(t) && !!h.push(t) }, relativeLength: function (h, t, e) { return /%$/.test(h) ? t * parseFloat(h) / 100 + (e || 0) : parseFloat(h) }, removeEvent: na, replaceNested: function (h, ...t) { let e, i; do for (i of (e = h, t)) h = h.replace(i[0], i[1]); while (h !== e); return h }, splat: oa, stableSort: function (h, t) { let e, i, s = h.length; for (i = 0; i < s; i++)h[i].safeI = i; for (h.sort(function (o, r) { return (e = t(o, r)) === 0 ? o.safeI - r.safeI : e }), i = 0; i < s; i++)delete h[i].safeI }, syncTimeout: function (h, t, e) { return t > 0 ? setTimeout(h, t, e) : (h.call(0, e), -1) }, timeUnits: { millisecond: 1, second: 1e3, minute: 6e4, hour: 36e5, day: 864e5, week: 6048e5, month: 24192e5, year: 314496e5 }, ucfirst: function (h) { return li(h) ? h.substring(0, 1).toUpperCase() + h.substring(1) : String(h) }, uniqueKey: Ph, useSerialIds: function (h) { return Pt = hi(h, Pt) }, wrap: function (h, t, e) { let i = h[t]; h[t] = function () { let s = arguments, o = this; return e.apply(this, [function () { return i.apply(o, arguments.length ? arguments : s) }].concat([].slice.call(arguments))) } } }, { pageLang: Lh, win: Gi } = C, { defined: ha, error: da, extend: vo, isNumber: ca, isObject: wo, isString: di, merge: Oh, objectEach: Eh, pad: Qt, splat: Ih, timeUnits: So, ucfirst: Dh } = I, Bh = C.isSafari && Gi.Intl && !Gi.Intl.DateTimeFormat.prototype.formatRange, zh = h => h.main === void 0, Nh = class { constructor(h, t) { this.options = { timezone: "UTC" }, this.variableTimezone = !1, this.Date = Gi.Date, this.update(h), this.lang = t } update(h = {}) { this.dTLCache = {}, this.options = h = Oh(!0, this.options, h); let { timezoneOffset: t, useUTC: e, locale: i } = h; this.Date = h.Date || Gi.Date || Date; let s = h.timezone; ha(e) && (s = e ? "UTC" : void 0), t && t % 60 == 0 && (s = "Etc/GMT" + (t > 0 ? "+" : "") + t / 60), this.variableTimezone = s !== "UTC" && (s == null ? void 0 : s.indexOf("Etc/GMT")) !== 0, this.timezone = s, this.lang && i && (this.lang.locale = i), ["months", "shortMonths", "weekdays", "shortWeekdays"].forEach(o => { let r = /months/i.test(o), a = /short/.test(o), n = { timeZone: "UTC" }; n[r ? "month" : "weekday"] = a ? "short" : "long", this[o] = (r ? [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11] : [3, 4, 5, 6, 7, 8, 9]).map(l => this.dateFormat(n, (r ? 31 : 1) * 24 * 36e5 * l)) }) } toParts(h) { let [t, e, i, s, o, r, a] = this.dateTimeFormat({ weekday: "narrow", day: "numeric", month: "numeric", year: "numeric", hour: "numeric", minute: "numeric", second: "numeric" }, h, "es").split(/(?:, | |\/|:)/g); return [s, i - 1, e, o, r, a, Math.floor(Number(h) || 0) % 1e3, "DLMXJVS".indexOf(t)].map(Number) } dateTimeFormat(h, t, e = this.options.locale || Lh) { let i = JSON.stringify(h) + e; di(h) && (h = this.str2dtf(h)); let s = this.dTLCache[i]; if (!s) { h.timeZone ?? (h.timeZone = this.timezone); try { s = new Intl.DateTimeFormat(e, h) } catch (o) { /Invalid time zone/i.test(o.message) ? (da(34), h.timeZone = "UTC", s = new Intl.DateTimeFormat(e, h)) : da(o.message, !1) } } return this.dTLCache[i] = s, (s == null ? void 0 : s.format(t)) || "" } str2dtf(h, t = {}) { let e = { L: { fractionalSecondDigits: 3 }, S: { second: "2-digit" }, M: { minute: "numeric" }, H: { hour: "2-digit" }, k: { hour: "numeric" }, E: { weekday: "narrow" }, a: { weekday: "short" }, A: { weekday: "long" }, d: { day: "2-digit" }, e: { day: "numeric" }, b: { month: "short" }, B: { month: "long" }, m: { month: "2-digit" }, o: { month: "numeric" }, y: { year: "2-digit" }, Y: { year: "numeric" } }; return Object.keys(e).forEach(i => { h.indexOf(i) !== -1 && vo(t, e[i]) }), t } makeTime(h, t, e = 1, i = 0, s, o, r) { let a = this.Date.UTC(h, t, e, i, s || 0, o || 0, r || 0); if (this.timezone !== "UTC") { let n = this.getTimezoneOffset(a); if (a += n, [2, 3, 8, 9, 10, 11].indexOf(t) !== -1 && (i < 5 || i > 20)) { let l = this.getTimezoneOffset(a); n !== l ? a += l - n : n - 36e5 !== this.getTimezoneOffset(a - 36e5) || Bh || (a -= 36e5) } } return a } parse(h) { if (!di(h)) return h ?? void 0; let t = (h = h.replace(/\//g, "-").replace(/(GMT|UTC)/, "")).indexOf("Z") > -1 || /([+-][0-9]{2}):?[0-9]{2}$/.test(h), e = /^[0-9]{4}-[0-9]{2}(-[0-9]{2}|)$/.test(h); t || e || (h += "Z"); let i = Date.parse(h); if (ca(i)) return i + (!t || e ? this.getTimezoneOffset(i) : 0) } getTimezoneOffset(h) { if (this.timezone !== "UTC") { let [t, e, i, s, o = 0] = this.dateTimeFormat({ timeZoneName: "shortOffset" }, h, "en").split(/(GMT|:)/).map(Number), r = -(60 * (i + o / 60) * 6e4); if (ca(r)) return r } return 0 } dateFormat(h, t, e) { let i = this.lang; if (!ha(t) || isNaN(t)) return (i == null ? void 0 : i.invalidDate) || ""; if (di(h = h ?? "%Y-%m-%d %H:%M:%S")) { let s, o = /%\[([a-zA-Z]+)\]/g; for (; s = o.exec(h);)h = h.replace(s[0], this.dateTimeFormat(s[1], t, i == null ? void 0 : i.locale)) } if (di(h) && h.indexOf("%") !== -1) { let s = this, [o, r, a, n, l, c, d, p] = this.toParts(t), u = (i == null ? void 0 : i.weekdays) || this.weekdays, g = (i == null ? void 0 : i.shortWeekdays) || this.shortWeekdays, m = (i == null ? void 0 : i.months) || this.months, f = (i == null ? void 0 : i.shortMonths) || this.shortMonths; Eh(vo({ a: g ? g[p] : u[p].substr(0, 3), A: u[p], d: Qt(a), e: Qt(a, 2, " "), w: p, v: (i == null ? void 0 : i.weekFrom) ?? "", b: f[r], B: m[r], m: Qt(r + 1), o: r + 1, y: o.toString().substr(2, 2), Y: o, H: Qt(n), k: n, I: Qt(n % 12 || 12), l: n % 12 || 12, M: Qt(l), p: n < 12 ? "AM" : "PM", P: n < 12 ? "am" : "pm", S: Qt(c), L: Qt(d, 3) }, C.dateFormats), function (y, x) { if (di(h)) for (; h.indexOf("%" + x) !== -1;)h = h.replace("%" + x, typeof y == "function" ? y.call(s, t) : y) }) } else if (wo(h)) { let s = (this.getTimezoneOffset(t) || 0) / 36e5, o = this.timezone || "Etc/GMT" + (s >= 0 ? "+" : "") + s, { prefix: r = "", suffix: a = "" } = h; h = r + this.dateTimeFormat(vo({ timeZone: o }, h), t) + a } return e ? Dh(h) : h } resolveDTLFormat(h) { return wo(h, !0) ? wo(h, !0) && zh(h) ? { main: h } : h : { main: (h = Ih(h))[0], from: h[1], to: h[2] } } getDateFormat(h, t, e, i) { let s = this.dateFormat("%m-%d %H:%M:%S.%L", t), o = "01-01 00:00:00.000", r = { millisecond: 15, second: 12, minute: 9, hour: 6, day: 3 }, a = "millisecond", n = a; for (a in So) { if (h && h === So.week && +this.dateFormat("%w", t) === e && s.substr(6) === o.substr(6)) { a = "week"; break } if (h && So[a] > h) { a = n; break } if (r[a] && s.substr(r[a]) !== o.substr(r[a])) break; a !== "week" && (n = a) } return this.resolveDTLFormat(i[a]).main } }, { defined: pa, extend: Uh, timeUnits: at } = I, Mo = class extends Nh { getTimeTicks(h, t, e, i) { let s = this, o = [], r = {}, { count: a = 1, unitRange: n } = h, [l, c, d, p, u, g] = s.toParts(t), m = (t || 0) % 1e3, f; if (i ?? (i = 1), pa(t)) { if (m = n >= at.second ? 0 : a * Math.floor(m / a), n >= at.second && (g = n >= at.minute ? 0 : a * Math.floor(g / a)), n >= at.minute && (u = n >= at.hour ? 0 : a * Math.floor(u / a)), n >= at.hour && (p = n >= at.day ? 0 : a * Math.floor(p / a)), n >= at.day && (d = n >= at.month ? 1 : Math.max(1, a * Math.floor(d / a))), n >= at.month && (c = n >= at.year ? 0 : a * Math.floor(c / a)), n >= at.year && (l -= l % a), n === at.week) { a && (t = s.makeTime(l, c, d, p, u, g, m)); let b = this.dateTimeFormat({ timeZone: this.timezone, weekday: "narrow" }, t, "es"), w = "DLMXJVS".indexOf(b); d += -w + i + (w < i ? -7 : 0) } t = s.makeTime(l, c, d, p, u, g, m), s.variableTimezone && pa(e) && (f = e - t > 4 * at.month || s.getTimezoneOffset(t) !== s.getTimezoneOffset(e)); let y = t, x = 1; for (; y < e;)o.push(y), n === at.year ? y = s.makeTime(l + x * a, 0) : n === at.month ? y = s.makeTime(l, c + x * a) : f && (n === at.day || n === at.week) ? y = s.makeTime(l, c, d + x * a * (n === at.day ? 1 : 7)) : f && n === at.hour && a > 1 ? y = s.makeTime(l, c, d, p + x * a) : y += n * a, x++; o.push(y), n <= at.hour && o.length < 1e4 && o.forEach(b => { b % 18e5 == 0 && s.dateFormat("%H%M%S%L", b) === "000000000" && (r[b] = "day") }) } return o.info = Uh(h, { higherRanks: r, totalRange: n * a }), o } }, { isTouchDevice: jh } = C, { fireEvent: Rh, merge: Wh } = I, Vt = { colors: ["#2caffe", "#544fc5", "#00e272", "#fe6a35", "#6b8abc", "#d568fb", "#2ee0ca", "#fa4b42", "#feb56a", "#91e8e1"], symbols: ["circle", "diamond", "square", "triangle", "triangle-down"], lang: { weekFrom: "week from", chartTitle: "Chart title", locale: void 0, loading: "Loading...", months: void 0, seriesName: "Series {add index 1}", shortMonths: void 0, weekdays: void 0, numericSymbols: ["k", "M", "G", "T", "P", "E"], pieSliceName: "Slice", resetZoom: "Reset zoom", yAxisTitle: "Values", resetZoomTitle: "Reset zoom level 1:1" }, global: { buttonTheme: { fill: "#f7f7f7", padding: 8, r: 2, stroke: "#cccccc", "stroke-width": 1, style: { color: "#333333", cursor: "pointer", fontSize: "0.8em", fontWeight: "normal" }, states: { hover: { fill: "#e6e6e6" }, select: { fill: "#e6e9ff", style: { color: "#000000", fontWeight: "bold" } }, disabled: { style: { color: "#cccccc" } } } } }, time: { Date: void 0, timezone: "UTC", timezoneOffset: 0, useUTC: void 0 }, chart: { alignThresholds: !1, panning: { enabled: !1, type: "x" }, styledMode: !1, borderRadius: 0, colorCount: 10, allowMutatingData: !0, ignoreHiddenSeries: !0, spacing: [10, 10, 15, 10], resetZoomButton: { theme: {}, position: {} }, reflow: !0, type: "line", zooming: { singleTouch: !1, resetButton: { theme: { zIndex: 6 }, position: { align: "right", x: -10, y: 10 } } }, width: null, height: null, borderColor: "#334eff", backgroundColor: "#ffffff", plotBorderColor: "#cccccc" }, title: { style: { color: "#333333", fontWeight: "bold" }, text: "Chart title", margin: 15, minScale: .67 }, subtitle: { style: { color: "#666666", fontSize: "0.8em" }, text: "" }, caption: { margin: 15, style: { color: "#666666", fontSize: "0.8em" }, text: "", align: "left", verticalAlign: "bottom" }, plotOptions: {}, legend: { enabled: !0, align: "center", alignColumns: !0, className: "highcharts-no-tooltip", events: {}, layout: "horizontal", itemMarginBottom: 2, itemMarginTop: 2, labelFormatter: function () { return this.name }, borderColor: "#999999", borderRadius: 0, navigation: { style: { fontSize: "0.8em" }, activeColor: "#0022ff", inactiveColor: "#cccccc" }, itemStyle: { color: "#333333", cursor: "pointer", fontSize: "0.8em", textDecoration: "none", textOverflow: "ellipsis" }, itemHoverStyle: { color: "#000000" }, itemHiddenStyle: { color: "#666666", textDecoration: "line-through" }, shadow: !1, itemCheckboxStyle: { position: "absolute", width: "13px", height: "13px" }, squareSymbol: !0, symbolPadding: 5, verticalAlign: "bottom", x: 0, y: 0, title: { style: { color: "#333333", fontSize: "0.8em", fontWeight: "bold" } } }, loading: { labelStyle: { fontWeight: "bold", position: "relative", top: "45%" }, style: { position: "absolute", backgroundColor: "#ffffff", opacity: .5, textAlign: "center" } }, tooltip: { enabled: !0, animation: { duration: 300, easing: h => Math.sqrt(1 - Math.pow(h - 1, 2)) }, borderRadius: 3, dateTimeLabelFormats: { millisecond: "%[AebHMSL]", second: "%[AebHMS]", minute: "%[AebHM]", hour: "%[AebHM]", day: "%[AebY]", week: "%v %[AebY]", month: "%[BY]", year: "%Y" }, footerFormat: "", headerShape: "callout", hideDelay: 500, padding: 8, position: { x: 0, y: 3 }, shared: !1, snap: jh ? 25 : 10, headerFormat: '<span style="font-size: 0.8em">{ucfirst point.key}</span><br/>', pointFormat: '<span style="color:{point.color}">●</span> {series.name}: <b>{point.y}</b><br/>', backgroundColor: "#ffffff", borderWidth: void 0, stickOnContact: !1, style: { color: "#333333", cursor: "default", fontSize: "0.8em" }, useHTML: !1 }, credits: { enabled: !0, href: "https://www.highcharts.com?credits", position: { align: "right", x: -10, verticalAlign: "bottom", y: -5 }, style: { cursor: "pointer", color: "#999999", fontSize: "0.6em" }, text: "Highcharts.com" } }, ko = new Mo(Vt.time, Vt.lang), wt = { defaultOptions: Vt, defaultTime: ko, getOptions: function () { return Vt }, setOptions: function (h) { var t; return Rh(C, "setOptions", { options: h }), Wh(!0, Vt, h), h.time && ko.update(Vt.time), h.lang && "locale" in h.lang && ko.update({ locale: h.lang.locale }), (t = h.lang) != null && t.chartTitle && (Vt.title = { ...Vt.title, text: h.lang.chartTitle }), Vt } }, { win: Fh } = C, { isNumber: ci, isString: Xh, merge: Yh, pInt: Mt, defined: ua } = I, ga = (h, t, e) => `color-mix(in srgb,${h},${t} ${100 * e}%)`, Ao = h => Xh(h) && !!h && h !== "none"; class _ { static parse(t) { return t ? new _(t) : _.None } constructor(t) { let e, i, s, o; this.rgba = [NaN, NaN, NaN, NaN], this.input = t; let r = C.Color; if (r && r !== _) return new r(t); if (typeof t == "object" && t.stops !== void 0) this.stops = t.stops.map(a => new _(a[1])); else if (typeof t == "string") for (this.input = t = _.names[t.toLowerCase()] || t, s = _.parsers.length; s-- && !i;)(e = (o = _.parsers[s]).regex.exec(t)) && (i = o.parse(e)); i && (this.rgba = i) } get(t) { let e = this.input, i = this.rgba; if (this.output) return this.output; if (typeof e == "object" && this.stops !== void 0) { let s = Yh(e); return s.stops = [].slice.call(s.stops), this.stops.forEach((o, r) => { s.stops[r] = [s.stops[r][0], o.get(t)] }), s } return i && ci(i[0]) ? t !== "rgb" && (t || i[3] !== 1) ? t === "a" ? `${i[3]}` : "rgba(" + i.join(",") + ")" : "rgb(" + i[0] + "," + i[1] + "," + i[2] + ")" : e } brighten(t) { let e = this.rgba; if (this.stops) this.stops.forEach(function (i) { i.brighten(t) }); else if (ci(t) && t !== 0) if (ci(e[0])) for (let i = 0; i < 3; i++)e[i] += Mt(255 * t), e[i] < 0 && (e[i] = 0), e[i] > 255 && (e[i] = 255); else _.useColorMix && Ao(this.input) && (this.output = ga(this.input, t > 0 ? "white" : "black", Math.abs(t))); return this } setOpacity(t) { return this.rgba[3] = t, this } tweenTo(t, e) { let i = this.rgba, s = t.rgba; if (!ci(i[0]) || !ci(s[0])) return _.useColorMix && Ao(this.input) && Ao(t.input) && e < .99 ? ga(this.input, t.input, e) : t.input || "none"; let o = s[3] !== 1 || i[3] !== 1, r = (n, l) => n + (i[l] - n) * (1 - e), a = s.slice(0, 3).map(r).map(Math.round); return o && a.push(r(s[3], 3)), (o ? "rgba(" : "rgb(") + a.join(",") + ")" } } _.names = { white: "#ffffff", black: "#000000" }, _.parsers = [{ regex: /rgba\(\s*(\d{1,3})\s*,\s*(\d{1,3})\s*,\s*(\d{1,3})\s*,\s*(\d?(?:\.\d+)?)\s*\)/, parse: function (h) { return [Mt(h[1]), Mt(h[2]), Mt(h[3]), parseFloat(h[4], 10)] } }, { regex: /rgb\(\s*(\d{1,3})\s*,\s*(\d{1,3})\s*,\s*(\d{1,3})\s*\)/, parse: function (h) { return [Mt(h[1]), Mt(h[2]), Mt(h[3]), 1] } }, { regex: /^#([a-f0-9])([a-f0-9])([a-f0-9])([a-f0-9])?$/i, parse: function (h) { return [Mt(h[1] + h[1], 16), Mt(h[2] + h[2], 16), Mt(h[3] + h[3], 16), ua(h[4]) ? Mt(h[4] + h[4], 16) / 255 : 1] } }, { regex: /^#([a-f0-9]{2})([a-f0-9]{2})([a-f0-9]{2})([a-f0-9]{2})?$/i, parse: function (h) { return [Mt(h[1], 16), Mt(h[2], 16), Mt(h[3], 16), ua(h[4]) ? Mt(h[4], 16) / 255 : 1] } }], _.useColorMix = (wh = Fh.CSS) == null ? void 0 : wh.supports("color", "color-mix(in srgb,red,blue 9%)"), _.None = new _(""); let { parse: ma } = _, { win: Hh } = C, { isNumber: Co, objectEach: Gh } = I; class kt { constructor(t, e, i) { this.pos = NaN, this.options = e, this.elem = t, this.prop = i } dSetter() { let t = this.paths, e = t == null ? void 0 : t[0], i = t == null ? void 0 : t[1], s = this.now || 0, o = []; if (s !== 1 && e && i) if (e.length === i.length && s < 1) for (let r = 0; r < i.length; r++) { let a = e[r], n = i[r], l = []; for (let c = 0; c < n.length; c++) { let d = a[c], p = n[c]; Co(d) && Co(p) && (n[0] !== "A" || c !== 4 && c !== 5) ? l[c] = d + s * (p - d) : l[c] = p } o.push(l) } else o = i; else o = this.toD || []; this.elem.attr("d", o, void 0, !0) } update() { let t = this.elem, e = this.prop, i = this.now, s = this.options.step; this[e + "Setter"] ? this[e + "Setter"]() : t.attr ? t.element && t.attr(e, i, null, !0) : t.style[e] = i + this.unit, s && s.call(t, i, this) } run(t, e, i) { let s = this, o = s.options, r = function (l) { return !r.stopped && s.step(l) }, a = Hh.requestAnimationFrame || function (l) { setTimeout(l, 13) }, n = function () { for (let l = 0; l < kt.timers.length; l++)kt.timers[l]() || kt.timers.splice(l--, 1); kt.timers.length && a(n) }; t !== e || this.elem["forceAnimate:" + this.prop] ? (this.startTime = +new Date, this.start = t, this.end = e, this.unit = i, this.now = this.start, this.pos = 0, r.elem = this.elem, r.prop = this.prop, r() && kt.timers.push(r) === 1 && a(n)) : (delete o.curAnim[this.prop], o.complete && Object.keys(o.curAnim).length === 0 && o.complete.call(this.elem)) } step(t) { let e, i, s = +new Date, o = this.options, r = this.elem, a = o.complete, n = o.duration, l = o.curAnim; return r.attr && !r.element ? e = !1 : t || s >= n + this.startTime ? (this.now = this.end, this.pos = 1, this.update(), l[this.prop] = !0, i = !0, Gh(l, function (c) { c !== !0 && (i = !1) }), i && a && a.call(r), e = !1) : (this.pos = o.easing((s - this.startTime) / n), this.now = this.start + (this.end - this.start) * this.pos, this.update(), e = !0), e } initPath(t, e, i) { let s = t.startX, o = t.endX, r = i.slice(), a = t.isArea, n = a ? 2 : 1, l = e && i.length > e.length && i.hasStackedCliffs, c, d, p, u, g = e == null ? void 0 : e.slice(); if (!g || l) return [r, r]; function m(y, x) { for (; y.length < d;) { let b = y[0], w = x[d - y.length]; if (w && b[0] === "M" && (w[0] === "C" ? y[0] = ["C", b[1], b[2], b[1], b[2], b[1], b[2]] : y[0] = ["L", b[1], b[2]]), y.unshift(b), a) { let v = y.pop(); y.push(y[y.length - 1], v) } } } function f(y) { for (; y.length < d;) { let x = y[Math.floor(y.length / n) - 1].slice(); if (x[0] === "C" && (x[1] = x[5], x[2] = x[6]), a) { let b = y[Math.floor(y.length / n)].slice(); y.splice(y.length / 2, 0, x, b) } else y.push(x) } } if (s && o && o.length) { for (p = 0; p < s.length; p++)if (s[p] === o[0]) { c = p; break } else if (s[0] === o[o.length - s.length + p]) { c = p, u = !0; break } else if (s[s.length - 1] === o[o.length - s.length + p]) { c = s.length - p; break } c === void 0 && (g = []) } return g.length && Co(c) && (d = r.length + c * n, u ? (m(g, r), f(r)) : (m(r, g), f(g))), [g, r] } fillSetter() { kt.prototype.strokeSetter.apply(this, arguments) } strokeSetter() { this.elem.attr(this.prop, ma(this.start).tweenTo(ma(this.end), this.pos), void 0, !0) } } kt.timers = []; let { defined: Vh, getStyle: Zh, isArray: $h, isNumber: Kh, isObject: To, merge: fa, objectEach: qh, pick: _h } = I; function Po(h) { return To(h) ? fa({ duration: 500, defer: 0 }, h) : { duration: 500 * !!h, defer: 0 } } function ya(h, t) { let e = kt.timers.length; for (; e--;)kt.timers[e].elem !== h || t && t !== kt.timers[e].prop || (kt.timers[e].stopped = !0) } let mt = { animate: function (h, t, e) { let i, s = "", o, r, a; To(e) || (a = arguments, e = { duration: a[2], easing: a[3], complete: a[4] }), Kh(e.duration) || (e.duration = 400), e.easing = typeof e.easing == "function" ? e.easing : Math[e.easing] || Math.easeInOutSine, e.curAnim = fa(t), qh(t, function (n, l) { ya(h, l), r = new kt(h, e, l), o = void 0, l === "d" && $h(t.d) ? (r.paths = r.initPath(h, h.pathArray, t.d), r.toD = t.d, i = 0, o = 1) : h.attr ? i = h.attr(l) : (i = parseFloat(Zh(h, l)) || 0, l !== "opacity" && (s = "px")), o || (o = n), typeof o == "string" && o.match("px") && (o = o.replace(/px/g, "")), r.run(i, o, s) }) }, animObject: Po, getDeferredAnimation: function (h, t, e) { let i = Po(t), s = e ? [e] : h.series, o = 0, r = 0; return s.forEach(a => { let n = Po(a.options.animation); o = To(t) && Vh(t.defer) ? i.defer : Math.max(o, n.duration + n.defer), r = Math.min(i.duration, n.duration) }), h.renderer.forExport && (o = 0), { defer: Math.max(0, o - r), duration: Math.min(o, r) } }, setAnimation: function (h, t) { t.renderer.globalAnimation = _h(h, t.options.chart.animation, !0) }, stop: ya }, { SVG_NS: xa, win: Jh } = C, { attr: Qh, createElement: td, css: ed, error: ba, isFunction: id, isString: va, objectEach: wa, splat: sd } = I, { trustedTypes: Lo } = Jh, Vi = Lo && id(Lo.createPolicy) && Lo.createPolicy("highcharts", { createHTML: h => h }), od = Vi ? Vi.createHTML("") : ""; class et { static filterUserAttributes(t) { return wa(t, (e, i) => { let s = !0; et.allowedAttributes.indexOf(i) === -1 && (s = !1), ["background", "dynsrc", "href", "lowsrc", "src"].indexOf(i) !== -1 && (s = va(e) && et.allowedReferences.some(o => e.indexOf(o) === 0)), s || (ba(33, !1, void 0, { "Invalid attribute in config": `${i}` }), delete t[i]), va(e) && t[i] && (t[i] = e.replace(/</g, "&lt;")) }), t } static parseStyle(t) { return t.split(";").reduce((e, i) => { let s = i.split(":").map(r => r.trim()), o = s.shift(); return o && s.length && (e[o.replace(/-([a-z])/g, r => r[1].toUpperCase())] = s.join(":")), e }, {}) } static setElementHTML(t, e) { t.innerHTML = et.emptyHTML, e && new et(e).addToDOM(t) } constructor(t) { this.nodes = typeof t == "string" ? this.parseMarkup(t) : t } addToDOM(t) { return function e(i, s) { let o; return sd(i).forEach(function (r) { let a, n = r.tagName, l = r.textContent ? C.doc.createTextNode(r.textContent) : void 0, c = et.bypassHTMLFiltering; if (n) if (n === "#text") a = l; else if (et.allowedTags.indexOf(n) !== -1 || c) { let d = n === "svg" ? xa : s.namespaceURI || xa, p = C.doc.createElementNS(d, n), u = r.attributes || {}; wa(r, function (g, m) { m !== "tagName" && m !== "attributes" && m !== "children" && m !== "style" && m !== "textContent" && (u[m] = g) }), Qh(p, c ? u : et.filterUserAttributes(u)), r.style && ed(p, r.style), l && p.appendChild(l), e(r.children || [], p), a = p } else ba(33, !1, void 0, { "Invalid tagName in config": n }); a && s.appendChild(a), o = a }), o }(this.nodes, t) } parseMarkup(t) { let e, i = []; t = t.trim().replace(/ style=(["'])/g, " data-style=$1"); try { e = new DOMParser().parseFromString(Vi ? Vi.createHTML(t) : t, "text/html") } catch { } if (!e) { let o = td("div"); o.innerHTML = t, e = { body: o } } let s = (o, r) => { let a = o.nodeName.toLowerCase(), n = { tagName: a }; a === "#text" && (n.textContent = o.textContent || ""); let l = o.attributes; if (l) { let c = {};[].forEach.call(l, d => { d.name === "data-style" ? n.style = et.parseStyle(d.value) : c[d.name] = d.value }), n.attributes = c } if (o.childNodes.length) { let c = [];[].forEach.call(o.childNodes, d => { s(d, c) }), c.length && (n.children = c) } r.push(n) }; return [].forEach.call(e.body.childNodes, o => s(o, i)), i } } et.allowedAttributes = ["alt", "aria-controls", "aria-describedby", "aria-expanded", "aria-haspopup", "aria-hidden", "aria-label", "aria-labelledby", "aria-live", "aria-pressed", "aria-readonly", "aria-roledescription", "aria-selected", "class", "clip-path", "color", "colspan", "cx", "cy", "d", "disabled", "dx", "dy", "fill", "filterUnits", "flood-color", "flood-opacity", "height", "href", "id", "in", "in2", "markerHeight", "markerWidth", "offset", "opacity", "operator", "orient", "padding", "paddingLeft", "paddingRight", "patternUnits", "r", "radius", "refX", "refY", "result", "role", "rowspan", "scope", "slope", "src", "startOffset", "stdDeviation", "stroke-linecap", "stroke-width", "stroke", "style", "summary", "tabindex", "tableValues", "target", "text-align", "text-anchor", "textAnchor", "textLength", "title", "type", "valign", "width", "x", "x1", "x2", "xlink:href", "y", "y1", "y2", "zIndex"], et.allowedReferences = ["https://", "http://", "mailto:", "/", "../", "./", "#"], et.allowedTags = ["#text", "a", "abbr", "b", "br", "button", "caption", "circle", "clipPath", "code", "dd", "defs", "div", "dl", "dt", "em", "feComponentTransfer", "feComposite", "feDropShadow", "feFlood", "feFuncA", "feFuncB", "feFuncG", "feFuncR", "feGaussianBlur", "feMerge", "feMergeNode", "feMorphology", "feOffset", "filter", "h1", "h2", "h3", "h4", "h5", "h6", "hr", "i", "img", "li", "linearGradient", "marker", "ol", "p", "path", "pattern", "pre", "rect", "small", "span", "stop", "strong", "style", "sub", "sup", "svg", "table", "tbody", "td", "text", "textPath", "th", "thead", "title", "tr", "tspan", "u", "ul"], et.emptyHTML = od, et.bypassHTMLFiltering = !1; let { defaultOptions: Sa, defaultTime: Ma } = wt, { pageLang: rd } = C, { extend: ad, getNestedProperty: nd, isArray: ld, isNumber: ka, isObject: hd, isString: dd, pick: cd, ucfirst: pd } = I, Zi = { add: (h, t) => h + t, divide: (h, t) => t !== 0 ? h / t : "", eq: (h, t) => h == t, each: function (h) { let t = arguments[arguments.length - 1]; return !!ld(h) && h.map((e, i) => $i(t.body, ad(hd(e) ? e : { "@this": e }, { "@index": i, "@first": i === 0, "@last": i === h.length - 1 }))).join("") }, ge: (h, t) => h >= t, gt: (h, t) => h > t, if: h => !!h, le: (h, t) => h <= t, lt: (h, t) => h < t, multiply: (h, t) => h * t, ne: (h, t) => h != t, subtract: (h, t) => h - t, ucfirst: pd, unless: h => !h }, Aa = {}, Ca = h => /^["'].+["']$/.test(h); function $i(h = "", t, e) { var f; let i = /\{([a-zA-Z\u00C0-\u017F\d:\.,;\-\/<>\[\]%_@+"'’= #\(\)]+)\}/g, s = /\(([a-zA-Z\u00C0-\u017F\d:\.,;\-\/<>\[\]%_@+"'= ]+)\)/g, o = [], r = /f$/, a = /\.(\d)/, n = ((f = e == null ? void 0 : e.options) == null ? void 0 : f.lang) || Sa.lang, l = (e == null ? void 0 : e.time) || Ma, c = (e == null ? void 0 : e.numberFormatter) || Ta.bind(e), d = (y = "") => { let x; return y === "true" || y !== "false" && ((x = Number(y)).toString() === y ? x : Ca(y) ? y.slice(1, -1) : nd(y, t)) }, p, u, g = 0, m; for (; (p = i.exec(h)) !== null;) { let y = p, x = s.exec(p[1]); x && (p = x, m = !0), u != null && u.isBlock || (u = { ctx: t, expression: p[1], find: p[0], isBlock: p[1].charAt(0) === "#", start: p.index, startInner: p.index + p[0].length, length: p[0].length }); let b = (u.isBlock ? y : p)[1].split(" ")[0].replace("#", ""); Zi[b] && (u.isBlock && b === u.fn && g++, u.fn || (u.fn = b)); let w = p[1] === "else"; if (u.isBlock && u.fn && (p[1] === `/${u.fn}` || w)) if (g) !w && g--; else { let v = u.startInner, S = h.substr(v, p.index - v); u.body === void 0 ? (u.body = S, u.startInner = p.index + p[0].length) : u.elseBody = S, u.find += S + p[0], w || (o.push(u), u = void 0) } else u.isBlock || o.push(u); if (x && !(u != null && u.isBlock)) break } return o.forEach(y => { let x, b, { body: w, elseBody: v, expression: S, fn: A } = y; if (A) { let M = [y], k = [], T = S.length, P = 0, L; for (b = 0; b <= T; b++) { let O = S.charAt(b); L || O !== '"' && O !== "'" ? L === O && (L = "") : L = O, L || O !== " " && b !== T || (k.push(S.substr(P, b - P)), P = b + 1) } for (b = Zi[A].length; b--;)M.unshift(d(k[b + 1])); x = Zi[A].apply(t, M), y.isBlock && typeof x == "boolean" && (x = $i(x ? w : v, t, e)) } else { let M = Ca(S) ? [S] : S.split(":"), k = (x = d(M.shift() || "")) % 1 != 0; if (typeof x == "number" && (M.length || k)) { let T = M.join(":"); if (r.test(T) || k) { let P = parseInt((T.match(a) || ["", "-1"])[1], 10); x !== null && (x = c(x, P, n.decimalPoint, T.indexOf(",") > -1 ? n.thousandsSep : "")) } else x = l.dateFormat(T, x) } s.lastIndex = 0, s.test(y.find) && dd(x) && (x = `"${x}"`) } h = h.replace(y.find, cd(x, "")) }), m ? $i(h, t, e) : h } function Ta(h, t, e, i) { var m; t *= 1; let s, o, [r, a] = (h = +h || 0).toString().split("e").map(Number), n = ((m = this == null ? void 0 : this.options) == null ? void 0 : m.lang) || Sa.lang, l = (h.toString().split(".")[1] || "").split("e")[0].length, c = t, d = {}; e ?? (e = n.decimalPoint), i ?? (i = n.thousandsSep), t === -1 ? t = Math.min(l, 20) : ka(t) ? t && a < 0 && ((o = t + a) >= 0 ? (r = +r.toExponential(o).split("e")[0], t = o) : (r = Math.floor(r), h = t < 20 ? +(r * Math.pow(10, a)).toFixed(t) : 0, a = 0)) : t = 2, a && (t ?? (t = 2), h = r), ka(t) && t >= 0 && (d.minimumFractionDigits = t, d.maximumFractionDigits = t), i === "" && (d.useGrouping = !1); let p = i || e, u = p ? "en" : (this == null ? void 0 : this.locale) || n.locale || rd, g = JSON.stringify(d) + u; return s = (Aa[g] ?? (Aa[g] = new Intl.NumberFormat(u, d))).format(h), p && (s = s.replace(/([,\.])/g, "_$1").replace(/_\,/g, i ?? ",").replace("_.", e ?? ".")), (t || +s != 0) && (!(a < 0) || c) || (s = "0"), a && +s != 0 && (s += "e" + (a < 0 ? "" : "+") + a), s } let At = { dateFormat: function (h, t, e) { return Ma.dateFormat(h, t, e) }, format: $i, helpers: Zi, numberFormat: Ta }; (function (h) { let t; h.rendererTypes = {}, h.getRendererType = function (e = t) { return h.rendererTypes[e] || h.rendererTypes[t] }, h.registerRendererType = function (e, i, s) { h.rendererTypes[e] = i, (!t || s) && (t = e, C.Renderer = i) } })(oi || (oi = {})); let pi = oi, { clamp: ud, pick: gd, pushUnique: md, stableSort: Oo } = I; (ri || (ri = {})).distribute = function h(t, e, i) { let s = t, o = s.reducedLen || e, r = (b, w) => b.target - w.target, a = [], n = t.length, l = [], c = a.push, d, p, u, g = !0, m, f, y = 0, x; for (d = n; d--;)y += t[d].size; if (y > o) { for (Oo(t, (b, w) => (w.rank || 0) - (b.rank || 0)), u = (x = t[0].rank === t[t.length - 1].rank) ? n / 2 : -1, p = x ? u : n - 1; u && y > o;)m = t[d = Math.floor(p)], md(l, d) && (y -= m.size), p += u, x && p >= t.length && (u /= 2, p = u); l.sort((b, w) => w - b).forEach(b => c.apply(a, t.splice(b, 1))) } for (Oo(t, r), t = t.map(b => ({ size: b.size, targets: [b.target], align: gd(b.align, .5) })); g;) { for (d = t.length; d--;)m = t[d], f = (Math.min.apply(0, m.targets) + Math.max.apply(0, m.targets)) / 2, m.pos = ud(f - m.size * m.align, 0, e - m.size); for (d = t.length, g = !1; d--;)d > 0 && t[d - 1].pos + t[d - 1].size > t[d].pos && (t[d - 1].size += t[d].size, t[d - 1].targets = t[d - 1].targets.concat(t[d].targets), t[d - 1].align = .5, t[d - 1].pos + t[d - 1].size > e && (t[d - 1].pos = e - t[d - 1].size), t.splice(d, 1), g = !0) } return c.apply(s, a), d = 0, t.some(b => { let w = 0; return (b.targets || []).some(() => (s[d].pos = b.pos + w, i !== void 0 && Math.abs(s[d].pos - s[d].target) > i ? (s.slice(0, d + 1).forEach(v => delete v.pos), s.reducedLen = (s.reducedLen || e) - .1 * e, s.reducedLen > .1 * e && h(s, e, i), !0) : (w += s[d].size, d++, !1))) }), Oo(s, r), s }; let Ki = ri, { animate: fd, animObject: yd, stop: Pa } = mt, { deg2rad: La, doc: Ne, svg: xd, SVG_NS: qi, win: bd, isFirefox: vd } = C, { addEvent: wd, attr: Eo, createElement: Sd, crisp: _i, css: Oa, defined: jt, erase: Md, extend: ui, fireEvent: Io, getAlignFactor: Do, isArray: Ea, isFunction: Ia, isNumber: kd, isObject: Ad, isString: Da, merge: Bo, objectEach: Ue, pick: Zt, pInt: Ji, pushUnique: Cd, replaceNested: Td, syncTimeout: Pd, uniqueKey: Ba } = I; class dt { _defaultGetter(t) { let e = Zt(this[t + "Value"], this[t], this.element ? this.element.getAttribute(t) : null, 0); return /^-?[\d\.]+$/.test(e) && (e = parseFloat(e)), e } _defaultSetter(t, e, i) { i.setAttribute(e, t) } add(t) { let e, i = this.renderer, s = this.element; return t && (this.parentGroup = t), this.textStr !== void 0 && this.element.nodeName === "text" && i.buildText(this), this.added = !0, (!t || t.handleZ || this.zIndex) && (e = this.zIndexSetter()), e || (t ? t.element : i.box).appendChild(s), this.onAdd && this.onAdd(), this } addClass(t, e) { let i = e ? "" : this.attr("class") || ""; return (t = (t || "").split(/ /g).reduce(function (s, o) { return i.indexOf(o) === -1 && s.push(o), s }, i ? [i] : []).join(" ")) !== i && this.attr("class", t), this } afterSetters() { this.doTransform && (this.updateTransform(), this.doTransform = !1) } align(t, e, i, s = !0) { let o = this.renderer, r = o.alignedObjects, a = !!t; t ? (this.alignOptions = t, this.alignByTranslate = e, this.alignTo = i) : (t = this.alignOptions || {}, e = this.alignByTranslate, i = this.alignTo); let n = !i || Da(i) ? i || "renderer" : void 0; n && (a && Cd(r, this), i = void 0); let l = Zt(i, o[n], o), c = (l.x || 0) + (t.x || 0) + ((l.width || 0) - (t.width || 0)) * Do(t.align), d = (l.y || 0) + (t.y || 0) + ((l.height || 0) - (t.height || 0)) * Do(t.verticalAlign), p = { "text-align": t == null ? void 0 : t.align }; return p[e ? "translateX" : "x"] = Math.round(c), p[e ? "translateY" : "y"] = Math.round(d), s && (this[this.placed ? "animate" : "attr"](p), this.placed = !0), this.alignAttr = p, this } alignSetter(t) { let e = { left: "start", center: "middle", right: "end" }; e[t] && (this.alignValue = t, this.element.setAttribute("text-anchor", e[t])) } animate(t, e, i) { let s = yd(Zt(e, this.renderer.globalAnimation, !0)), o = s.defer; return Ne.hidden && (s.duration = 0), s.duration !== 0 ? (i && (s.complete = i), Pd(() => { this.element && fd(this, t, s) }, o)) : (this.attr(t, void 0, i || s.complete), Ue(t, function (r, a) { s.step && s.step.call(this, r, { prop: a, pos: 1, elem: this }) }, this)), this } applyTextOutline(t) { let e = this.element; t.indexOf("contrast") !== -1 && (t = t.replace(/contrast/g, this.renderer.getContrast(e.style.fill))); let i = t.indexOf(" "), s = t.substring(i + 1), o = t.substring(0, i); if (o && o !== "none" && C.svg) { this.fakeTS = !0, o = o.replace(/(^[\d\.]+)(.*?)$/g, function (c, d, p) { return 2 * Number(d) + p }), this.removeTextOutline(); let r = Ne.createElementNS(qi, "tspan"); Eo(r, { class: "highcharts-text-outline", fill: s, stroke: s, "stroke-width": o, "stroke-linejoin": "round" }); let a = e.querySelector("textPath") || e;[].forEach.call(a.childNodes, c => { let d = c.cloneNode(!0); d.removeAttribute && ["fill", "stroke", "stroke-width", "stroke"].forEach(p => d.removeAttribute(p)), r.appendChild(d) }); let n = 0;[].forEach.call(a.querySelectorAll("text tspan"), c => { n += Number(c.getAttribute("dy")) }); let l = Ne.createElementNS(qi, "tspan"); l.textContent = "​", Eo(l, { x: Number(e.getAttribute("x")), dy: -n }), r.appendChild(l), a.insertBefore(r, a.firstChild) } } attr(t, e, i, s) { let { element: o } = this, r = dt.symbolCustomAttribs, a, n, l = this, c; return typeof t == "string" && e !== void 0 && (a = t, (t = {})[a] = e), typeof t == "string" ? l = (this[t + "Getter"] || this._defaultGetter).call(this, t, o) : (Ue(t, function (d, p) { c = !1, s || Pa(this, p), this.symbolName && r.indexOf(p) !== -1 && (n || (this.symbolAttr(t), n = !0), c = !0), this.rotation && (p === "x" || p === "y") && (this.doTransform = !0), c || (this[p + "Setter"] || this._defaultSetter).call(this, d, p, o) }, this), this.afterSetters()), i && i.call(this), l } clip(t) { if (t && !t.clipPath) { let e = Ba() + "-", i = this.renderer.createElement("clipPath").attr({ id: e }).add(this.renderer.defs); ui(t, { clipPath: i, id: e, count: 0 }), t.add(i) } return this.attr("clip-path", t ? `url(${this.renderer.url}#${t.id})` : "none") } crisp(t, e) { e = Math.round(e || t.strokeWidth || 0); let i = t.x || this.x || 0, s = t.y || this.y || 0, o = (t.width || this.width || 0) + i, r = (t.height || this.height || 0) + s, a = _i(i, e), n = _i(s, e); return ui(t, { x: a, y: n, width: _i(o, e) - a, height: _i(r, e) - n }), jt(t.strokeWidth) && (t.strokeWidth = e), t } complexColor(t, e, i) { let s = this.renderer, o, r, a, n, l, c, d, p, u, g, m = [], f; Io(this.renderer, "complexColor", { args: arguments }, function () { if (t.radialGradient ? r = "radialGradient" : t.linearGradient && (r = "linearGradient"), r) { if (a = t[r], l = s.gradients, c = t.stops, u = i.radialReference, Ea(a) && (t[r] = a = { x1: a[0], y1: a[1], x2: a[2], y2: a[3], gradientUnits: "userSpaceOnUse" }), r === "radialGradient" && u && !jt(a.gradientUnits) && (n = a, a = Bo(a, s.getRadialAttr(u, n), { gradientUnits: "userSpaceOnUse" })), Ue(a, function (y, x) { x !== "id" && m.push(x, y) }), Ue(c, function (y) { m.push(y) }), l[m = m.join(",")]) g = l[m].attr("id"); else { a.id = g = Ba(); let y = l[m] = s.createElement(r).attr(a).add(s.defs); y.radAttr = n, y.stops = [], c.forEach(function (x) { x[1].indexOf("rgba") === 0 ? (d = (o = _.parse(x[1])).get("rgb"), p = o.get("a")) : (d = x[1], p = 1); let b = s.createElement("stop").attr({ offset: x[0], "stop-color": d, "stop-opacity": p }).add(y); y.stops.push(b) }) } f = "url(" + s.url + "#" + g + ")", i.setAttribute(e, f), i.gradient = m, t.toString = function () { return f } } }) } css(t) { let e = this.styles, i = {}, s = this.element, o, r = !e; if (e && Ue(t, function (a, n) { e && e[n] !== a && (i[n] = a, r = !0) }), r) { e && (t = ui(e, i)), t.width === null || t.width === "auto" ? delete this.textWidth : s.nodeName.toLowerCase() === "text" && t.width && (o = this.textWidth = Ji(t.width)), ui(this.styles, t), o && !xd && this.renderer.forExport && delete t.width; let a = vd && t.fontSize || null; a && (kd(a) || /^\d+$/.test(a)) && (t.fontSize += "px"); let n = Bo(t); s.namespaceURI === this.SVG_NS && (["textOutline", "textOverflow", "whiteSpace", "width"].forEach(l => n && delete n[l]), n.color && (n.fill = n.color, delete n.color)), Oa(s, n) } return this.added && (this.element.nodeName === "text" && this.renderer.buildText(this), t.textOutline && this.applyTextOutline(t.textOutline)), this } dashstyleSetter(t) { let e, i = this["stroke-width"]; if (i === "inherit" && (i = 1), t) { let s = (t = t.toLowerCase()).replace("shortdashdotdot", "3,1,1,1,1,1,").replace("shortdashdot", "3,1,1,1").replace("shortdot", "1,1,").replace("shortdash", "3,1,").replace("longdash", "8,3,").replace(/dot/g, "1,3,").replace("dash", "4,3,").replace(/,$/, "").split(","); for (e = s.length; e--;)s[e] = "" + Ji(s[e]) * Zt(i, NaN); t = s.join(",").replace(/NaN/g, "none"), this.element.setAttribute("stroke-dasharray", t) } } destroy() { let t = this, e = t.element || {}, i = t.renderer, s = e.ownerSVGElement, o = e.nodeName === "SPAN" && t.parentGroup || void 0, r, a; if (e.onclick = e.onmouseout = e.onmouseover = e.onmousemove = e.point = null, Pa(t), t.clipPath && s) { let n = t.clipPath;[].forEach.call(s.querySelectorAll("[clip-path],[CLIP-PATH]"), function (l) { l.getAttribute("clip-path").indexOf(n.element.id) > -1 && l.removeAttribute("clip-path") }), t.clipPath = n.destroy() } if (t.stops) { for (a = 0; a < t.stops.length; a++)t.stops[a].destroy(); t.stops.length = 0, t.stops = void 0 } for (t.safeRemoveChild(e); o != null && o.div && o.div.childNodes.length === 0;)r = o.parentGroup, t.safeRemoveChild(o.div), delete o.div, o = r; t.alignOptions && Md(i.alignedObjects, t), Ue(t, (n, l) => { var c, d, p; (((c = t[l]) == null ? void 0 : c.parentGroup) === t || ["connector", "foreignObject"].indexOf(l) !== -1) && ((p = (d = t[l]) == null ? void 0 : d.destroy) == null || p.call(d)), delete t[l] }) } dSetter(t, e, i) { Ea(t) && (typeof t[0] == "string" && (t = this.renderer.pathToSegments(t)), this.pathArray = t, t = t.reduce((s, o, r) => o != null && o.join ? (r ? s + " " : "") + o.join(" ") : (o || "").toString(), "")), /(NaN| {2}|^$)/.test(t) && (t = "M 0 0"), this[e] !== t && (i.setAttribute(e, t), this[e] = t) } fillSetter(t, e, i) { typeof t == "string" ? i.setAttribute(e, t) : t && this.complexColor(t, e, i) } hrefSetter(t, e, i) { i.setAttributeNS("http://www.w3.org/1999/xlink", e, t) } getBBox(t, e) { let i, s, o, r, { alignValue: a, element: n, renderer: l, styles: c, textStr: d } = this, { cache: p, cacheKeys: u } = l, g = n.namespaceURI === this.SVG_NS, m = Zt(e, this.rotation, 0), f = l.styledMode ? n && dt.prototype.getStyle.call(n, "font-size") : c.fontSize; if (jt(d) && ((r = d.toString()).indexOf("<") === -1 && (r = r.replace(/\d/g, "0")), r += ["", l.rootFontSize, f, m, this.textWidth, a, c.lineClamp, c.textOverflow, c.fontWeight].join(",")), r && !t && (i = p[r]), !i || i.polygon) { if (g || l.forExport) { try { o = this.fakeTS && function (x) { let b = n.querySelector(".highcharts-text-outline"); b && Oa(b, { display: x }) }, Ia(o) && o("none"), i = n.getBBox ? ui({}, n.getBBox()) : { width: n.offsetWidth, height: n.offsetHeight, x: 0, y: 0 }, Ia(o) && o("") } catch { } (!i || i.width < 0) && (i = { x: 0, y: 0, width: 0, height: 0 }) } else i = this.htmlGetBBox(); s = i.height, g && (i.height = s = { "11px,17": 14, "13px,20": 16 }[`${f || ""},${Math.round(s)}`] || s), m && (i = this.getRotatedBox(i, m)); let y = { bBox: i }; Io(this, "afterGetBBox", y), i = y.bBox } if (r && (d === "" || i.height > 0)) { for (; u.length > 250;)delete p[u.shift()]; p[r] || u.push(r), p[r] = i } return i } getRotatedBox(t, e) { let { x: i, y: s, width: o, height: r } = t, { alignValue: a, translateY: n, rotationOriginX: l = 0, rotationOriginY: c = 0 } = this, d = Do(a), p = Number(this.element.getAttribute("y") || 0) - (n ? 0 : s), u = e * La, g = (e - 90) * La, m = Math.cos(u), f = Math.sin(u), y = o * m, x = o * f, b = Math.cos(g), w = Math.sin(g), [[v, S], [A, M]] = [l, c].map(F => [F - F * m, F * f]), k = i + d * (o - y) + v + M + p * b, T = k + y, P = T - r * b, L = P - y, O = s + p - d * x - S + A + p * w, B = O + x, D = B - r * w, z = D - x, E = Math.min(k, T, P, L), N = Math.min(O, B, D, z), V = Math.max(k, T, P, L) - E, W = Math.max(O, B, D, z) - N; return { x: E, y: N, width: V, height: W, polygon: [[k, O], [T, B], [P, D], [L, z]] } } getStyle(t) { return bd.getComputedStyle(this.element || this, "").getPropertyValue(t) } hasClass(t) { return ("" + this.attr("class")).split(" ").indexOf(t) !== -1 } hide() { return this.attr({ visibility: "hidden" }) } htmlGetBBox() { return { height: 0, width: 0, x: 0, y: 0 } } constructor(t, e) { this.onEvents = {}, this.opacity = 1, this.SVG_NS = qi, this.element = e === "span" || e === "body" ? Sd(e) : Ne.createElementNS(this.SVG_NS, e), this.renderer = t, this.styles = {}, Io(this, "afterInit") } on(t, e) { let { onEvents: i } = this; return i[t] && i[t](), i[t] = wd(this.element, t, e), this } opacitySetter(t, e, i) { let s = Number(Number(t).toFixed(3)); this.opacity = s, i.setAttribute(e, s) } reAlign() { var t; (t = this.alignOptions) != null && t.width && this.alignOptions.align !== "left" && (this.alignOptions.width = this.getBBox().width, this.placed = !1, this.align()) } removeClass(t) { return this.attr("class", ("" + this.attr("class")).replace(Da(t) ? RegExp(`(^| )${t}( |$)`) : t, " ").replace(/ +/g, " ").trim()) } removeTextOutline() { let t = this.element.querySelector("tspan.highcharts-text-outline"); t && this.safeRemoveChild(t) } safeRemoveChild(t) { let e = t.parentNode; e && e.removeChild(t) } setRadialReference(t) { let e = this.element.gradient && this.renderer.gradients[this.element.gradient] || void 0; return this.element.radialReference = t, e != null && e.radAttr && e.animate(this.renderer.getRadialAttr(t, e.radAttr)), this } shadow(t) { var o; let { renderer: e } = this, i = Bo(((o = this.parentGroup) == null ? void 0 : o.rotation) === 90 ? { offsetX: -1, offsetY: -1 } : {}, Ad(t) ? t : {}), s = e.shadowDefinition(i); return this.attr({ filter: t ? `url(${e.url}#${s})` : "none" }) } show(t = !0) { return this.attr({ visibility: t ? "inherit" : "visible" }) } "stroke-widthSetter"(t, e, i) { this[e] = t, i.setAttribute(e, t) } strokeWidth() { if (!this.renderer.styledMode) return this["stroke-width"] || 0; let t = this.getStyle("stroke-width"), e = 0, i; return /px$/.test(t) ? e = Ji(t) : t !== "" && (Eo(i = Ne.createElementNS(qi, "rect"), { width: t, "stroke-width": 0 }), this.element.parentNode.appendChild(i), e = i.getBBox().width, i.parentNode.removeChild(i)), e } symbolAttr(t) { let e = this; dt.symbolCustomAttribs.forEach(function (i) { e[i] = Zt(t[i], e[i]) }), e.attr({ d: e.renderer.symbols[e.symbolName](e.x, e.y, e.width, e.height, e) }) } textSetter(t) { t !== this.textStr && (delete this.textPxLength, this.textStr = t, this.added && this.renderer.buildText(this), this.reAlign()) } titleSetter(t) { let e = this.element, i = e.getElementsByTagName("title")[0] || Ne.createElementNS(this.SVG_NS, "title"); e.insertBefore ? e.insertBefore(i, e.firstChild) : e.appendChild(i), i.textContent = Td(Zt(t, ""), [/<[^>]*>/g, ""]).replace(/&lt;/g, "<").replace(/&gt;/g, ">") } toFront() { let t = this.element; return t.parentNode.appendChild(t), this } translate(t, e) { return this.attr({ translateX: t, translateY: e }) } updateTransform(t = "transform") { let { element: e, foreignObject: i, matrix: s, padding: o, rotation: r = 0, rotationOriginX: a, rotationOriginY: n, scaleX: l, scaleY: c, text: d, translateX: p = 0, translateY: u = 0 } = this, g = ["translate(" + p + "," + u + ")"]; jt(s) && g.push("matrix(" + s.join(",") + ")"), r && (g.push("rotate(" + r + " " + (a ?? e.getAttribute("x") ?? this.x ?? 0) + " " + (n ?? e.getAttribute("y") ?? this.y ?? 0) + ")"), (d == null ? void 0 : d.element.tagName) !== "SPAN" || d != null && d.foreignObject || d.attr({ rotation: r, rotationOriginX: (a || 0) - o, rotationOriginY: (n || 0) - o })), (jt(l) || jt(c)) && g.push("scale(" + Zt(l, 1) + " " + Zt(c, 1) + ")"), g.length && !(d || this).textPath && ((i == null ? void 0 : i.element) || e).setAttribute(t, g.join(" ")) } visibilitySetter(t, e, i) { t === "inherit" ? i.removeAttribute(e) : this[e] !== t && i.setAttribute(e, t), this[e] = t } xGetter(t) { return this.element.nodeName === "circle" && (t === "x" ? t = "cx" : t === "y" && (t = "cy")), this._defaultGetter(t) } zIndexSetter(t, e) { let i = this.renderer, s = this.parentGroup, o = (s || i).element || i.box, r = this.element, a = o === i.box, n, l, c, d = !1, p, u = this.added, g; if (jt(t) ? (r.setAttribute("data-z-index", t), t *= 1, this[e] === t && (u = !1)) : jt(this[e]) && r.removeAttribute("data-z-index"), this[e] = t, u) { for ((t = this.zIndex) && s && (s.handleZ = !0), g = (n = o.childNodes).length - 1; g >= 0 && !d; g--)p = !jt(c = (l = n[g]).getAttribute("data-z-index")), l !== r && (t < 0 && p && !a && !g ? (o.insertBefore(r, n[g]), d = !0) : (Ji(c) <= t || p && (!jt(t) || t >= 0)) && (o.insertBefore(r, n[g + 1]), d = !0)); d || (o.insertBefore(r, n[3 * !!a]), d = !0) } return d } } dt.symbolCustomAttribs = ["anchorX", "anchorY", "clockwise", "end", "height", "innerR", "r", "start", "width", "x", "y"], dt.prototype.strokeSetter = dt.prototype.fillSetter, dt.prototype.yGetter = dt.prototype.xGetter, dt.prototype.matrixSetter = dt.prototype.rotationOriginXSetter = dt.prototype.rotationOriginYSetter = dt.prototype.rotationSetter = dt.prototype.scaleXSetter = dt.prototype.scaleYSetter = dt.prototype.translateXSetter = dt.prototype.translateYSetter = dt.prototype.verticalAlignSetter = function (h, t) { this[t] = h, this.doTransform = !0 }; let Dt = dt, { defined: za, extend: Ld, getAlignFactor: Na, isNumber: gi, merge: Od, pick: Qi, removeEvent: Ua } = I; class ge extends Dt { constructor(t, e, i, s, o, r, a, n, l, c) { let d; super(t, "g"), this.paddingLeftSetter = this.paddingSetter, this.paddingRightSetter = this.paddingSetter, this.doUpdate = !1, this.textStr = e, this.x = i, this.y = s, this.anchorX = r, this.anchorY = a, this.baseline = l, this.className = c, this.addClass(c === "button" ? "highcharts-no-tooltip" : "highcharts-label"), c && this.addClass("highcharts-" + c), this.text = t.text(void 0, 0, 0, n).attr({ zIndex: 1 }), typeof o == "string" && ((d = /^url\((.*?)\)$/.test(o)) || this.renderer.symbols[o]) && (this.symbolKey = o), this.bBox = ge.emptyBBox, this.padding = 3, this.baselineOffset = 0, this.needsBox = t.styledMode || d, this.deferredAttr = {}, this.alignFactor = 0 } alignSetter(t) { let e = Na(t); this.textAlign = t, e !== this.alignFactor && (this.alignFactor = e, this.bBox && gi(this.xSetting) && this.attr({ x: this.xSetting })) } anchorXSetter(t, e) { this.anchorX = t, this.boxAttr(e, Math.round(t) - this.getCrispAdjust() - this.xSetting) } anchorYSetter(t, e) { this.anchorY = t, this.boxAttr(e, t - this.ySetting) } boxAttr(t, e) { this.box ? this.box.attr(t, e) : this.deferredAttr[t] = e } css(t) { if (t) { let e = {}; t = Od(t), ge.textProps.forEach(i => { t[i] !== void 0 && (e[i] = t[i], delete t[i]) }), this.text.css(e), "fontSize" in e || "fontWeight" in e ? this.updateTextPadding() : ("width" in e || "textOverflow" in e) && this.updateBoxSize() } return Dt.prototype.css.call(this, t) } destroy() { Ua(this.element, "mouseenter"), Ua(this.element, "mouseleave"), this.text && this.text.destroy(), this.box && (this.box = this.box.destroy()), Dt.prototype.destroy.call(this) } fillSetter(t, e) { t && (this.needsBox = !0), this.fill = t, this.boxAttr(e, t) } getBBox(t, e) { this.textStr && this.bBox.width === 0 && this.bBox.height === 0 && this.updateBoxSize(); let { padding: i, height: s = 0, translateX: o = 0, translateY: r = 0, width: a = 0 } = this, n = Qi(this.paddingLeft, i), l = e ?? (this.rotation || 0), c = { width: a, height: s, x: o + this.bBox.x - n, y: r + this.bBox.y - i + this.baselineOffset }; return l && (c = this.getRotatedBox(c, l)), c } getCrispAdjust() { return (this.renderer.styledMode && this.box ? this.box.strokeWidth() : this["stroke-width"] ? parseInt(this["stroke-width"], 10) : 0) % 2 / 2 } heightSetter(t) { this.heightSetting = t, this.doUpdate = !0 } afterSetters() { super.afterSetters(), this.doUpdate && (this.updateBoxSize(), this.doUpdate = !1) } onAdd() { this.text.add(this), this.attr({ text: Qi(this.textStr, ""), x: this.x || 0, y: this.y || 0 }), this.box && za(this.anchorX) && this.attr({ anchorX: this.anchorX, anchorY: this.anchorY }) } paddingSetter(t, e) { gi(t) ? t !== this[e] && (this[e] = t, this.updateTextPadding()) : this[e] = void 0 } rSetter(t, e) { this.boxAttr(e, t) } strokeSetter(t, e) { this.stroke = t, this.boxAttr(e, t) } "stroke-widthSetter"(t, e) { t && (this.needsBox = !0), this["stroke-width"] = t, this.boxAttr(e, t) } "text-alignSetter"(t) { this.textAlign = this["text-align"] = t, this.updateTextPadding() } textSetter(t) { t !== void 0 && this.text.attr({ text: t }), this.updateTextPadding(), this.reAlign() } updateBoxSize() { let t, e = this.text, i = {}, s = this.padding, o = this.bBox = (!gi(this.widthSetting) || !gi(this.heightSetting) || this.textAlign) && za(e.textStr) ? e.getBBox(void 0, 0) : ge.emptyBBox; this.width = this.getPaddedWidth(), this.height = (this.heightSetting || o.height || 0) + 2 * s; let r = this.renderer.fontMetrics(e); if (this.baselineOffset = s + Math.min((this.text.firstLineMetrics || r).b, o.height || 1 / 0), this.heightSetting && (this.baselineOffset += (this.heightSetting - r.h) / 2), this.needsBox && !e.textPath) { if (!this.box) { let a = this.box = this.symbolKey ? this.renderer.symbol(this.symbolKey) : this.renderer.rect(); a.addClass((this.className === "button" ? "" : "highcharts-label-box") + (this.className ? " highcharts-" + this.className + "-box" : "")), a.add(this) } i.x = t = this.getCrispAdjust(), i.y = (this.baseline ? -this.baselineOffset : 0) + t, i.width = Math.round(this.width), i.height = Math.round(this.height), this.box.attr(Ld(i, this.deferredAttr)), this.deferredAttr = {} } } updateTextPadding() { let t = this.text, e = t.styles.textAlign || this.textAlign; if (!t.textPath) { this.updateBoxSize(); let i = this.baseline ? 0 : this.baselineOffset, s = (this.paddingLeft ?? this.padding) + Na(e) * (this.widthSetting ?? this.bBox.width); (s !== t.x || i !== t.y) && (t.attr({ align: e, x: s }), i !== void 0 && t.attr("y", i)), t.x = s, t.y = i } } widthSetter(t) { this.widthSetting = gi(t) ? t : void 0, this.doUpdate = !0 } getPaddedWidth() { let t = this.padding, e = Qi(this.paddingLeft, t), i = Qi(this.paddingRight, t); return (this.widthSetting || this.bBox.width || 0) + e + i } xSetter(t) { this.x = t, this.alignFactor && (t -= this.alignFactor * this.getPaddedWidth(), this["forceAnimate:x"] = !0), this.xSetting = Math.round(t), this.attr("translateX", this.xSetting) } ySetter(t) { this.ySetting = this.y = Math.round(t), this.attr("translateY", this.ySetting) } } ge.emptyBBox = { width: 0, height: 0, x: 0, y: 0 }, ge.textProps = ["color", "direction", "fontFamily", "fontSize", "fontStyle", "fontWeight", "lineClamp", "lineHeight", "textAlign", "textDecoration", "textOutline", "textOverflow", "whiteSpace", "width"]; let { defined: ja, isNumber: Ed, pick: mi } = I; function Ra(h, t, e, i, s) { let o = []; if (s) { let r = s.start || 0, a = s.end || 0, n = mi(s.r, e), l = mi(s.r, i || e), c = 2e-4 / (s.borderRadius ? 1 : Math.max(n, 1)), d = Math.abs(a - r - 2 * Math.PI) < c; d && (r = Math.PI / 2, a = 2.5 * Math.PI - c); let p = s.innerR, u = mi(s.open, d), g = Math.cos(r), m = Math.sin(r), f = Math.cos(a), y = Math.sin(a), x = mi(s.longArc, a - r - Math.PI < c ? 0 : 1), b = ["A", n, l, 0, x, mi(s.clockwise, 1), h + n * f, t + l * y]; b.params = { start: r, end: a, cx: h, cy: t }, o.push(["M", h + n * g, t + l * m], b), ja(p) && ((b = ["A", p, p, 0, x, ja(s.clockwise) ? 1 - s.clockwise : 0, h + p * g, t + p * m]).params = { start: a, end: r, cx: h, cy: t }, o.push(u ? ["M", h + p * f, t + p * y] : ["L", h + p * f, t + p * y], b)), u || o.push(["Z"]) } return o } function Wa(h, t, e, i, s) { return s != null && s.r ? zo(h, t, e, i, s) : [["M", h, t], ["L", h + e, t], ["L", h + e, t + i], ["L", h, t + i], ["Z"]] } function zo(h, t, e, i, s) { let o = (s == null ? void 0 : s.r) || 0; return [["M", h + o, t], ["L", h + e - o, t], ["A", o, o, 0, 0, 1, h + e, t + o], ["L", h + e, t + i - o], ["A", o, o, 0, 0, 1, h + e - o, t + i], ["L", h + o, t + i], ["A", o, o, 0, 0, 1, h, t + i - o], ["L", h, t + o], ["A", o, o, 0, 0, 1, h + o, t], ["Z"]] } let Fa = { arc: Ra, callout: function (h, t, e, i, s) { let o = Math.min((s == null ? void 0 : s.r) || 0, e, i), r = o + 6, a = s == null ? void 0 : s.anchorX, n = (s == null ? void 0 : s.anchorY) || 0, l = zo(h, t, e, i, { r: o }); if (!Ed(a) || a < e && a > 0 && n < i && n > 0) return l; if (h + a > e - r) if (n > t + r && n < t + i - r) l.splice(3, 1, ["L", h + e, n - 6], ["L", h + e + 6, n], ["L", h + e, n + 6], ["L", h + e, t + i - o]); else if (a < e) { let c = n < t + r, d = c ? t : t + i; l.splice(c ? 2 : 5, 0, ["L", a, n], ["L", h + e - o, d]) } else l.splice(3, 1, ["L", h + e, i / 2], ["L", a, n], ["L", h + e, i / 2], ["L", h + e, t + i - o]); else if (h + a < r) if (n > t + r && n < t + i - r) l.splice(7, 1, ["L", h, n + 6], ["L", h - 6, n], ["L", h, n - 6], ["L", h, t + o]); else if (a > 0) { let c = n < t + r, d = c ? t : t + i; l.splice(c ? 1 : 6, 0, ["L", a, n], ["L", h + o, d]) } else l.splice(7, 1, ["L", h, i / 2], ["L", a, n], ["L", h, i / 2], ["L", h, t + o]); else n > i && a < e - r ? l.splice(5, 1, ["L", a + 6, t + i], ["L", a, t + i + 6], ["L", a - 6, t + i], ["L", h + o, t + i]) : n < 0 && a > r && l.splice(1, 1, ["L", a - 6, t], ["L", a, t - 6], ["L", a + 6, t], ["L", e - o, t]); return l }, circle: function (h, t, e, i) { return Ra(h + e / 2, t + i / 2, e / 2, i / 2, { start: .5 * Math.PI, end: 2.5 * Math.PI, open: !1 }) }, diamond: function (h, t, e, i) { return [["M", h + e / 2, t], ["L", h + e, t + i / 2], ["L", h + e / 2, t + i], ["L", h, t + i / 2], ["Z"]] }, rect: Wa, roundedRect: zo, square: Wa, triangle: function (h, t, e, i) { return [["M", h + e / 2, t], ["L", h + e, t + i], ["L", h, t + i], ["Z"]] }, "triangle-down": function (h, t, e, i) { return [["M", h, t], ["L", h + e, t], ["L", h + e / 2, t + i], ["Z"]] } }, { doc: No, SVG_NS: Id, win: Xa } = C, { attr: Uo, extend: Dd, fireEvent: Bd, isString: zd, objectEach: Nd, pick: Ud } = I, jo = (h, t) => h.substring(0, t) + "…", jd = class { constructor(h) { let t = h.styles; this.renderer = h.renderer, this.svgElement = h, this.width = h.textWidth, this.textLineHeight = t == null ? void 0 : t.lineHeight, this.textOutline = t == null ? void 0 : t.textOutline, this.ellipsis = (t == null ? void 0 : t.textOverflow) === "ellipsis", this.lineClamp = t == null ? void 0 : t.lineClamp, this.noWrap = (t == null ? void 0 : t.whiteSpace) === "nowrap" } buildSVG() { let h = this.svgElement, t = h.element, e = h.renderer, i = Ud(h.textStr, "").toString(), s = i.indexOf("<") !== -1, o = t.childNodes, r = !h.added && e.box, a = [i, this.ellipsis, this.noWrap, this.textLineHeight, this.textOutline, h.getStyle("font-size"), h.styles.lineClamp, this.width].join(","); if (a !== h.textCache) { h.textCache = a, delete h.actualWidth; for (let n = o.length; n--;)t.removeChild(o[n]); if (s || this.ellipsis || this.width || h.textPath || i.indexOf(" ") !== -1 && (!this.noWrap || /<br.*?>/g.test(i))) { if (i !== "") { r && r.appendChild(t); let n = new et(i); this.modifyTree(n.nodes), n.addToDOM(t), this.modifyDOM(), this.ellipsis && (t.textContent || "").indexOf("…") !== -1 && h.attr("title", this.unescapeEntities(h.textStr || "", ["&lt;", "&gt;"])), r && r.removeChild(t) } } else t.appendChild(No.createTextNode(this.unescapeEntities(i))); zd(this.textOutline) && h.applyTextOutline && h.applyTextOutline(this.textOutline) } } modifyDOM() { let h, t = this.svgElement, e = Uo(t.element, "x"); for (t.firstLineMetrics = void 0; (h = t.element.firstChild) && /^[\s\u200B]*$/.test(h.textContent || " ");)t.element.removeChild(h);[].forEach.call(t.element.querySelectorAll("tspan.highcharts-br"), (r, a) => { r.nextSibling && r.previousSibling && (a === 0 && r.previousSibling.nodeType === 1 && (t.firstLineMetrics = t.renderer.fontMetrics(r.previousSibling)), Uo(r, { dy: this.getLineHeight(r.nextSibling), x: e })) }); let i = this.width || 0; if (!i) return; let s = (r, a) => { var m; let n = r.textContent || "", l = n.replace(/([^\^])-/g, "$1- ").split(" "), c = !this.noWrap && (l.length > 1 || t.element.childNodes.length > 1), d = this.getLineHeight(a), p = Math.max(0, i - .8 * d), u = 0, g = t.actualWidth; if (c) { let f = [], y = []; for (; a.firstChild && a.firstChild !== r;)y.push(a.firstChild), a.removeChild(a.firstChild); for (; l.length;)if (l.length && !this.noWrap && u > 0 && (f.push(r.textContent || ""), r.textContent = l.join(" ").replace(/- /g, "-")), this.truncate(r, void 0, l, u === 0 && g || 0, i, p, (x, b) => l.slice(0, b).join(" ").replace(/- /g, "-")), g = t.actualWidth, u++, this.lineClamp && u >= this.lineClamp) { l.length && (this.truncate(r, r.textContent || "", void 0, 0, i, p, jo), r.textContent = ((m = r.textContent) == null ? void 0 : m.replace("…", "")) + "…"); break } y.forEach(x => { a.insertBefore(x, r) }), f.forEach(x => { a.insertBefore(No.createTextNode(x), r); let b = No.createElementNS(Id, "tspan"); b.textContent = "​", Uo(b, { dy: d, x: e }), a.insertBefore(b, r) }) } else this.ellipsis && n && this.truncate(r, n, void 0, 0, i, p, jo) }, o = r => { [].slice.call(r.childNodes).forEach(a => { a.nodeType === Xa.Node.TEXT_NODE ? s(a, r) : (a.className.baseVal.indexOf("highcharts-br") !== -1 && (t.actualWidth = 0), o(a)) }) }; o(t.element) } getLineHeight(h) { let t = h.nodeType === Xa.Node.TEXT_NODE ? h.parentElement : h; return this.textLineHeight ? parseInt(this.textLineHeight.toString(), 10) : this.renderer.fontMetrics(t || this.svgElement.element).h } modifyTree(h) { let t = (e, i) => { let { attributes: s = {}, children: o, style: r = {}, tagName: a } = e, n = this.renderer.styledMode; if (a === "b" || a === "strong" ? n ? s.class = "highcharts-strong" : r.fontWeight = "bold" : (a === "i" || a === "em") && (n ? s.class = "highcharts-emphasized" : r.fontStyle = "italic"), r != null && r.color && (r.fill = r.color), a === "br") { s.class = "highcharts-br", e.textContent = "​"; let l = h[i + 1]; l != null && l.textContent && (l.textContent = l.textContent.replace(/^ +/gm, "")) } else a === "a" && o && o.some(l => l.tagName === "#text") && (e.children = [{ children: o, tagName: "tspan" }]); a !== "#text" && a !== "a" && (e.tagName = "tspan"), Dd(e, { attributes: s, style: r }), o && o.filter(l => l.tagName !== "#text").forEach(t) }; h.forEach(t), Bd(this.svgElement, "afterModifyTree", { nodes: h }) } truncate(h, t, e, i, s, o, r) { let a, n, l = this.svgElement, { rotation: c } = l, d = [], p = e && !i ? 1 : 0, u = (t || e || "").length, g = u; e || (s = o); let m = function (f, y) { let x = y || f, b = h.parentNode; if (b && d[x] === void 0 && b.getSubStringLength) try { d[x] = i + b.getSubStringLength(0, e ? x + 1 : x) } catch { } return d[x] }; if (l.rotation = 0, i + (n = m(h.textContent.length)) > s) { for (; p <= u;)g = Math.ceil((p + u) / 2), e && (a = r(e, g)), n = m(g, a && a.length - 1), p === u ? p = u + 1 : n > s ? u = g - 1 : p = g; u === 0 ? h.textContent = "" : t && u === t.length - 1 || (h.textContent = a || r(t || e, g)), this.ellipsis && n > s && this.truncate(h, h.textContent || "", void 0, 0, s, o, jo) } e && e.splice(0, g), l.actualWidth = n, l.rotation = c } unescapeEntities(h, t) { return Nd(this.renderer.escapes, function (e, i) { t && t.indexOf(e) !== -1 || (h = h.toString().replace(RegExp(e, "g"), i)) }), h } }, { defaultOptions: Rd } = wt, { charts: Wd, deg2rad: Ya, doc: je, isFirefox: Ha, isMS: Ga, isWebKit: Fd, noop: Xd, SVG_NS: Yd, symbolSizes: Ro, win: Wo } = C, { addEvent: ts, attr: es, createElement: Hd, crisp: Va, css: is, defined: me, destroyObjectProperties: Gd, extend: fe, isArray: Vd, isNumber: Re, isObject: fi, isString: Zd, merge: Fo, pick: Xo, pInt: $d, replaceNested: Kd, uniqueKey: qd } = I; class ye { constructor(t, e, i, s, o, r, a) { let n, l; this.x = 0, this.y = 0; let c = this.createElement("svg").attr({ version: "1.1", class: "highcharts-root" }), d = c.element; a || c.css(this.getStyle(s || {})), t.appendChild(d), es(t, "dir", "ltr"), t.innerHTML.indexOf("xmlns") === -1 && es(d, "xmlns", this.SVG_NS), this.box = d, this.boxWrapper = c, this.alignedObjects = [], this.url = this.getReferenceURL(), this.createElement("desc").add().element.appendChild(je.createTextNode("Created with Highcharts 12.3.0")), this.defs = this.createElement("defs").add(), this.allowHTML = r, this.forExport = o, this.styledMode = a, this.gradients = {}, this.cache = {}, this.cacheKeys = [], this.imgCount = 0, this.rootFontSize = c.getStyle("font-size"), this.setSize(e, i, !1), Ha && t.getBoundingClientRect && ((n = function () { is(t, { left: 0, top: 0 }), l = t.getBoundingClientRect(), is(t, { left: Math.ceil(l.left) - l.left + "px", top: Math.ceil(l.top) - l.top + "px" }) })(), this.unSubPixelFix = ts(Wo, "resize", n)) } definition(t) { return new et([t]).addToDOM(this.defs.element) } getReferenceURL() { if ((Ha || Fd) && je.getElementsByTagName("base").length) { if (!me(ce)) { let t = qd(), e = new et([{ tagName: "svg", attributes: { width: 8, height: 8 }, children: [{ tagName: "defs", children: [{ tagName: "clipPath", attributes: { id: t }, children: [{ tagName: "rect", attributes: { width: 4, height: 4 } }] }] }, { tagName: "rect", attributes: { id: "hitme", width: 8, height: 8, "clip-path": `url(#${t})`, fill: "rgba(0,0,0,0.001)" } }] }]).addToDOM(je.body); is(e, { position: "fixed", top: 0, left: 0, zIndex: 9e5 }); let i = je.elementFromPoint(6, 6); ce = (i == null ? void 0 : i.id) === "hitme", je.body.removeChild(e) } if (ce) return Kd(Wo.location.href.split("#")[0], [/<[^>]*>/g, ""], [/([\('\)])/g, "\\$1"], [/ /g, "%20"]) } return "" } getStyle(t) { return this.style = fe({ fontFamily: '-apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, "Apple Color Emoji", "Segoe UI Emoji", "Segoe UI Symbol", sans-serif', fontSize: "1rem" }, t), this.style } setStyle(t) { this.boxWrapper.css(this.getStyle(t)) } isHidden() { return !this.boxWrapper.getBBox().width } destroy() { let t = this.defs; return this.box = null, this.boxWrapper = this.boxWrapper.destroy(), Gd(this.gradients || {}), this.gradients = null, this.defs = t.destroy(), this.unSubPixelFix && this.unSubPixelFix(), this.alignedObjects = null, null } createElement(t) { return new this.Element(this, t) } getRadialAttr(t, e) { return { cx: t[0] - t[2] / 2 + (e.cx || 0) * t[2], cy: t[1] - t[2] / 2 + (e.cy || 0) * t[2], r: (e.r || 0) * t[2] } } shadowDefinition(t) { let e = [`highcharts-drop-shadow-${this.chartIndex}`, ...Object.keys(t).map(s => `${s}-${t[s]}`)].join("-").toLowerCase().replace(/[^a-z\d\-]/g, ""), i = Fo({ color: "#000000", offsetX: 1, offsetY: 1, opacity: .15, width: 5 }, t); return this.defs.element.querySelector(`#${e}`) || this.definition({ tagName: "filter", attributes: { id: e, filterUnits: i.filterUnits }, children: this.getShadowFilterContent(i) }), e } getShadowFilterContent(t) { return [{ tagName: "feDropShadow", attributes: { dx: t.offsetX, dy: t.offsetY, "flood-color": t.color, "flood-opacity": Math.min(5 * t.opacity, 1), stdDeviation: t.width / 2 } }] } buildText(t) { new jd(t).buildSVG() } getContrast(t) { if (t === "transparent") return "#000000"; let e = _.parse(t).rgba, i = " clamp(0,calc(9e9*(0.5 - (0.2126*r + 0.7152*g + 0.0722*b))),1)"; if (Re(e[0]) || !_.useColorMix) { let s = e.map(r => { let a = r / 255; return a <= .04 ? a / 12.92 : Math.pow((a + .055) / 1.055, 2.4) }), o = .2126 * s[0] + .7152 * s[1] + .0722 * s[2]; return 1.05 / (o + .05) > (o + .05) / .05 ? "#FFFFFF" : "#000000" } return "color(from " + t + " srgb" + i + i + i + ")" } button(t, e, i, s, o = {}, r, a, n, l, c) { let d = this.label(t, e, i, l, void 0, void 0, c, void 0, "button"), p = this.styledMode, u = arguments, g = 0; o = Fo(Rd.global.buttonTheme, o), p && (delete o.fill, delete o.stroke, delete o["stroke-width"]); let m = o.states || {}, f = o.style || {}; delete o.states, delete o.style; let y = [et.filterUserAttributes(o)], x = [f]; return p || ["hover", "select", "disabled"].forEach((b, w) => { y.push(Fo(y[0], et.filterUserAttributes(u[w + 5] || m[b] || {}))), x.push(y[w + 1].style), delete y[w + 1].style }), ts(d.element, Ga ? "mouseover" : "mouseenter", function () { g !== 3 && d.setState(1) }), ts(d.element, Ga ? "mouseout" : "mouseleave", function () { g !== 3 && d.setState(g) }), d.setState = (b = 0) => { if (b !== 1 && (d.state = g = b), d.removeClass(/highcharts-button-(normal|hover|pressed|disabled)/).addClass("highcharts-button-" + ["normal", "hover", "pressed", "disabled"][b]), !p) { d.attr(y[b]); let w = x[b]; fi(w) && d.css(w) } }, d.attr(y[0]), !p && (d.css(fe({ cursor: "default" }, f)), c && d.text.css({ pointerEvents: "none" })), d.on("touchstart", b => b.stopPropagation()).on("click", function (b) { g !== 3 && (s == null || s.call(d, b)) }) } crispLine(t, e) { let [i, s] = t; return me(i[1]) && i[1] === s[1] && (i[1] = s[1] = Va(i[1], e)), me(i[2]) && i[2] === s[2] && (i[2] = s[2] = Va(i[2], e)), t } path(t) { let e = this.styledMode ? {} : { fill: "none" }; return Vd(t) ? e.d = t : fi(t) && fe(e, t), this.createElement("path").attr(e) } circle(t, e, i) { let s = fi(t) ? t : t === void 0 ? {} : { x: t, y: e, r: i }, o = this.createElement("circle"); return o.xSetter = o.ySetter = function (r, a, n) { n.setAttribute("c" + a, r) }, o.attr(s) } arc(t, e, i, s, o, r) { let a; fi(t) ? (e = (a = t).y, i = a.r, s = a.innerR, o = a.start, r = a.end, t = a.x) : a = { innerR: s, start: o, end: r }; let n = this.symbol("arc", t, e, i, i, a); return n.r = i, n } rect(t, e, i, s, o, r) { let a = fi(t) ? t : t === void 0 ? {} : { x: t, y: e, r: o, width: Math.max(i || 0, 0), height: Math.max(s || 0, 0) }, n = this.createElement("rect"); return this.styledMode || (r !== void 0 && (a["stroke-width"] = r, fe(a, n.crisp(a))), a.fill = "none"), n.rSetter = function (l, c, d) { n.r = l, es(d, { rx: l, ry: l }) }, n.rGetter = function () { return n.r || 0 }, n.attr(a) } roundedRect(t) { return this.symbol("roundedRect").attr(t) } setSize(t, e, i) { this.width = t, this.height = e, this.boxWrapper.animate({ width: t, height: e }, { step: function () { this.attr({ viewBox: "0 0 " + this.attr("width") + " " + this.attr("height") }) }, duration: Xo(i, !0) ? void 0 : 0 }), this.alignElements() } g(t) { let e = this.createElement("g"); return t ? e.attr({ class: "highcharts-" + t }) : e } image(t, e, i, s, o, r) { let a = { preserveAspectRatio: "none" }; Re(e) && (a.x = e), Re(i) && (a.y = i), Re(s) && (a.width = s), Re(o) && (a.height = o); let n = this.createElement("image").attr(a), l = function (c) { n.attr({ href: t }), r.call(n, c) }; if (r) { n.attr({ href: "data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" }); let c = new Wo.Image; ts(c, "load", l), c.src = t, c.complete && l({}) } else n.attr({ href: t }); return n } symbol(t, e, i, s, o, r) { var f, y; let a, n, l, c, d = this, p = /^url\((.*?)\)$/, u = p.test(t), g = !u && (this.symbols[t] ? t : "circle"), m = g && this.symbols[g]; if (m) typeof e == "number" && (n = m.call(this.symbols, e || 0, i || 0, s || 0, o || 0, r)), a = this.path(n), d.styledMode || a.attr("fill", "none"), fe(a, { symbolName: g || void 0, x: e, y: i, width: s, height: o }), r && fe(a, r); else if (u) { l = t.match(p)[1]; let x = a = this.image(l); x.imgwidth = Xo(r == null ? void 0 : r.width, (f = Ro[l]) == null ? void 0 : f.width), x.imgheight = Xo(r == null ? void 0 : r.height, (y = Ro[l]) == null ? void 0 : y.height), c = b => b.attr({ width: b.width, height: b.height }), ["width", "height"].forEach(b => { x[`${b}Setter`] = function (w, v) { this[v] = w; let { alignByTranslate: S, element: A, width: M, height: k, imgwidth: T, imgheight: P } = this, L = v === "width" ? T : P, O = 1; r && r.backgroundSize === "within" && M && k && T && P ? (O = Math.min(M / T, k / P), es(A, { width: Math.round(T * O), height: Math.round(P * O) })) : A && L && A.setAttribute(v, L), !S && T && P && this.translate(((M || 0) - T * O) / 2, ((k || 0) - P * O) / 2) } }), me(e) && x.attr({ x: e, y: i }), x.isImg = !0, x.symbolUrl = t, me(x.imgwidth) && me(x.imgheight) ? c(x) : (x.attr({ width: 0, height: 0 }), Hd("img", { onload: function () { let b = Wd[d.chartIndex]; this.width === 0 && (is(this, { position: "absolute", top: "-999em" }), je.body.appendChild(this)), Ro[l] = { width: this.width, height: this.height }, x.imgwidth = this.width, x.imgheight = this.height, x.element && c(x), this.parentNode && this.parentNode.removeChild(this), d.imgCount--, d.imgCount || !b || b.hasLoaded || b.onload() }, src: l }), this.imgCount++) } return a } clipRect(t, e, i, s) { return this.rect(t, e, i, s, 0) } text(t, e, i, s) { let o = {}; if (s && (this.allowHTML || !this.forExport)) return this.html(t, e, i); o.x = Math.round(e || 0), i && (o.y = Math.round(i)), me(t) && (o.text = t); let r = this.createElement("text").attr(o); return s && (!this.forExport || this.allowHTML) || (r.xSetter = function (a, n, l) { let c = l.getElementsByTagName("tspan"), d = l.getAttribute(n); for (let p = 0, u; p < c.length; p++)(u = c[p]).getAttribute(n) === d && u.setAttribute(n, a); l.setAttribute(n, a) }), r } fontMetrics(t) { let e = $d(Dt.prototype.getStyle.call(t, "font-size") || 0), i = e < 24 ? e + 3 : Math.round(1.2 * e), s = Math.round(.8 * i); return { h: i, b: s, f: e } } rotCorr(t, e, i) { let s = t; return e && i && (s = Math.max(s * Math.cos(e * Ya), 4)), { x: -t / 3 * Math.sin(e * Ya), y: s } } pathToSegments(t) { let e = [], i = [], s = { A: 8, C: 7, H: 2, L: 3, M: 3, Q: 5, S: 5, T: 3, V: 2 }; for (let o = 0; o < t.length; o++)Zd(i[0]) && Re(t[o]) && i.length === s[i[0].toUpperCase()] && t.splice(o, 0, i[0].replace("M", "L").replace("m", "l")), typeof t[o] == "string" && (i.length && e.push(i.slice(0)), i.length = 0), i.push(t[o]); return e.push(i.slice(0)), e } label(t, e, i, s, o, r, a, n, l) { return new ge(this, t, e, i, s, o, r, a, n, l) } alignElements() { this.alignedObjects.forEach(t => t.align()) } } fe(ye.prototype, { Element: Dt, SVG_NS: Yd, escapes: { "&": "&amp;", "<": "&lt;", ">": "&gt;", "'": "&#39;", '"': "&quot;" }, symbols: Fa, draw: Xd }), pi.registerRendererType("svg", ye, !0); let { composed: _d, isFirefox: Jd } = C, { attr: Qd, css: te, createElement: tc, defined: Za, extend: ec, getAlignFactor: ic, isNumber: ss, pInt: sc, pushUnique: oc } = I; function $a(h, t, e) { var s; let i = (s = this.div) == null ? void 0 : s.style; Dt.prototype[`${t}Setter`].call(this, h, t, e), i && (e.style[t] = i[t] = h) } let rc = (h, t) => { var e; if (!h.div) { let i = Qd(h.element, "class"), s = h.css, o = tc("div", i ? { className: i } : void 0, { position: "absolute", left: `${h.translateX || 0}px`, top: `${h.translateY || 0}px`, ...h.styles, display: h.display, opacity: h.opacity, visibility: h.visibility }, ((e = h.parentGroup) == null ? void 0 : e.div) || t); h.classSetter = (r, a, n) => { n.setAttribute("class", r), o.className = r }, h.translateXSetter = h.translateYSetter = (r, a) => { h[a] = r, o.style[a === "translateX" ? "left" : "top"] = `${r}px`, h.doTransform = !0 }, h.scaleXSetter = h.scaleYSetter = (r, a) => { h[a] = r, h.doTransform = !0 }, h.opacitySetter = h.visibilitySetter = $a, h.css = r => (s.call(h, r), r.cursor && (o.style.cursor = r.cursor), r.pointerEvents && (o.style.pointerEvents = r.pointerEvents), h), h.on = function () { return Dt.prototype.on.apply({ element: o, onEvents: h.onEvents }, arguments), h }, h.div = o } return h.div }; class We extends Dt { static compose(t) { oc(_d, this.compose) && (t.prototype.html = function (e, i, s) { return new We(this, "span").attr({ text: e, x: Math.round(i), y: Math.round(s) }) }) } constructor(t, e) { super(t, e), We.useForeignObject ? this.foreignObject = t.createElement("foreignObject").attr({ zIndex: 2 }) : this.css({ position: "absolute", ...t.styledMode ? {} : { fontFamily: t.style.fontFamily, fontSize: t.style.fontSize } }), this.element.style.whiteSpace = "nowrap" } getSpanCorrection(t, e, i) { this.xCorr = -t * i, this.yCorr = -e } css(t) { let e, { element: i } = this, s = i.tagName === "SPAN" && t && "width" in t, o = s && t.width; return s && (delete t.width, this.textWidth = sc(o) || void 0, e = !0), (t == null ? void 0 : t.textOverflow) === "ellipsis" && (t.overflow = "hidden", t.whiteSpace = "nowrap"), t != null && t.lineClamp && (t.display = "-webkit-box", t.WebkitLineClamp = t.lineClamp, t.WebkitBoxOrient = "vertical", t.overflow = "hidden"), ss(Number(t == null ? void 0 : t.fontSize)) && (t.fontSize += "px"), ec(this.styles, t), te(i, t), e && this.updateTransform(), this } htmlGetBBox() { let { element: t } = this; return { x: t.offsetLeft, y: t.offsetTop, width: t.offsetWidth, height: t.offsetHeight } } updateTransform() { var x; if (!this.added) { this.alignOnAdd = !0; return } let { element: t, foreignObject: e, oldTextWidth: i, renderer: s, rotation: o, rotationOriginX: r, rotationOriginY: a, scaleX: n, scaleY: l, styles: { display: c = "inline-block", whiteSpace: d }, textAlign: p = "left", textWidth: u, translateX: g = 0, translateY: m = 0, x: f = 0, y = 0 } = this; if (e || te(t, { marginLeft: `${g}px`, marginTop: `${m}px` }), t.tagName === "SPAN") { let b, w = [o, p, t.innerHTML, u, this.textAlign].join(","), v = -(((x = this.parentGroup) == null ? void 0 : x.padding) * 1) || 0; if (u !== i) { let k = this.textPxLength ? this.textPxLength : (te(t, { width: "", whiteSpace: d || "nowrap" }), t.offsetWidth), T = u || 0, P = t.style.textOverflow === "" && t.style.webkitLineClamp; (T > i || k > T || P) && (/[\-\s\u00AD]/.test(t.textContent || t.innerText) || t.style.textOverflow === "ellipsis") && (te(t, { width: (o || n || k > T || P) && ss(u) ? u + "px" : "auto", display: c, whiteSpace: d || "normal" }), this.oldTextWidth = u) } e && (te(t, { display: "inline-block", verticalAlign: "top" }), e.attr({ width: s.width, height: s.height })), w !== this.cTT && (b = s.fontMetrics(t).b, Za(o) && !e && (o !== (this.oldRotation || 0) || p !== this.oldAlign) && te(t, { transform: `rotate(${o}deg)`, transformOrigin: `${v}% ${v}px` }), this.getSpanCorrection(!Za(o) && !this.textWidth && this.textPxLength || t.offsetWidth, b, ic(p))); let { xCorr: S = 0, yCorr: A = 0 } = this, M = { left: `${f + S}px`, top: `${y + A}px`, textAlign: p, transformOrigin: `${(r ?? f) - S - f - v}px ${(a ?? y) - A - y - v}px` }; (n || l) && (M.transform = `scale(${n ?? 1},${l ?? 1})`), e ? (super.updateTransform(), ss(f) && ss(y) ? (e.attr({ x: f + S, y: y + A, width: t.offsetWidth + 3, height: t.offsetHeight, "transform-origin": t.getAttribute("transform-origin") || "0 0" }), te(t, { display: c, textAlign: p })) : Jd && e.attr({ width: 0, height: 0 })) : te(t, M), this.cTT = w, this.oldRotation = o, this.oldAlign = p } } add(t) { let { foreignObject: e, renderer: i } = this, s = i.box.parentNode, o = []; if (e) e.add(t), super.add(i.createElement("body").attr({ xmlns: "http://www.w3.org/1999/xhtml" }).css({ background: "transparent", margin: "0 3px 0 0" }).add(e)); else { let r; if (this.parentGroup = t, t && !(r = t.div)) { let a = t; for (; a;)o.push(a), a = a.parentGroup; for (let n of o.reverse()) r = rc(n, s) } (r || s).appendChild(this.element) } return this.added = !0, this.alignOnAdd && this.updateTransform(), this } textSetter(t) { t !== this.textStr && (delete this.bBox, delete this.oldTextWidth, et.setElementHTML(this.element, t ?? ""), this.textStr = t, this.doTransform = !0) } alignSetter(t) { this.alignValue = this.textAlign = t, this.doTransform = !0 } xSetter(t, e) { this[e] = t, this.doTransform = !0 } } let xe = We.prototype; xe.visibilitySetter = xe.opacitySetter = $a, xe.ySetter = xe.rotationSetter = xe.rotationOriginXSetter = xe.rotationOriginYSetter = xe.xSetter, function (h) { h.xAxis = { alignTicks: !0, allowDecimals: void 0, panningEnabled: !0, zIndex: 2, zoomEnabled: !0, dateTimeLabelFormats: { millisecond: { main: "%[HMSL]", range: !1 }, second: { main: "%[HMS]", range: !1 }, minute: { main: "%[HM]", range: !1 }, hour: { main: "%[HM]", range: !1 }, day: { main: "%[eb]" }, week: { main: "%[eb]" }, month: { main: "%[bY]" }, year: { main: "%Y" } }, endOnTick: !1, gridLineDashStyle: "Solid", gridZIndex: 1, labels: { autoRotationLimit: 80, distance: 15, enabled: !0, indentation: 10, overflow: "justify", reserveSpace: void 0, rotation: void 0, staggerLines: 0, step: 0, useHTML: !1, zIndex: 7, style: { color: "#333333", cursor: "default", fontSize: "0.8em", textOverflow: "ellipsis" } }, maxPadding: .01, minorGridLineDashStyle: "Solid", minorTickLength: 2, minorTickPosition: "outside", minorTicksPerMajor: 5, minPadding: .01, offset: void 0, reversed: void 0, reversedStacks: !1, showEmpty: !0, showFirstLabel: !0, showLastLabel: !0, startOfWeek: 1, startOnTick: !1, tickLength: 10, tickPixelInterval: 100, tickmarkPlacement: "between", tickPosition: "outside", title: { align: "middle", useHTML: !1, x: 0, y: 0, style: { color: "#666666", fontSize: "0.8em" } }, visible: !0, minorGridLineColor: "#f2f2f2", minorGridLineWidth: 1, minorTickColor: "#999999", lineColor: "#333333", lineWidth: 1, gridLineColor: "#e6e6e6", gridLineWidth: void 0, tickColor: "#333333" }, h.yAxis = { reversedStacks: !0, endOnTick: !0, maxPadding: .05, minPadding: .05, tickPixelInterval: 72, showLastLabel: !0, labels: { x: void 0 }, startOnTick: !0, title: {}, stackLabels: { animation: {}, allowOverlap: !1, enabled: !1, crop: !0, overflow: "justify", formatter: function () { let { numberFormatter: t } = this.axis.chart; return t(this.total || 0, -1) }, style: { color: "#000000", fontSize: "0.7em", fontWeight: "bold", textOutline: "1px contrast" } }, gridLineWidth: 1, lineWidth: 0 } }(Jt || (Jt = {})); let ac = Jt, { addEvent: nc, isFunction: lc, objectEach: hc, removeEvent: dc } = I; (Oe || (Oe = {})).registerEventOptions = function (h, t) { h.eventOptions = h.eventOptions || {}, hc(t.events, function (e, i) { h.eventOptions[i] !== e && (h.eventOptions[i] && (dc(h, i, h.eventOptions[i]), delete h.eventOptions[i]), lc(e) && (h.eventOptions[i] = e, nc(h, i, e, { order: 0 }))) }) }; let os = Oe, { deg2rad: Yo } = C, { clamp: cc, correctFloat: rs, defined: Ho, destroyObjectProperties: pc, extend: Ka, fireEvent: yi, getAlignFactor: uc, isNumber: as, merge: gc, objectEach: mc, pick: Rt } = I, Fe = class { constructor(h, t, e, i, s) { this.isNew = !0, this.isNewLabel = !0, this.axis = h, this.pos = t, this.type = e || "", this.parameters = s || {}, this.tickmarkOffset = this.parameters.tickmarkOffset, this.options = this.parameters.options, yi(this, "init"), e || i || this.addLabel() } addLabel() { var A, M; let h = this, t = h.axis, e = t.options, i = t.chart, s = t.categories, o = t.logarithmic, r = t.names, a = h.pos, n = Rt((A = h.options) == null ? void 0 : A.labels, e.labels), l = t.tickPositions, c = a === l[0], d = a === l[l.length - 1], p = (!n.step || n.step === 1) && t.tickInterval === 1, u = l.info, g = h.label, m, f, y, x = this.parameters.category || (s ? Rt(s[a], r[a], a) : a); o && as(x) && (x = rs(o.lin2log(x))), t.dateTime && (u ? m = (f = i.time.resolveDTLFormat(e.dateTimeLabelFormats[!((M = e.grid) != null && M.enabled) && u.higherRanks[a] || u.unitName])).main : as(x) && (m = t.dateTime.getXDateFormat(x, e.dateTimeLabelFormats || {}))), h.isFirst = c, h.isLast = d; let b = { axis: t, chart: i, dateTimeLabelFormat: m, isFirst: c, isLast: d, pos: a, tick: h, tickPositionInfo: u, value: x }; yi(this, "labelFormat", b); let w = k => n.formatter ? n.formatter.call(k, k) : n.format ? (k.text = t.defaultLabelFormatter.call(k), At.format(n.format, k, i)) : t.defaultLabelFormatter.call(k), v = w.call(b, b), S = f == null ? void 0 : f.list; S ? h.shortenLabel = function () { for (y = 0; y < S.length; y++)if (Ka(b, { dateTimeLabelFormat: S[y] }), g.attr({ text: w.call(b, b) }), g.getBBox().width < t.getSlotWidth(h) - 2 * (n.padding || 0)) return; g.attr({ text: "" }) } : h.shortenLabel = void 0, p && t._addedPlotLB && h.moveLabel(v, n), Ho(g) || h.movedLabel ? g && g.textStr !== v && !p && (!g.textWidth || n.style.width || g.styles.width || g.css({ width: null }), g.attr({ text: v }), g.textPxLength = g.getBBox().width) : (h.label = g = h.createLabel(v, n), h.rotation = 0) } createLabel(h, t, e) { let i = this.axis, { renderer: s, styledMode: o } = i.chart, r = t.style.whiteSpace, a = Ho(h) && t.enabled ? s.text(h, e == null ? void 0 : e.x, e == null ? void 0 : e.y, t.useHTML).add(i.labelGroup) : void 0; return a && (o || a.css(gc(t.style)), a.textPxLength = a.getBBox().width, !o && r && a.css({ whiteSpace: r })), a } destroy() { pc(this, this.axis) } getPosition(h, t, e, i) { let s = this.axis, o = s.chart, r = i && o.oldChartHeight || o.chartHeight, a = { x: h ? rs(s.translate(t + e, void 0, void 0, i) + s.transB) : s.left + s.offset + (s.opposite ? (i && o.oldChartWidth || o.chartWidth) - s.right - s.left : 0), y: h ? r - s.bottom + s.offset - (s.opposite ? s.height : 0) : rs(r - s.translate(t + e, void 0, void 0, i) - s.transB) }; return a.y = cc(a.y, -1e9, 1e9), yi(this, "afterGetPosition", { pos: a }), a } getLabelPosition(h, t, e, i, s, o, r, a) { let n, l, c = this.axis, d = c.transA, p = c.isLinked && c.linkedParent ? c.linkedParent.reversed : c.reversed, u = c.staggerLines, g = c.tickRotCorr || { x: 0, y: 0 }, m = i || c.reserveSpaceDefault ? 0 : -c.labelOffset * (c.labelAlign === "center" ? .5 : 1), f = s.distance, y = {}; return n = c.side === 0 ? e.rotation ? -f : -e.getBBox().height : c.side === 2 ? g.y + f : Math.cos(e.rotation * Yo) * (g.y - e.getBBox(!1, 0).height / 2), Ho(s.y) && (n = c.side === 0 && c.horiz ? s.y + n : s.y), h = h + Rt(s.x, [0, 1, 0, -1][c.side] * f) + m + g.x - (o && i ? o * d * (p ? -1 : 1) : 0), t = t + n - (o && !i ? o * d * (p ? 1 : -1) : 0), u && (l = r / (a || 1) % u, c.opposite && (l = u - l - 1), t += l * (c.labelOffset / u)), y.x = h, y.y = Math.round(t), yi(this, "afterGetLabelPosition", { pos: y, tickmarkOffset: o, index: r }), y } getLabelSize() { return this.label ? this.label.getBBox()[this.axis.horiz ? "height" : "width"] : 0 } getMarkPath(h, t, e, i, s = !1, o) { return o.crispLine([["M", h, t], ["L", h + (s ? 0 : -e), t + (s ? e : 0)]], i) } handleOverflow(h) { var f; let t = this.axis, e = t.options.labels, i = h.x, s = t.chart.chartWidth, o = t.chart.spacing, r = Rt(t.labelLeft, Math.min(t.pos, o[3])), a = Rt(t.labelRight, Math.max(t.isRadial ? 0 : t.pos + t.len, s - o[1])), n = this.label, l = this.rotation, c = uc(t.labelAlign || n.attr("align")), d = n.getBBox().width, p = t.getSlotWidth(this), u = p, g = 1, m; l || e.overflow !== "justify" ? l < 0 && i - c * d < r ? m = Math.round(i / Math.cos(l * Yo) - r) : l > 0 && i + c * d > a && (m = Math.round((s - i) / Math.cos(l * Yo))) : (i - c * d < r ? u = h.x + u * (1 - c) - r : i + (1 - c) * d > a && (u = a - h.x + u * c, g = -1), (u = Math.min(p, u)) < p && t.labelAlign === "center" && (h.x += g * (p - u - c * (p - Math.min(d, u)))), (d > u || t.autoRotation && ((f = n == null ? void 0 : n.styles) != null && f.width)) && (m = u)), m && n && (this.shortenLabel ? this.shortenLabel() : n.css(Ka({}, { width: Math.floor(m) + "px", lineClamp: +!t.isRadial }))) } moveLabel(h, t) { let e = this, i = e.label, s = e.axis, o = !1, r; i && i.textStr === h ? (e.movedLabel = i, o = !0, delete e.label) : mc(s.ticks, function (a) { o || a.isNew || a === e || !a.label || a.label.textStr !== h || (e.movedLabel = a.label, o = !0, a.labelPos = e.movedLabel.xy, delete a.label) }), !o && (e.labelPos || i) && (r = e.labelPos || i.xy, e.movedLabel = e.createLabel(h, t, r), e.movedLabel && e.movedLabel.attr({ opacity: 0 })) } render(h, t, e) { var g; let i = this.axis, s = i.horiz, o = this.pos, r = Rt(this.tickmarkOffset, i.tickmarkOffset), a = this.getPosition(s, o, r, t), n = a.x, l = a.y, c = i.pos, d = c + i.len, p = s ? n : l, u = Rt(e, (g = this.label) == null ? void 0 : g.newOpacity, 1); !i.chart.polar && (rs(p) < c || p > d) && (e = 0), e ?? (e = 1), this.isActive = !0, this.renderGridLine(t, e), this.renderMark(a, e), this.renderLabel(a, t, u, h), this.isNew = !1, yi(this, "afterRender") } renderGridLine(h, t) { let e = this.axis, i = e.options, s = {}, o = this.pos, r = this.type, a = Rt(this.tickmarkOffset, e.tickmarkOffset), n = e.chart.renderer, l = this.gridLine, c, d = i.gridLineWidth, p = i.gridLineColor, u = i.gridLineDashStyle; this.type === "minor" && (d = i.minorGridLineWidth, p = i.minorGridLineColor, u = i.minorGridLineDashStyle), l || (e.chart.styledMode || (s.stroke = p, s["stroke-width"] = d || 0, s.dashstyle = u), r || (s.zIndex = 1), h && (t = 0), this.gridLine = l = n.path().attr(s).addClass("highcharts-" + (r ? r + "-" : "") + "grid-line").add(e.gridGroup)), l && (c = e.getPlotLinePath({ value: o + a, lineWidth: l.strokeWidth(), force: "pass", old: h, acrossPanes: !1 })) && l[h || this.isNew ? "attr" : "animate"]({ d: c, opacity: t }) } renderMark(h, t) { let e = this.axis, i = e.options, s = e.chart.renderer, o = this.type, r = e.tickSize(o ? o + "Tick" : "tick"), a = h.x, n = h.y, l = Rt(i[o !== "minor" ? "tickWidth" : "minorTickWidth"], !o && e.isXAxis ? 1 : 0), c = i[o !== "minor" ? "tickColor" : "minorTickColor"], d = this.mark, p = !d; r && (e.opposite && (r[0] = -r[0]), !d && (this.mark = d = s.path().addClass("highcharts-" + (o ? o + "-" : "") + "tick").add(e.axisGroup), e.chart.styledMode || d.attr({ stroke: c, "stroke-width": l })), d[p ? "attr" : "animate"]({ d: this.getMarkPath(a, n, r[0], d.strokeWidth(), e.horiz, s), opacity: t })) } renderLabel(h, t, e, i) { let s = this.axis, o = s.horiz, r = s.options, a = this.label, n = r.labels, l = n.step, c = Rt(this.tickmarkOffset, s.tickmarkOffset), d = h.x, p = h.y, u = !0; a && as(d) && (a.xy = h = this.getLabelPosition(d, p, a, o, n, c, i, l), (!this.isFirst || this.isLast || r.showFirstLabel) && (!this.isLast || this.isFirst || r.showLastLabel) ? !o || n.step || n.rotation || t || e === 0 || this.handleOverflow(h) : u = !1, l && i % l && (u = !1), u && as(h.y) ? (h.opacity = e, a[this.isNewLabel ? "attr" : "animate"](h).show(!0), this.isNewLabel = !1) : (a.hide(), this.isNewLabel = !0)) } replaceMovedLabel() { let h = this.label, t = this.axis; h && !this.isNew && (h.animate({ opacity: 0 }, void 0, h.destroy), delete this.label), t.isDirty = !0, this.label = this.movedLabel, delete this.movedLabel } }, { animObject: fc } = mt, { xAxis: qa, yAxis: yc } = ac, { defaultOptions: Go } = wt, { registerEventOptions: xc } = os, { deg2rad: bc } = C, { arrayMax: _a, arrayMin: vc, clamp: Vo, correctFloat: Ct, defined: q, destroyObjectProperties: wc, erase: Ja, error: Zo, extend: ns, fireEvent: it, getClosestDistance: Qa, insertItem: Sc, isArray: tn, isNumber: U, isString: en, merge: ls, normalizeTickInterval: Mc, objectEach: hs, pick: H, relativeLength: ds, removeEvent: kc, splat: Ac, syncTimeout: Cc } = I, sn = (h, t) => Mc(t, void 0, void 0, H(h.options.allowDecimals, t < .5 || h.tickAmount !== void 0), !!h.tickAmount); ns(Go, { xAxis: qa, yAxis: ls(qa, yc) }); class cs { constructor(t, e, i) { this.init(t, e, i) } init(t, e, i = this.coll) { let s = i === "xAxis", o = this.isZAxis || (t.inverted ? !s : s); this.chart = t, this.horiz = o, this.isXAxis = s, this.coll = i, it(this, "init", { userOptions: e }), this.opposite = H(e.opposite, this.opposite), this.side = H(e.side, this.side, o ? 2 * !this.opposite : this.opposite ? 1 : 3), this.setOptions(e); let r = this.options, a = r.labels; this.type ?? (this.type = r.type || "linear"), this.uniqueNames ?? (this.uniqueNames = r.uniqueNames ?? !0), it(this, "afterSetType"), this.userOptions = e, this.minPixelPadding = 0, this.reversed = H(r.reversed, this.reversed), this.visible = r.visible, this.zoomEnabled = r.zoomEnabled, this.hasNames = this.type === "category" || r.categories === !0, this.categories = tn(r.categories) && r.categories || (this.hasNames ? [] : void 0), this.names || (this.names = [], this.names.keys = {}), this.plotLinesAndBandsGroups = {}, this.positiveValuesOnly = !!this.logarithmic, this.isLinked = q(r.linkedTo), this.ticks = {}, this.labelEdge = [], this.minorTicks = {}, this.plotLinesAndBands = [], this.alternateBands = {}, this.len ?? (this.len = 0), this.minRange = this.userMinRange = r.minRange || r.maxZoom, this.range = r.range, this.offset = r.offset || 0, this.max = void 0, this.min = void 0; let n = H(r.crosshair, Ac(t.options.tooltip.crosshairs)[+!s]); this.crosshair = n === !0 ? {} : n, t.axes.indexOf(this) === -1 && (s ? t.axes.splice(t.xAxis.length, 0, this) : t.axes.push(this), Sc(this, t[this.coll])), t.orderItems(this.coll), this.series = this.series || [], t.inverted && !this.isZAxis && s && !q(this.reversed) && (this.reversed = !0), this.labelRotation = U(a.rotation) ? a.rotation : void 0, xc(this, r), it(this, "afterInit") } setOptions(t) { let e = this.horiz ? { labels: { autoRotation: [-45], padding: 3 }, margin: 15 } : { labels: { padding: 1 }, title: { rotation: 90 * this.side } }; this.options = ls(e, this.coll === "yAxis" ? { title: { text: this.chart.options.lang.yAxisTitle } } : {}, Go[this.coll], t), it(this, "afterSetOptions", { userOptions: t }) } defaultLabelFormatter() { let t = this.axis, { numberFormatter: e } = this.chart, i = U(this.value) ? this.value : NaN, s = t.chart.time, o = t.categories, r = this.dateTimeLabelFormat, a = Go.lang, n = a.numericSymbols, l = a.numericSymbolMagnitude || 1e3, c = t.logarithmic ? Math.abs(i) : t.tickInterval, d = n == null ? void 0 : n.length, p, u; if (o) u = `${this.value}`; else if (r) u = s.dateFormat(r, i, !0); else if (d && n && c >= 1e3) for (; d-- && u === void 0;)c >= (p = Math.pow(l, d + 1)) && 10 * i % p == 0 && n[d] !== null && i !== 0 && (u = e(i / p, -1) + n[d]); return u === void 0 && (u = Math.abs(i) >= 1e4 ? e(i, -1) : e(i, -1, void 0, "")), u } getSeriesExtremes() { let t, e = this; it(this, "getSeriesExtremes", null, function () { e.hasVisibleSeries = !1, e.dataMin = e.dataMax = e.threshold = void 0, e.softThreshold = !e.isXAxis, e.series.forEach(i => { if (i.reserveSpace()) { let s = i.options, o, r = s.threshold, a, n; if (e.hasVisibleSeries = !0, e.positiveValuesOnly && 0 >= (r || 0) && (r = void 0), e.isXAxis) (o = i.getColumn("x")).length && (o = e.logarithmic ? o.filter(l => l > 0) : o, a = (t = i.getXExtremes(o)).min, n = t.max, U(a) || a instanceof Date || (o = o.filter(U), a = (t = i.getXExtremes(o)).min, n = t.max), o.length && (e.dataMin = Math.min(H(e.dataMin, a), a), e.dataMax = Math.max(H(e.dataMax, n), n))); else { let l = i.applyExtremes(); U(l.dataMin) && (a = l.dataMin, e.dataMin = Math.min(H(e.dataMin, a), a)), U(l.dataMax) && (n = l.dataMax, e.dataMax = Math.max(H(e.dataMax, n), n)), q(r) && (e.threshold = r), (!s.softThreshold || e.positiveValuesOnly) && (e.softThreshold = !1) } } }) }), it(this, "afterGetSeriesExtremes") } translate(t, e, i, s, o, r) { var m; let a = this.linkedParent || this, n = s && a.old ? a.old.min : a.min; if (!U(n)) return NaN; let l = a.minPixelPadding, c = (a.isOrdinal || ((m = a.brokenAxis) == null ? void 0 : m.hasBreaks) || a.logarithmic && o) && a.lin2val, d = 1, p = 0, u = s && a.old ? a.old.transA : a.transA, g = 0; return u || (u = a.transA), i && (d *= -1, p = a.len), a.reversed && (d *= -1, p -= d * (a.sector || a.len)), e ? (g = (t = t * d + p - l) / u + n, c && (g = a.lin2val(g))) : (c && (t = a.val2lin(t)), g = d * (t - n) * u + p + d * l + (U(r) ? u * r : 0), a.isRadial || (g = Ct(g))), g } toPixels(t, e) { var i; return this.translate(((i = this.chart) == null ? void 0 : i.time.parse(t)) ?? NaN, !1, !this.horiz, void 0, !0) + (e ? 0 : this.pos) } toValue(t, e) { return this.translate(t - (e ? 0 : this.pos), !0, !this.horiz, void 0, !0) } getPlotLinePath(t) { let e = this, i = e.chart, s = e.left, o = e.top, r = t.old, a = t.value, n = t.lineWidth, l = r && i.oldChartHeight || i.chartHeight, c = r && i.oldChartWidth || i.chartWidth, d = e.transB, p = t.translatedValue, u = t.force, g, m, f, y, x; function b(v, S, A) { return u !== "pass" && (v < S || v > A) && (u ? v = Vo(v, S, A) : x = !0), v } let w = { value: a, lineWidth: n, old: r, force: u, acrossPanes: t.acrossPanes, translatedValue: p }; return it(this, "getPlotLinePath", w, function (v) { g = f = (p = Vo(p = H(p, e.translate(a, void 0, void 0, r)), -1e9, 1e9)) + d, m = y = l - p - d, U(p) ? e.horiz ? (m = o, y = l - e.bottom + (e.options.isInternal ? 0 : i.scrollablePixelsY || 0), g = f = b(g, s, s + e.width)) : (g = s, f = c - e.right + (i.scrollablePixelsX || 0), m = y = b(m, o, o + e.height)) : (x = !0, u = !1), v.path = x && !u ? void 0 : i.renderer.crispLine([["M", g, m], ["L", f, y]], n || 1) }), w.path } getLinearTickPositions(t, e, i) { let s, o, r, a = Ct(Math.floor(e / t) * t), n = Ct(Math.ceil(i / t) * t), l = []; if (Ct(a + t) === a && (r = 20), this.single) return [e]; for (s = a; s <= n && (l.push(s), (s = Ct(s + t, r)) !== o);)o = s; return l } getMinorTickInterval() { let { minorTicks: t, minorTickInterval: e } = this.options; return t === !0 ? H(e, "auto") : t !== !1 ? e : void 0 } getMinorTickPositions() { var c; let t = this.options, e = this.tickPositions, i = this.minorTickInterval, s = this.pointRangePadding || 0, o = (this.min || 0) - s, r = (this.max || 0) + s, a = (c = this.brokenAxis) != null && c.hasBreaks ? this.brokenAxis.unitLength : r - o, n = [], l; if (a && a / i < this.len / 3) { let d = this.logarithmic; if (d) this.paddedTicks.forEach(function (p, u, g) { u && n.push.apply(n, d.getLogTickPositions(i, g[u - 1], g[u], !0)) }); else if (this.dateTime && this.getMinorTickInterval() === "auto") n = n.concat(this.getTimeTicks(this.dateTime.normalizeTimeTickInterval(i), o, r, t.startOfWeek)); else for (l = o + (e[0] - o) % i; l <= r && l !== n[0]; l += i)n.push(l) } return n.length !== 0 && this.trimTicks(n), n } adjustForMinRange() { let t = this.options, e = this.logarithmic, i = this.chart.time, { max: s, min: o, minRange: r } = this, a, n, l, c; this.isXAxis && r === void 0 && !e && (r = q(t.min) || q(t.max) || q(t.floor) || q(t.ceiling) ? null : Math.min(5 * (Qa(this.series.map(d => { let p = d.getColumn("x"); return d.xIncrement ? p.slice(0, 2) : p })) || 0), this.dataMax - this.dataMin)), U(s) && U(o) && U(r) && s - o < r && (n = this.dataMax - this.dataMin >= r, a = (r - s + o) / 2, l = [o - a, i.parse(t.min) ?? o - a], n && (l[2] = e ? e.log2lin(this.dataMin) : this.dataMin), c = [(o = _a(l)) + r, i.parse(t.max) ?? o + r], n && (c[2] = e ? e.log2lin(this.dataMax) : this.dataMax), (s = vc(c)) - o < r && (l[0] = s - r, l[1] = i.parse(t.min) ?? s - r, o = _a(l))), this.minRange = r, this.min = o, this.max = s } getClosest() { let t, e; if (this.categories) e = 1; else { let i = []; this.series.forEach(function (s) { let o = s.closestPointRange, r = s.getColumn("x"); r.length === 1 ? i.push(r[0]) : s.sorted && q(o) && s.reserveSpace() && (e = q(e) ? Math.min(e, o) : o) }), i.length && (i.sort((s, o) => s - o), t = Qa([i])) } return t && e ? Math.min(t, e) : t || e } nameToX(t) { let e = tn(this.options.categories), i = e ? this.categories : this.names, s = t.options.x, o; return t.series.requireSorting = !1, q(s) || (s = this.uniqueNames && i ? e ? i.indexOf(t.name) : H(i.keys[t.name], -1) : t.series.autoIncrement()), s === -1 ? !e && i && (o = i.length) : U(s) && (o = s), o !== void 0 ? (this.names[o] = t.name, this.names.keys[t.name] = o) : t.x && (o = t.x), o } updateNames() { let t = this, e = this.names; e.length > 0 && (Object.keys(e.keys).forEach(function (i) { delete e.keys[i] }), e.length = 0, this.minRange = this.userMinRange, (this.series || []).forEach(i => { i.xIncrement = null, (!i.points || i.isDirtyData) && (t.max = Math.max(t.max || 0, i.dataTable.rowCount - 1), i.processData(), i.generatePoints()); let s = i.getColumn("x").slice(); i.data.forEach((o, r) => { let a = s[r]; o != null && o.options && o.name !== void 0 && (a = t.nameToX(o)) !== void 0 && a !== o.x && (s[r] = o.x = a) }), i.dataTable.setColumn("x", s) })) } setAxisTranslation() { var p; let t = this, e = t.max - t.min, i = t.linkedParent, s = !!t.categories, o = t.isXAxis, r = t.axisPointRange || 0, a, n = 0, l = 0, c, d = t.transA; (o || s || r) && (a = t.getClosest(), i ? (n = i.minPointOffset, l = i.pointRangePadding) : t.series.forEach(function (u) { let g = s ? 1 : o ? H(u.options.pointRange, a, 0) : t.axisPointRange || 0, m = u.options.pointPlacement; if (r = Math.max(r, g), !t.single || s) { let f = u.is("xrange") ? !o : o; n = Math.max(n, f && en(m) ? 0 : g / 2), l = Math.max(l, f && m === "on" ? 0 : g) } }), c = (p = t.ordinal) != null && p.slope && a ? t.ordinal.slope / a : 1, t.minPointOffset = n *= c, t.pointRangePadding = l *= c, t.pointRange = Math.min(r, t.single && s ? 1 : e), o && (t.closestPointRange = a)), t.translationSlope = t.transA = d = t.staticScale || t.len / (e + l || 1), t.transB = t.horiz ? t.left : t.bottom, t.minPixelPadding = d * n, it(this, "afterSetAxisTranslation") } minFromRange() { let { max: t, min: e } = this; return U(t) && U(e) && t - e || void 0 } setTickInterval(t) { var D, z, E, N; let { categories: e, chart: i, dataMax: s, dataMin: o, dateTime: r, isXAxis: a, logarithmic: n, options: l, softThreshold: c } = this, d = i.time, p = U(this.threshold) ? this.threshold : void 0, u = this.minRange || 0, { ceiling: g, floor: m, linkedTo: f, softMax: y, softMin: x } = l, b = U(f) && ((D = i[this.coll]) == null ? void 0 : D[f]), w = l.tickPixelInterval, v = l.maxPadding, S = l.minPadding, A = 0, M, k = U(l.tickInterval) && l.tickInterval >= 0 ? l.tickInterval : void 0, T, P, L, O; if (r || e || b || this.getTickAmount(), L = H(this.userMin, d.parse(l.min)), O = H(this.userMax, d.parse(l.max)), b ? (this.linkedParent = b, M = b.getExtremes(), this.min = H(M.min, M.dataMin), this.max = H(M.max, M.dataMax), this.type !== b.type && Zo(11, !0, i)) : (c && q(p) && U(s) && U(o) && (o >= p ? (T = p, S = 0) : s <= p && (P = p, v = 0)), this.min = H(L, T, o), this.max = H(O, P, s)), U(this.max) && U(this.min) && (n && (this.positiveValuesOnly && !t && 0 >= Math.min(this.min, H(o, this.min)) && Zo(10, !0, i), this.min = Ct(n.log2lin(this.min), 16), this.max = Ct(n.log2lin(this.max), 16)), this.range && U(o) && (this.userMin = this.min = L = Math.max(o, this.minFromRange() || 0), this.userMax = O = this.max, this.range = void 0)), it(this, "foundExtremes"), this.adjustForMinRange(), U(this.min) && U(this.max)) { if (!U(this.userMin) && U(x) && x < this.min && (this.min = L = x), !U(this.userMax) && U(y) && y > this.max && (this.max = O = y), e || this.axisPointRange || (z = this.stacking) != null && z.usePercentage || b || (A = this.max - this.min) && (!q(L) && S && (this.min -= A * S), !q(O) && v && (this.max += A * v)), !U(this.userMin) && U(m) && (this.min = Math.max(this.min, m)), !U(this.userMax) && U(g) && (this.max = Math.min(this.max, g)), c && U(o) && U(s)) { let V = p || 0; !q(L) && this.min < V && o >= V ? this.min = l.minRange ? Math.min(V, this.max - u) : V : !q(O) && this.max > V && s <= V && (this.max = l.minRange ? Math.max(V, this.min + u) : V) } !i.polar && this.min > this.max && (q(l.min) ? this.max = this.min : q(l.max) && (this.min = this.max)), A = this.max - this.min } if (this.min !== this.max && U(this.min) && U(this.max) ? b && !k && w === b.options.tickPixelInterval ? this.tickInterval = k = b.tickInterval : this.tickInterval = H(k, this.tickAmount ? A / Math.max(this.tickAmount - 1, 1) : void 0, e ? 1 : A * w / Math.max(this.len, w)) : this.tickInterval = 1, a && !t) { let V = this.min !== ((E = this.old) == null ? void 0 : E.min) || this.max !== ((N = this.old) == null ? void 0 : N.max); this.series.forEach(function (W) { var F; W.forceCrop = (F = W.forceCropping) == null ? void 0 : F.call(W), W.processData(V) }), it(this, "postProcessData", { hasExtremesChanged: V }) } this.setAxisTranslation(), it(this, "initialAxisTranslation"), this.pointRange && !k && (this.tickInterval = Math.max(this.pointRange, this.tickInterval)); let B = H(l.minTickInterval, r && !this.series.some(V => !V.sorted) ? this.closestPointRange : 0); !k && B && this.tickInterval < B && (this.tickInterval = B), r || n || k || (this.tickInterval = sn(this, this.tickInterval)), this.tickAmount || (this.tickInterval = this.unsquish()), this.setTickPositions() } setTickPositions() { var c, d; let t = this.options, e = t.tickPositions, i = t.tickPositioner, s = this.getMinorTickInterval(), o = !this.isPanning, r = o && t.startOnTick, a = o && t.endOnTick, n = [], l; if (this.tickmarkOffset = this.categories && t.tickmarkPlacement === "between" && this.tickInterval === 1 ? .5 : 0, this.single = this.min === this.max && q(this.min) && !this.tickAmount && (this.min % 1 == 0 || t.allowDecimals !== !1), e) n = e.slice(); else if (U(this.min) && U(this.max)) { if (!((c = this.ordinal) != null && c.positions) && (this.max - this.min) / this.tickInterval > Math.max(2 * this.len, 200)) n = [this.min, this.max], Zo(19, !1, this.chart); else if (this.dateTime) n = this.getTimeTicks(this.dateTime.normalizeTimeTickInterval(this.tickInterval, t.units), this.min, this.max, t.startOfWeek, (d = this.ordinal) == null ? void 0 : d.positions, this.closestPointRange, !0); else if (this.logarithmic) n = this.logarithmic.getLogTickPositions(this.tickInterval, this.min, this.max); else { let p = this.tickInterval, u = p; for (; u <= 2 * p && (n = this.getLinearTickPositions(this.tickInterval, this.min, this.max), this.tickAmount && n.length > this.tickAmount);)this.tickInterval = sn(this, u *= 1.1) } n.length > this.len && (n = [n[0], n[n.length - 1]])[0] === n[1] && (n.length = 1), i && (this.tickPositions = n, (l = i.apply(this, [this.min, this.max])) && (n = l)) } this.tickPositions = n, this.minorTickInterval = s === "auto" && this.tickInterval ? this.tickInterval / t.minorTicksPerMajor : s, this.paddedTicks = n.slice(0), this.trimTicks(n, r, a), !this.isLinked && U(this.min) && U(this.max) && (this.single && n.length < 2 && !this.categories && !this.series.some(p => p.is("heatmap") && p.options.pointPlacement === "between") && (this.min -= .5, this.max += .5), e || l || this.adjustTickAmount()), it(this, "afterSetTickPositions") } trimTicks(t, e, i) { let s = t[0], o = t[t.length - 1], r = !this.isOrdinal && this.minPointOffset || 0; if (it(this, "trimTicks"), !this.isLinked || !this.grid) { if (e && s !== -1 / 0) this.min = s; else for (; this.min - r > t[0];)t.shift(); if (i) this.max = o; else for (; this.max + r < t[t.length - 1];)t.pop(); t.length === 0 && q(s) && !this.options.tickPositions && t.push((o + s) / 2) } } alignToOthers() { let t, e = this, i = e.chart, s = [this], o = e.options, r = i.options.chart, a = this.coll === "yAxis" && r.alignThresholds, n = []; if (e.thresholdAlignment = void 0, (r.alignTicks !== !1 && o.alignTicks || a) && o.startOnTick !== !1 && o.endOnTick !== !1 && !e.logarithmic) { let l = d => { let { horiz: p, options: u } = d; return [p ? u.left : u.top, u.width, u.height, u.pane].join(",") }, c = l(this); i[this.coll].forEach(function (d) { let { series: p } = d; p.length && p.some(u => u.visible) && d !== e && l(d) === c && (t = !0, s.push(d)) }) } if (t && a) { s.forEach(c => { let d = c.getThresholdAlignment(e); U(d) && n.push(d) }); let l = n.length > 1 ? n.reduce((c, d) => c += d, 0) / n.length : void 0; s.forEach(c => { c.thresholdAlignment = l }) } return t } getThresholdAlignment(t) { if ((!U(this.dataMin) || this !== t && this.series.some(e => e.isDirty || e.isDirtyData)) && this.getSeriesExtremes(), U(this.threshold)) { let e = Vo((this.threshold - (this.dataMin || 0)) / ((this.dataMax || 0) - (this.dataMin || 0)), 0, 1); return this.options.reversed && (e = 1 - e), e } } getTickAmount() { let t = this.options, e = t.tickPixelInterval, i = t.tickAmount; q(t.tickInterval) || i || !(this.len < e) || this.isRadial || this.logarithmic || !t.startOnTick || !t.endOnTick || (i = 2), !i && this.alignToOthers() && (i = Math.ceil(this.len / e) + 1), i < 4 && (this.finalTickAmt = i, i = 5), this.tickAmount = i } adjustTickAmount() { let t = this, { finalTickAmt: e, max: i, min: s, options: o, tickPositions: r, tickAmount: a, thresholdAlignment: n } = t, l = r == null ? void 0 : r.length, c = H(t.threshold, t.softThreshold ? 0 : null), d, p, u = t.tickInterval, g, m = () => r.push(Ct(r[r.length - 1] + u)), f = () => r.unshift(Ct(r[0] - u)); if (U(n) && (g = n < .5 ? Math.ceil(n * (a - 1)) : Math.floor(n * (a - 1)), o.reversed && (g = a - 1 - g)), t.hasData() && U(s) && U(i)) { let y = () => { t.transA *= (l - 1) / (a - 1), t.min = o.startOnTick ? r[0] : Math.min(s, r[0]), t.max = o.endOnTick ? r[r.length - 1] : Math.max(i, r[r.length - 1]) }; if (U(g) && U(t.threshold)) { for (; r[g] !== c || r.length !== a || r[0] > s || r[r.length - 1] < i;) { for (r.length = 0, r.push(t.threshold); r.length < a;)r[g] === void 0 || r[g] > t.threshold ? f() : m(); if (u > 8 * t.tickInterval) break; u *= 2 } y() } else if (l < a) { for (; r.length < a;)r.length % 2 || s === c ? m() : f(); y() } if (q(e)) { for (p = d = r.length; p--;)(e === 3 && p % 2 == 1 || e <= 2 && p > 0 && p < d - 1) && r.splice(p, 1); t.finalTickAmt = void 0 } } } setScale() { var r, a, n, l, c; let { coll: t, stacking: e } = this, i = !1, s = !1; this.series.forEach(d => { var p; i = i || d.isDirtyData || d.isDirty, s = s || ((p = d.xAxis) == null ? void 0 : p.isDirty) || !1 }), this.setAxisSize(); let o = this.len !== ((r = this.old) == null ? void 0 : r.len); o || i || s || this.isLinked || this.forceRedraw || this.userMin !== ((a = this.old) == null ? void 0 : a.userMin) || this.userMax !== ((n = this.old) == null ? void 0 : n.userMax) || this.alignToOthers() ? (e && t === "yAxis" && e.buildStacks(), this.forceRedraw = !1, this.userMinRange || (this.minRange = void 0), this.getSeriesExtremes(), this.setTickInterval(), e && t === "xAxis" && e.buildStacks(), this.isDirty || (this.isDirty = o || this.min !== ((l = this.old) == null ? void 0 : l.min) || this.max !== ((c = this.old) == null ? void 0 : c.max))) : e && e.cleanStacks(), i && delete this.allExtremes, it(this, "afterSetScale") } setExtremes(t, e, i = !0, s, o) { let r = this.chart; this.series.forEach(a => { delete a.kdTree }), t = r.time.parse(t), e = r.time.parse(e), it(this, "setExtremes", o = ns(o, { min: t, max: e }), a => { this.userMin = a.min, this.userMax = a.max, this.eventArgs = a, i && r.redraw(s) }) } setAxisSize() { let t = this.chart, e = this.options, i = e.offsets || [0, 0, 0, 0], s = this.horiz, o = this.width = Math.round(ds(H(e.width, t.plotWidth - i[3] + i[1]), t.plotWidth)), r = this.height = Math.round(ds(H(e.height, t.plotHeight - i[0] + i[2]), t.plotHeight)), a = this.top = Math.round(ds(H(e.top, t.plotTop + i[0]), t.plotHeight, t.plotTop)), n = this.left = Math.round(ds(H(e.left, t.plotLeft + i[3]), t.plotWidth, t.plotLeft)); this.bottom = t.chartHeight - r - a, this.right = t.chartWidth - o - n, this.len = Math.max(s ? o : r, 0), this.pos = s ? n : a } getExtremes() { let t = this.logarithmic; return { min: t ? Ct(t.lin2log(this.min)) : this.min, max: t ? Ct(t.lin2log(this.max)) : this.max, dataMin: this.dataMin, dataMax: this.dataMax, userMin: this.userMin, userMax: this.userMax } } getThreshold(t) { let e = this.logarithmic, i = e ? e.lin2log(this.min) : this.min, s = e ? e.lin2log(this.max) : this.max; return t === null || t === -1 / 0 ? t = i : t === 1 / 0 ? t = s : i > t ? t = i : s < t && (t = s), this.translate(t, 0, 1, 0, 1) } autoLabelAlign(t) { let e = (H(t, 0) - 90 * this.side + 720) % 360, i = { align: "center" }; return it(this, "autoLabelAlign", i, function (s) { e > 15 && e < 165 ? s.align = "right" : e > 195 && e < 345 && (s.align = "left") }), i.align } tickSize(t) { let e = this.options, i = H(e[t === "tick" ? "tickWidth" : "minorTickWidth"], t === "tick" && this.isXAxis && !this.categories ? 1 : 0), s = e[t === "tick" ? "tickLength" : "minorTickLength"], o; i && s && (e[t + "Position"] === "inside" && (s = -s), o = [s, i]); let r = { tickSize: o }; return it(this, "afterTickSize", r), r.tickSize } labelMetrics() { let t = this.chart.renderer, e = this.ticks, i = e[Object.keys(e)[0]] || {}; return this.chart.renderer.fontMetrics(i.label || i.movedLabel || t.box) } unsquish() { let t = this.options.labels, e = t.padding || 0, i = this.horiz, s = this.tickInterval, o = this.len / ((+!!this.categories + this.max - this.min) / s), r = t.rotation, a = Ct(.8 * this.labelMetrics().h), n = Math.max(this.max - this.min, 0), l = function (g) { let m = (g + 2 * e) / (o || 1); return (m = m > 1 ? Math.ceil(m) : 1) * s > n && g !== 1 / 0 && o !== 1 / 0 && n && (m = Math.ceil(n / s)), Ct(m * s) }, c = s, d, p = Number.MAX_VALUE, u; if (i) { if (!t.staggerLines && (U(r) ? u = [r] : o < t.autoRotationLimit && (u = t.autoRotation)), u) { let g, m; for (let f of u) (f === r || f && f >= -90 && f <= 90) && (m = (g = l(Math.abs(a / Math.sin(bc * f)))) + Math.abs(f / 360)) < p && (p = m, d = f, c = g) } } else c = l(.75 * a); return this.autoRotation = u, this.labelRotation = H(d, U(r) ? r : 0), t.step ? s : c } getSlotWidth(t) { let e = this.chart, i = this.horiz, s = this.options.labels, o = Math.max(this.tickPositions.length - !this.categories, 1), r = e.margin[3]; if (t && U(t.slotWidth)) return t.slotWidth; if (i && s.step < 2 && !this.isRadial) return s.rotation ? 0 : (this.staggerLines || 1) * this.len / o; if (!i) { let a = s.style.width; if (a !== void 0) return parseInt(String(a), 10); if (r) return r - e.spacing[3] } return .33 * e.chartWidth } renderUnsquish() { let t = this.chart, e = t.renderer, i = this.tickPositions, s = this.ticks, o = this.options.labels, r = o.style, a = this.horiz, n = this.getSlotWidth(), l = Math.max(1, Math.round(n - (a ? 2 * (o.padding || 0) : o.distance || 0))), c = {}, d = this.labelMetrics(), p = r.lineClamp, u, g = p ?? (Math.floor(this.len / (i.length * d.h)) || 1), m = 0; en(o.rotation) || (c.rotation = o.rotation || 0), i.forEach(function (f) { var b; let y = s[f]; y.movedLabel && y.replaceMovedLabel(); let x = ((b = y.label) == null ? void 0 : b.textPxLength) || 0; x > m && (m = x) }), this.maxLabelLength = m, this.autoRotation ? m > l && m > d.h ? c.rotation = this.labelRotation : this.labelRotation = 0 : n && (u = l), c.rotation && (u = m > .5 * t.chartHeight ? .33 * t.chartHeight : m, p || (g = 1)), this.labelAlign = o.align || this.autoLabelAlign(this.labelRotation), this.labelAlign && (c.align = this.labelAlign), i.forEach(function (f) { let y = s[f], x = y == null ? void 0 : y.label, b = r.width, w = {}; x && (x.attr(c), y.shortenLabel ? y.shortenLabel() : u && !b && r.whiteSpace !== "nowrap" && (u < (x.textPxLength || 0) || x.element.tagName === "SPAN") ? x.css(ns(w, { width: `${u}px`, lineClamp: g })) : !x.styles.width || w.width || b || x.css({ width: "auto" }), y.rotation = c.rotation) }, this), this.tickRotCorr = e.rotCorr(d.b, this.labelRotation || 0, this.side !== 0) } hasData() { return this.series.some(function (t) { return t.hasData() }) || this.options.showEmpty && q(this.min) && q(this.max) } addTitle(t) { let e, i = this.chart.renderer, s = this.horiz, o = this.opposite, r = this.options.title, a = this.chart.styledMode; this.axisTitle || ((e = r.textAlign) || (e = (s ? { low: "left", middle: "center", high: "right" } : { low: o ? "right" : "left", middle: "center", high: o ? "left" : "right" })[r.align]), this.axisTitle = i.text(r.text || "", 0, 0, r.useHTML).attr({ zIndex: 7, rotation: r.rotation || 0, align: e }).addClass("highcharts-axis-title"), a || this.axisTitle.css(ls(r.style)), this.axisTitle.add(this.axisGroup), this.axisTitle.isNew = !0), a || r.style.width || this.isRadial || this.axisTitle.css({ width: this.len + "px" }), this.axisTitle[t ? "show" : "hide"](t) } generateTick(t) { let e = this.ticks; e[t] ? e[t].addLabel() : e[t] = new Fe(this, t) } createGroups() { let { axisParent: t, chart: e, coll: i, options: s } = this, o = e.renderer, r = (a, n, l) => o.g(a).attr({ zIndex: l }).addClass(`highcharts-${i.toLowerCase()}${n} ` + (this.isRadial ? `highcharts-radial-axis${n} ` : "") + (s.className || "")).add(t); this.axisGroup || (this.gridGroup = r("grid", "-grid", s.gridZIndex), this.axisGroup = r("axis", "", s.zIndex), this.labelGroup = r("axis-labels", "-labels", s.labels.zIndex)) } getOffset() { let t = this, { chart: e, horiz: i, options: s, side: o, ticks: r, tickPositions: a, coll: n } = t, l = e.inverted && !t.isZAxis ? [1, 0, 3, 2][o] : o, c = t.hasData(), d = s.title, p = s.labels, u = U(s.crossing), g = e.axisOffset, m = e.clipOffset, f = [-1, 1, 1, -1][o], y, x = 0, b, w = 0, v = 0, S, A; if (t.showAxis = y = c || s.showEmpty, t.staggerLines = t.horiz && p.staggerLines || void 0, t.createGroups(), c || t.isLinked ? (a.forEach(function (M) { t.generateTick(M) }), t.renderUnsquish(), t.reserveSpaceDefault = o === 0 || o === 2 || { 1: "left", 3: "right" }[o] === t.labelAlign, H(p.reserveSpace, !u && null, t.labelAlign === "center" || null, t.reserveSpaceDefault) && a.forEach(function (M) { v = Math.max(r[M].getLabelSize(), v) }), t.staggerLines && (v *= t.staggerLines), t.labelOffset = v * (t.opposite ? -1 : 1)) : hs(r, function (M, k) { M.destroy(), delete r[k] }), d != null && d.text && d.enabled !== !1 && (t.addTitle(y), y && !u && d.reserveSpace !== !1 && (t.titleOffset = x = t.axisTitle.getBBox()[i ? "height" : "width"], w = q(b = d.offset) ? 0 : H(d.margin, i ? 5 : 10))), t.renderLine(), t.offset = f * H(s.offset, g[o] ? g[o] + (s.margin || 0) : 0), t.tickRotCorr = t.tickRotCorr || { x: 0, y: 0 }, A = o === 0 ? -t.labelMetrics().h : o === 2 ? t.tickRotCorr.y : 0, S = Math.abs(v) + w, v && (S -= A, S += f * (i ? H(p.y, t.tickRotCorr.y + f * p.distance) : H(p.x, f * p.distance))), t.axisTitleMargin = H(b, S), t.getMaxLabelDimensions && (t.maxLabelDimensions = t.getMaxLabelDimensions(r, a)), n !== "colorAxis" && m) { let M = this.tickSize("tick"); g[o] = Math.max(g[o], (t.axisTitleMargin || 0) + x + f * t.offset, S, a != null && a.length && M ? M[0] + f * t.offset : 0); let k = !t.axisLine || s.offset ? 0 : t.axisLine.strokeWidth() / 2; m[l] = Math.max(m[l], k) } it(this, "afterGetOffset") } getLinePath(t) { let e = this.chart, i = this.opposite, s = this.offset, o = this.horiz, r = this.left + (i ? this.width : 0) + s, a = e.chartHeight - this.bottom - (i ? this.height : 0) + s; return i && (t *= -1), e.renderer.crispLine([["M", o ? this.left : r, o ? a : this.top], ["L", o ? e.chartWidth - this.right : r, o ? a : e.chartHeight - this.bottom]], t) } renderLine() { !this.axisLine && (this.axisLine = this.chart.renderer.path().addClass("highcharts-axis-line").add(this.axisGroup), this.chart.styledMode || this.axisLine.attr({ stroke: this.options.lineColor, "stroke-width": this.options.lineWidth, zIndex: 7 })) } getTitlePosition(t) { let e = this.horiz, i = this.left, s = this.top, o = this.len, r = this.options.title, a = e ? i : s, n = this.opposite, l = this.offset, c = r.x, d = r.y, p = this.chart.renderer.fontMetrics(t), u = t ? Math.max(t.getBBox(!1, 0).height - p.h - 1, 0) : 0, g = { low: a + (e ? 0 : o), middle: a + o / 2, high: a + (e ? o : 0) }[r.align], m = (e ? s + this.height : i) + (e ? 1 : -1) * (n ? -1 : 1) * (this.axisTitleMargin || 0) + [-u, u, p.f, -u][this.side], f = { x: e ? g + c : m + (n ? this.width : 0) + l + c, y: e ? m + d - (n ? this.height : 0) + l : g + d }; return it(this, "afterGetTitlePosition", { titlePosition: f }), f } renderMinorTick(t, e) { let i = this.minorTicks; i[t] || (i[t] = new Fe(this, t, "minor")), e && i[t].isNew && i[t].render(null, !0), i[t].render(null, !1, 1) } renderTick(t, e, i) { var r; let s = this.isLinked, o = this.ticks; (!s || t >= this.min && t <= this.max || (r = this.grid) != null && r.isColumn) && (o[t] || (o[t] = new Fe(this, t)), i && o[t].isNew && o[t].render(e, !0, -1), o[t].render(e)) } render() { let t, e, i = this, s = i.chart, o = i.logarithmic, r = s.renderer, a = i.options, n = i.isLinked, l = i.tickPositions, c = i.axisTitle, d = i.ticks, p = i.minorTicks, u = i.alternateBands, g = a.stackLabels, m = a.alternateGridColor, f = a.crossing, y = i.tickmarkOffset, x = i.axisLine, b = i.showAxis, w = fc(r.globalAnimation); if (i.labelEdge.length = 0, i.overlap = !1, [d, p, u].forEach(function (v) { hs(v, function (S) { S.isActive = !1 }) }), U(f)) { let v = this.isXAxis ? s.yAxis[0] : s.xAxis[0], S = [1, -1, -1, 1][this.side]; if (v) { let A = v.toPixels(f, !0); i.horiz && (A = v.len - A), i.offset = S * A } } if (i.hasData() || n) { let v = i.chart.hasRendered && i.old && U(i.old.min); i.minorTickInterval && !i.categories && i.getMinorTickPositions().forEach(function (S) { i.renderMinorTick(S, v) }), l.length && (l.forEach(function (S, A) { i.renderTick(S, A, v) }), y && (i.min === 0 || i.single) && (d[-1] || (d[-1] = new Fe(i, -1, null, !0)), d[-1].render(-1))), m && l.forEach(function (S, A) { e = l[A + 1] !== void 0 ? l[A + 1] + y : i.max - y, A % 2 == 0 && S < i.max && e <= i.max + (s.polar ? -y : y) && (u[S] || (u[S] = new C.PlotLineOrBand(i, {})), t = S + y, u[S].options = { from: o ? o.lin2log(t) : t, to: o ? o.lin2log(e) : e, color: m, className: "highcharts-alternate-grid" }, u[S].render(), u[S].isActive = !0) }), i._addedPlotLB || (i._addedPlotLB = !0, (a.plotLines || []).concat(a.plotBands || []).forEach(function (S) { i.addPlotBandOrLine(S) })) } [d, p, u].forEach(function (v) { let S = [], A = w.duration; hs(v, function (M, k) { M.isActive || (M.render(k, !1, 0), M.isActive = !1, S.push(k)) }), Cc(function () { let M = S.length; for (; M--;)v[S[M]] && !v[S[M]].isActive && (v[S[M]].destroy(), delete v[S[M]]) }, v !== u && s.hasRendered && A ? A : 0) }), x && (x[x.isPlaced ? "animate" : "attr"]({ d: this.getLinePath(x.strokeWidth()) }), x.isPlaced = !0, x[b ? "show" : "hide"](b)), c && b && (c[c.isNew ? "attr" : "animate"](i.getTitlePosition(c)), c.isNew = !1), g != null && g.enabled && i.stacking && i.stacking.renderStackTotals(), i.old = { len: i.len, max: i.max, min: i.min, transA: i.transA, userMax: i.userMax, userMin: i.userMin }, i.isDirty = !1, it(this, "afterRender") } redraw() { this.visible && (this.render(), this.plotLinesAndBands.forEach(function (t) { t.render() })), this.series.forEach(function (t) { t.isDirty = !0 }) } getKeepProps() { return this.keepProps || cs.keepProps } destroy(t) { let e = this, i = e.plotLinesAndBands, s = this.eventOptions; if (it(this, "destroy", { keepEvents: t }), t || kc(e), [e.ticks, e.minorTicks, e.alternateBands].forEach(function (o) { wc(o) }), i) { let o = i.length; for (; o--;)i[o].destroy() } for (let o in ["axisLine", "axisTitle", "axisGroup", "gridGroup", "labelGroup", "cross", "scrollbar"].forEach(function (r) { e[r] && (e[r] = e[r].destroy()) }), e.plotLinesAndBandsGroups) e.plotLinesAndBandsGroups[o] = e.plotLinesAndBandsGroups[o].destroy(); hs(e, function (o, r) { e.getKeepProps().indexOf(r) === -1 && delete e[r] }), this.eventOptions = s } drawCrosshair(t, e) { var d; let i = this.crosshair, s = (i == null ? void 0 : i.snap) ?? !0, o = this.chart, r, a, n, l = this.cross, c; if (it(this, "drawCrosshair", { e: t, point: e }), t || (t = (d = this.cross) == null ? void 0 : d.e), i && (q(e) || !s) !== !1) { if (s ? q(e) && (a = H(this.coll !== "colorAxis" ? e.crosshairPos : null, this.isXAxis ? e.plotX : this.len - e.plotY)) : a = t && (this.horiz ? t.chartX - this.pos : this.len - t.chartY + this.pos), q(a) && (c = { value: e && (this.isXAxis ? e.x : H(e.stackY, e.y)), translatedValue: a }, o.polar && ns(c, { isCrosshair: !0, chartX: t == null ? void 0 : t.chartX, chartY: t == null ? void 0 : t.chartY, point: e }), r = this.getPlotLinePath(c) || null), !q(r)) return void this.hideCrosshair(); n = this.categories && !this.isRadial, l || (this.cross = l = o.renderer.path().addClass("highcharts-crosshair highcharts-crosshair-" + (n ? "category " : "thin ") + (i.className || "")).attr({ zIndex: H(i.zIndex, 2) }).add(), !o.styledMode && (l.attr({ stroke: i.color || (n ? _.parse("#ccd3ff").setOpacity(.25).get() : "#cccccc"), "stroke-width": H(i.width, 1) }).css({ "pointer-events": "none" }), i.dashStyle && l.attr({ dashstyle: i.dashStyle }))), l.show().attr({ d: r }), n && !i.width && l.attr({ "stroke-width": this.transA }), this.cross.e = t } else this.hideCrosshair(); it(this, "afterDrawCrosshair", { e: t, point: e }) } hideCrosshair() { this.cross && this.cross.hide(), it(this, "afterHideCrosshair") } update(t, e) { let i = this.chart; t = ls(this.userOptions, t), this.destroy(!0), this.init(i, t), i.isDirtyBox = !0, H(e, !0) && i.redraw() } remove(t) { let e = this.chart, i = this.coll, s = this.series, o = s.length; for (; o--;)s[o] && s[o].remove(!1); Ja(e.axes, this), Ja(e[i] || [], this), e.orderItems(i), this.destroy(), e.isDirtyBox = !0, H(t, !0) && e.redraw() } setTitle(t, e) { this.update({ title: t }, e) } setCategories(t, e) { this.update({ categories: t }, e) } } cs.keepProps = ["coll", "extKey", "hcEvents", "len", "names", "series", "userMax", "userMin"]; let xi = cs, { addEvent: Tc, getMagnitude: Pc, normalizeTickInterval: Lc, timeUnits: ps } = I; (function (h) { function t() { return this.chart.time.getTimeTicks.apply(this.chart.time, arguments) } function e() { if (this.type !== "datetime") { this.dateTime = void 0; return } this.dateTime || (this.dateTime = new i(this)) } h.compose = function (s) { return s.keepProps.includes("dateTime") || (s.keepProps.push("dateTime"), s.prototype.getTimeTicks = t, Tc(s, "afterSetType", e)), s }; class i { constructor(o) { this.axis = o } normalizeTimeTickInterval(o, r) { let a = r || [["millisecond", [1, 2, 5, 10, 20, 25, 50, 100, 200, 500]], ["second", [1, 2, 5, 10, 15, 30]], ["minute", [1, 2, 5, 10, 15, 30]], ["hour", [1, 2, 3, 4, 6, 8, 12]], ["day", [1, 2]], ["week", [1, 2]], ["month", [1, 2, 3, 4, 6]], ["year", null]], n = a[a.length - 1], l = ps[n[0]], c = n[1], d; for (d = 0; d < a.length && (l = ps[(n = a[d])[0]], c = n[1], !a[d + 1] || !(o <= (l * c[c.length - 1] + ps[a[d + 1][0]]) / 2)); d++); l === ps.year && o < 5 * l && (c = [1, 2, 5]); let p = Lc(o / l, c, n[0] === "year" ? Math.max(Pc(o / l), 1) : 1); return { unitRange: l, count: p, unitName: n[0] } } getXDateFormat(o, r) { let { axis: a } = this, n = a.chart.time; return a.closestPointRange ? n.getDateFormat(a.closestPointRange, o, a.options.startOfWeek, r) || n.resolveDTLFormat(r.year).main : n.resolveDTLFormat(r.day).main } } h.Additions = i })(gt || (gt = {})); let Oc = gt, { addEvent: on, normalizeTickInterval: Ec, pick: Ic } = I; (function (h) { function t() { this.type !== "logarithmic" ? this.logarithmic = void 0 : this.logarithmic ?? (this.logarithmic = new i(this)) } function e() { let s = this.logarithmic; s && (this.lin2val = function (o) { return s.lin2log(o) }, this.val2lin = function (o) { return s.log2lin(o) }) } h.compose = function (s) { return s.keepProps.includes("logarithmic") || (s.keepProps.push("logarithmic"), on(s, "afterSetType", t), on(s, "afterInit", e)), s }; class i { constructor(o) { this.axis = o } getLogTickPositions(o, r, a, n) { let l = this.axis, c = l.len, d = l.options, p = []; if (n || (this.minorAutoInterval = void 0), o >= .5) o = Math.round(o), p = l.getLinearTickPositions(o, r, a); else if (o >= .08) { let u, g, m, f, y, x, b, w = Math.floor(r); for (u = o > .3 ? [1, 2, 4] : o > .15 ? [1, 2, 4, 6, 8] : [1, 2, 3, 4, 5, 6, 7, 8, 9], g = w; g < a + 1 && !b; g++)for (m = 0, f = u.length; m < f && !b; m++)(y = this.log2lin(this.lin2log(g) * u[m])) > r && (!n || x <= a) && x !== void 0 && p.push(x), x > a && (b = !0), x = y } else { let u = this.lin2log(r), g = this.lin2log(a), m = n ? l.getMinorTickInterval() : d.tickInterval, f = d.tickPixelInterval / (n ? 5 : 1), y = n ? c / l.tickPositions.length : c; o = Ec(o = Ic(m === "auto" ? null : m, this.minorAutoInterval, (g - u) * f / (y || 1))), p = l.getLinearTickPositions(o, u, g).map(this.log2lin), n || (this.minorAutoInterval = o / 5) } return n || (l.tickInterval = o), p } lin2log(o) { return Math.pow(10, o) } log2lin(o) { return Math.log(o) / Math.LN10 } } h.Additions = i })(St || (St = {})); let Dc = St, { erase: Bc, extend: zc, isNumber: rn } = I; (function (h) { let t; function e(l) { return this.addPlotBandOrLine(l, "plotBands") } function i(l, c) { let d = this.userOptions, p = new t(this, l); if (this.visible && (p = p.render()), p) { if (this._addedPlotLB || (this._addedPlotLB = !0, (d.plotLines || []).concat(d.plotBands || []).forEach(u => { this.addPlotBandOrLine(u) })), c) { let u = d[c] || []; u.push(l), d[c] = u } this.plotLinesAndBands.push(p) } return p } function s(l) { return this.addPlotBandOrLine(l, "plotLines") } function o(l, c, d) { d = d || this.options; let p = this.getPlotLinePath({ value: c, force: !0, acrossPanes: d.acrossPanes }), u = [], g = this.horiz, m = !rn(this.min) || !rn(this.max) || l < this.min && c < this.min || l > this.max && c > this.max, f = this.getPlotLinePath({ value: l, force: !0, acrossPanes: d.acrossPanes }), y, x = 1, b; if (f && p) for (m && (b = f.toString() === p.toString(), x = 0), y = 0; y < f.length; y += 2) { let w = f[y], v = f[y + 1], S = p[y], A = p[y + 1]; (w[0] === "M" || w[0] === "L") && (v[0] === "M" || v[0] === "L") && (S[0] === "M" || S[0] === "L") && (A[0] === "M" || A[0] === "L") && (g && S[1] === w[1] ? (S[1] += x, A[1] += x) : g || S[2] !== w[2] || (S[2] += x, A[2] += x), u.push(["M", w[1], w[2]], ["L", v[1], v[2]], ["L", A[1], A[2]], ["L", S[1], S[2]], ["Z"])), u.isFlat = b } return u } function r(l) { this.removePlotBandOrLine(l) } function a(l) { let c = this.plotLinesAndBands, d = this.options, p = this.userOptions; if (c) { let u = c.length; for (; u--;)c[u].id === l && c[u].destroy();[d.plotLines || [], p.plotLines || [], d.plotBands || [], p.plotBands || []].forEach(function (g) { var m; for (u = g.length; u--;)((m = g[u]) == null ? void 0 : m.id) === l && Bc(g, g[u]) }) } } function n(l) { this.removePlotBandOrLine(l) } h.compose = function (l, c) { let d = c.prototype; return d.addPlotBand || (t = l, zc(d, { addPlotBand: e, addPlotLine: s, addPlotBandOrLine: i, getPlotBandPath: o, removePlotBand: r, removePlotLine: n, removePlotBandOrLine: a })), c } })(Ee || (Ee = {})); let Nc = Ee, { addEvent: Uc, arrayMax: an, arrayMin: nn, defined: Wt, destroyObjectProperties: jc, erase: Rc, fireEvent: Wc, merge: ln, objectEach: Fc, pick: Xc } = I; class us { static compose(t, e) { return Uc(t, "afterInit", function () { this.labelCollectors.push(() => { var s; let i = []; for (let o of this.axes) for (let { label: r, options: a } of o.plotLinesAndBands) r && !((s = a == null ? void 0 : a.label) != null && s.allowOverlap) && i.push(r); return i }) }), Nc.compose(us, e) } constructor(t, e) { this.axis = t, this.options = e, this.id = e.id } render() { Wc(this, "render"); let { axis: t, options: e } = this, { horiz: i, logarithmic: s } = t, { color: o, events: r, zIndex: a = 0 } = e, { renderer: n, time: l } = t.chart, c = {}, d = l.parse(e.to), p = l.parse(e.from), u = l.parse(e.value), g = e.borderWidth, m = e.label, { label: f, svgElem: y } = this, x = [], b, w = Wt(p) && Wt(d), v = Wt(u), S = !y, A = { class: "highcharts-plot-" + (w ? "band " : "line ") + (e.className || "") }, M = w ? "bands" : "lines"; if (!t.chart.styledMode && (v ? (A.stroke = o || "#999999", A["stroke-width"] = Xc(e.width, 1), e.dashStyle && (A.dashstyle = e.dashStyle)) : w && (A.fill = o || "#e6e9ff", g && (A.stroke = e.borderColor, A["stroke-width"] = g))), c.zIndex = a, M += "-" + a, (b = t.plotLinesAndBandsGroups[M]) || (t.plotLinesAndBandsGroups[M] = b = n.g("plot-" + M).attr(c).add()), y || (this.svgElem = y = n.path().attr(A).add(b)), Wt(u)) x = t.getPlotLinePath({ value: (s == null ? void 0 : s.log2lin(u)) ?? u, lineWidth: y.strokeWidth(), acrossPanes: e.acrossPanes }); else { if (!(Wt(p) && Wt(d))) return; x = t.getPlotBandPath((s == null ? void 0 : s.log2lin(p)) ?? p, (s == null ? void 0 : s.log2lin(d)) ?? d, e) } return !this.eventsAdded && r && (Fc(r, (k, T) => { y == null || y.on(T, P => { r[T].apply(this, [P]) }) }), this.eventsAdded = !0), (S || !y.d) && (x != null && x.length) ? y.attr({ d: x }) : y && (x ? (y.show(), y.animate({ d: x })) : y.d && (y.hide(), f && (this.label = f = f.destroy()))), m && (Wt(m.text) || Wt(m.formatter)) && (x != null && x.length) && t.width > 0 && t.height > 0 && !x.isFlat ? (m = ln({ align: i && w ? "center" : void 0, x: i ? !w && 4 : 10, verticalAlign: !i && w ? "middle" : void 0, y: i ? w ? 16 : 10 : w ? 6 : -4, rotation: i && !w ? 90 : 0, ...w ? { inside: !0 } : {} }, m), this.renderLabel(m, x, w, a)) : f && f.hide(), this } renderLabel(t, e, i, s) { var g, m; let o = this.axis, r = o.chart.renderer, a = t.inside, n = this.label; n || (this.label = n = r.text(this.getLabelText(t), 0, 0, t.useHTML).attr({ align: t.textAlign || t.align, rotation: t.rotation, class: "highcharts-plot-" + (i ? "band" : "line") + "-label " + (t.className || ""), zIndex: s }), o.chart.styledMode || n.css(ln({ color: (g = o.chart.options.title) == null ? void 0 : g.style.color, fontSize: "0.8em", textOverflow: i && !a ? "" : "ellipsis" }, t.style)), n.add()); let l = e.xBounds || [e[0][1], e[1][1], i ? e[2][1] : e[0][1]], c = e.yBounds || [e[0][2], e[1][2], i ? e[2][2] : e[0][2]], d = nn(l), p = nn(c), u = an(l) - d; n.align(t, !1, { x: d, y: p, width: u, height: an(c) - p }), n.alignAttr.y -= r.fontMetrics(n).b, (!n.alignValue || n.alignValue === "left" || Wt(a)) && n.css({ width: (((m = t.style) == null ? void 0 : m.width) || (i && a ? u : n.rotation === 90 ? o.height - (n.alignAttr.y - o.top) : (t.clip ? o.width : o.chart.chartWidth) - (n.alignAttr.x - o.left))) + "px" }), n.show(!0) } getLabelText(t) { return Wt(t.formatter) ? t.formatter.call(this) : t.text } destroy() { Rc(this.axis.plotLinesAndBands, this), delete this.axis, jc(this) } } let { animObject: Yc } = mt, { format: hn } = At, { composed: Hc, dateFormats: Gc, doc: dn, isSafari: Vc } = C, { distribute: Zc } = Ki, { addEvent: $c, clamp: Xe, css: cn, discardElement: Kc, extend: qc, fireEvent: $o, getAlignFactor: pn, isArray: _c, isNumber: Jc, isObject: Qc, isString: Ko, merge: tp, pick: Ye, pushUnique: ep, splat: qo, syncTimeout: ip } = I; class _o { constructor(t, e, i) { this.allowShared = !0, this.crosshairs = [], this.distance = 0, this.isHidden = !0, this.isSticky = !1, this.options = {}, this.outside = !1, this.chart = t, this.init(t, e), this.pointer = i } bodyFormatter(t) { return t.map(e => { let i = e.series.tooltipOptions, s = e.formatPrefix || "point"; return (i[s + "Formatter"] || e.tooltipFormatter).call(e, i[s + "Format"] || "") }) } cleanSplit(t) { this.chart.series.forEach(function (e) { let i = e == null ? void 0 : e.tt; i && (!i.isActive || t ? e.tt = i.destroy() : i.isActive = !1) }) } defaultFormatter(t) { let e, i = this.points || qo(this); return (e = (e = [t.headerFooterFormatter(i[0])]).concat(t.bodyFormatter(i))).push(t.headerFooterFormatter(i[0], !0)), e } destroy() { this.label && (this.label = this.label.destroy()), this.split && (this.cleanSplit(!0), this.tt && (this.tt = this.tt.destroy())), this.renderer && (this.renderer = this.renderer.destroy(), Kc(this.container)), I.clearTimeout(this.hideTimer) } getAnchor(t, e) { var c; let i, { chart: s, pointer: o } = this, r = s.inverted, a = s.plotTop, n = s.plotLeft; if (t = qo(t), (c = t[0].series) != null && c.yAxis && !t[0].series.yAxis.options.reversedStacks && (t = t.slice().reverse()), this.followPointer && e) e.chartX === void 0 && (e = o.normalize(e)), i = [e.chartX - n, e.chartY - a]; else if (t[0].tooltipPos) i = t[0].tooltipPos; else { let d = 0, p = 0; t.forEach(function (u) { let g = u.pos(!0); g && (d += g[0], p += g[1]) }), d /= t.length, p /= t.length, this.shared && t.length > 1 && e && (r ? d = e.chartX : p = e.chartY), i = [d - n, p - a] } let l = { point: t[0], ret: i }; return $o(this, "getAnchor", l), l.ret.map(Math.round) } getClassName(t, e, i) { let s = this.options, o = t.series, r = o.options; return [s.className, "highcharts-label", i && "highcharts-tooltip-header", e ? "highcharts-tooltip-box" : "highcharts-tooltip", !i && "highcharts-color-" + Ye(t.colorIndex, o.colorIndex), r == null ? void 0 : r.className].filter(Ko).join(" ") } getLabel({ anchorX: t, anchorY: e } = { anchorX: 0, anchorY: 0 }) { let i = this, s = this.chart.styledMode, o = this.options, r = this.split && this.allowShared, a = this.container, n = this.chart.renderer; if (this.label) { let l = !this.label.hasClass("highcharts-label"); (!r && l || r && !l) && this.destroy() } if (!this.label) { if (this.outside) { let l = this.chart, c = l.options.chart.style, d = pi.getRendererType(); this.container = a = C.doc.createElement("div"), a.className = "highcharts-tooltip-container " + (l.renderTo.className.match(/(highcharts[a-zA-Z0-9-]+)\s?/gm) || ""), cn(a, { position: "absolute", top: "1px", pointerEvents: "none", zIndex: Math.max(this.options.style.zIndex || 0, ((c == null ? void 0 : c.zIndex) || 0) + 3) }), this.renderer = n = new d(a, 0, 0, c, void 0, void 0, n.styledMode) } if (r ? this.label = n.g("tooltip") : (this.label = n.label("", t, e, o.shape || "callout", void 0, void 0, o.useHTML, void 0, "tooltip").attr({ padding: o.padding, r: o.borderRadius }), s || this.label.attr({ fill: o.backgroundColor, "stroke-width": o.borderWidth || 0 }).css(o.style).css({ pointerEvents: o.style.pointerEvents || (this.shouldStickOnContact() ? "auto" : "none") })), i.outside) { let l = this.label;[l.xSetter, l.ySetter].forEach((c, d) => { l[d ? "ySetter" : "xSetter"] = p => { c.call(l, i.distance), l[d ? "y" : "x"] = p, a && (a.style[d ? "top" : "left"] = `${p}px`) } }) } this.label.attr({ zIndex: 8 }).shadow(o.shadow ?? !o.fixed).add() } return a && !a.parentElement && C.doc.body.appendChild(a), this.label } getPlayingField() { let { body: t, documentElement: e } = dn, { chart: i, distance: s, outside: o } = this; return { width: o ? Math.max(t.scrollWidth, e.scrollWidth, t.offsetWidth, e.offsetWidth, e.clientWidth) - 2 * s - 2 : i.chartWidth, height: o ? Math.max(t.scrollHeight, e.scrollHeight, t.offsetHeight, e.offsetHeight, e.clientHeight) : i.chartHeight } } getPosition(t, e, i) { var D, z; let { distance: s, chart: o, outside: r, pointer: a } = this, { inverted: n, plotLeft: l, plotTop: c, polar: d } = o, { plotX: p = 0, plotY: u = 0 } = i, g = {}, m = n && i.h || 0, { height: f, width: y } = this.getPlayingField(), x = a.getChartPosition(), b = E => E * x.scaleX, w = E => E * x.scaleY, v = E => { let N = E === "x"; return [E, N ? y : f, N ? t : e].concat(r ? [N ? b(t) : w(e), N ? x.left - s + b(p + l) : x.top - s + w(u + c), 0, N ? y : f] : [N ? t : e, N ? p + l : u + c, N ? l : c, N ? l + o.plotWidth : c + o.plotHeight]) }, S = v("y"), A = v("x"), M, k = !!i.negative; !d && ((z = (D = o.hoverSeries) == null ? void 0 : D.yAxis) != null && z.reversed) && (k = !k); let T = !this.followPointer && Ye(i.ttBelow, !d && !n === k), P = function (E, N, V, W, F, lt, X) { let $ = r ? E === "y" ? w(s) : b(s) : s, R = (V - W) / 2, j = W < F - s, rt = F + s + W < N, K = F - $ - V + R, J = F + $ - R; if (T && rt) g[E] = J; else if (!T && j) g[E] = K; else if (j) g[E] = Math.min(X - W, K - m < 0 ? K : K - m); else { if (!rt) return g[E] = 0, !1; g[E] = Math.max(lt, J + m + V > N ? J : J + m) } }, L = function (E, N, V, W, F) { if (F < s || F > N - s) return !1; F < V / 2 ? g[E] = 1 : F > N - W / 2 ? g[E] = N - W - 2 : g[E] = F - V / 2 }, O = function (E) { [S, A] = [A, S], M = E }, B = () => { P.apply(0, S) !== !1 ? L.apply(0, A) !== !1 || M || (O(!0), B()) : M ? g.x = g.y = 0 : (O(!0), B()) }; return (n && !d || this.len > 1) && O(), B(), g } getFixedPosition(t, e, i) { var p; let s = i.series, { chart: o, options: r, split: a } = this, n = r.position, l = n.relativeTo, c = r.shared || (p = s == null ? void 0 : s.yAxis) != null && p.isRadial && (l === "pane" || !l) ? "plotBox" : l, d = c === "chart" ? o.renderer : o[c] || o.getClipBox(s, !0); return { x: d.x + (d.width - t) * pn(n.align) + n.x, y: d.y + (d.height - e) * pn(n.verticalAlign) + (!a && n.y || 0) } } hide(t) { let e = this; I.clearTimeout(this.hideTimer), t = Ye(t, this.options.hideDelay), this.isHidden || (this.hideTimer = ip(function () { let i = e.getLabel(); e.getLabel().animate({ opacity: 0 }, { duration: t && 150, complete: () => { i.hide(), e.container && e.container.remove() } }), e.isHidden = !0 }, t)) } init(t, e) { this.chart = t, this.options = e, this.crosshairs = [], this.isHidden = !0, this.split = e.split && !t.inverted && !t.polar, this.shared = e.shared || this.split, this.outside = Ye(e.outside, !!(t.scrollablePixelsX || t.scrollablePixelsY)) } shouldStickOnContact(t) { return !!(!this.followPointer && this.options.stickOnContact && (!t || this.pointer.inClass(t.target, "highcharts-tooltip"))) } move(t, e, i, s) { let { followPointer: o, options: r } = this, a = Yc(!o && !this.isHidden && !r.fixed && r.animation), n = o || (this.len || 0) > 1, l = { x: t, y: e }; n ? l.anchorX = l.anchorY = NaN : (l.anchorX = i, l.anchorY = s), a.step = () => this.drawTracker(), this.getLabel().animate(l, a) } refresh(t, e) { let { chart: i, options: s, pointer: o, shared: r } = this, a = qo(t), n = a[0], l = s.format, c = s.formatter || this.defaultFormatter, d = i.styledMode, p = this.allowShared; if (!s.enabled || !n.series) return; I.clearTimeout(this.hideTimer), this.allowShared = !(!_c(t) && t.series && t.series.noSharedTooltip), p = p && !this.allowShared, this.followPointer = !this.split && n.series.tooltipOptions.followPointer; let u = this.getAnchor(t, e), g = u[0], m = u[1]; r && this.allowShared && (o.applyInactiveState(a), a.forEach(x => x.setState("hover")), n.points = a), this.len = a.length; let f = Ko(l) ? hn(l, n, i) : c.call(n, this); n.points = void 0; let y = n.series; if (this.distance = Ye(y.tooltipOptions.distance, 16), f === !1) this.hide(); else { if (this.split && this.allowShared) this.renderSplit(f, a); else { let x = g, b = m; if (e && o.isDirectTouch && (x = e.chartX - i.plotLeft, b = e.chartY - i.plotTop), !(i.polar || y.options.clip === !1 || a.some(w => o.isDirectTouch || w.series.shouldShowTooltip(x, b)))) return void this.hide(); { let w = this.getLabel(p && this.tt || {}); (!s.style.width || d) && w.css({ width: (this.outside ? this.getPlayingField() : i.spacingBox).width + "px" }), w.attr({ class: this.getClassName(n), text: f && f.join ? f.join("") : f }), this.outside && w.attr({ x: Xe(w.x || 0, 0, this.getPlayingField().width - (w.width || 0) - 1) }), d || w.attr({ stroke: s.borderColor || n.color || y.color || "#666666" }), this.updatePosition({ plotX: g, plotY: m, negative: n.negative, ttBelow: n.ttBelow, series: y, h: u[2] || 0 }) } } this.isHidden && this.label && this.label.attr({ opacity: 1 }).show(), this.isHidden = !1 } $o(this, "refresh") } renderSplit(t, e) { var F, lt; let i = this, { chart: s, chart: { chartWidth: o, chartHeight: r, plotHeight: a, plotLeft: n, plotTop: l, scrollablePixelsY: c = 0, scrollablePixelsX: d, styledMode: p }, distance: u, options: g, options: { fixed: m, position: f, positioner: y }, pointer: x } = i, { scrollLeft: b = 0, scrollTop: w = 0 } = ((F = s.scrollablePlotArea) == null ? void 0 : F.scrollingContainer) || {}, v = i.outside && typeof d != "number" ? dn.documentElement.getBoundingClientRect() : { left: b, right: b + o }, S = i.getLabel(), A = this.renderer || s.renderer, M = !!((lt = s.xAxis[0]) != null && lt.opposite), { left: k, top: T } = x.getChartPosition(), P = y || m, L = l + w, O = 0, B = a - c, D = function (X, $, R, j = [0, 0], rt = !0) { let K, J; if (R.isHeader) J = M ? 0 : B, K = Xe(j[0] - X / 2, v.left, v.right - X - (i.outside ? k : 0)); else if (m && R) { let ut = i.getFixedPosition(X, $, R); K = ut.x, J = ut.y - L } else J = j[1] - L, K = Xe(K = rt ? j[0] - X - u : j[0] + u, rt ? K : v.left, v.right); return { x: K, y: J } }; Ko(t) && (t = [!1, t]); let z = t.slice(0, e.length + 1).reduce(function (X, $, R) { if ($ !== !1 && $ !== "") { let j = e[R - 1] || { isHeader: !0, plotX: e[0].plotX, plotY: a, series: {} }, rt = j.isHeader, K = rt ? i : j.series, J = K.tt = function (ft, tt, Xi) { let de = ft, { isHeader: Pe, series: Yi } = tt, Ut = Yi.tooltipOptions || g; if (!de) { let ei = { padding: Ut.padding, r: Ut.borderRadius }; p || (ei.fill = Ut.backgroundColor, ei["stroke-width"] = Ut.borderWidth ?? (m && !Pe ? 0 : 1)), de = A.label("", 0, 0, Ut[Pe ? "headerShape" : "shape"] || (m && !Pe ? "rect" : "callout"), void 0, void 0, Ut.useHTML).addClass(i.getClassName(tt, !0, Pe)).attr(ei).add(S) } return de.isActive = !0, de.attr({ text: Xi }), p || de.css(Ut.style).attr({ stroke: Ut.borderColor || tt.color || Yi.color || "#333333" }), de }(K.tt, j, $.toString()), ut = J.getBBox(), _t = ut.width + J.strokeWidth(); rt && (O = ut.height, B += O, M && (L -= O)); let { anchorX: It, anchorY: vt } = function (ft) { let tt, Xi, { isHeader: de, plotX: Pe = 0, plotY: Yi = 0, series: Ut } = ft; if (de) tt = Math.max(n + Pe, n), Xi = l + a / 2; else { let { xAxis: ei, yAxis: Sh } = Ut; tt = ei.pos + Xe(Pe, -u, ei.len + u), Ut.shouldShowTooltip(0, Sh.pos - l + Yi, { ignoreX: !0 }) && (Xi = Sh.pos + Yi) } return { anchorX: tt = Xe(tt, v.left - u, v.right + u), anchorY: Xi } }(j); if (typeof vt == "number") { let ft = ut.height + 1, tt = (y || D).call(i, _t, ft, j, [It, vt]); X.push({ align: P ? 0 : void 0, anchorX: It, anchorY: vt, boxWidth: _t, point: j, rank: Ye(tt.rank, +!!rt), size: ft, target: tt.y, tt: J, x: tt.x }) } else J.isActive = !1 } return X }, []); !P && z.some(X => { let { outside: $ } = i, R = ($ ? k : 0) + X.anchorX; return R < v.left && R + X.boxWidth < v.right || R < k - v.left + X.boxWidth && v.right - R > R }) && (z = z.map(X => { let { x: $, y: R } = D.call(this, X.boxWidth, X.size, X.point, [X.anchorX, X.anchorY], !1); return qc(X, { target: R, x: $ }) })), i.cleanSplit(), Zc(z, B); let E = { left: k, right: k }; z.forEach(function (X) { let { x: $, boxWidth: R, isHeader: j } = X; !j && (i.outside && k + $ < E.left && (E.left = k + $), !j && i.outside && E.left + R > E.right && (E.right = k + $)) }), z.forEach(function (X) { let { x: $, anchorX: R, anchorY: j, pos: rt, point: { isHeader: K } } = X, J = { visibility: rt === void 0 ? "hidden" : "inherit", x: $, y: (rt || 0) + L + (m && f.y || 0), anchorX: R, anchorY: j }; if (i.outside && $ < R) { let ut = k - E.left; ut > 0 && (K || (J.x = $ + ut, J.anchorX = R + ut), K && (J.x = (E.right - E.left) / 2, J.anchorX = R + ut)) } X.tt.attr(J) }); let { container: N, outside: V, renderer: W } = i; if (V && N && W) { let { width: X, height: $, x: R, y: j } = S.getBBox(); W.setSize(X + R, $ + j, !1), N.style.left = E.left + "px", N.style.top = T + "px" } Vc && S.attr({ opacity: S.opacity === 1 ? .999 : 1 }) } drawTracker() { if (!this.shouldStickOnContact()) { this.tracker && (this.tracker = this.tracker.destroy()); return } let t = this.chart, e = this.label, i = this.shared ? t.hoverPoints : t.hoverPoint; if (!e || !i) return; let s = { x: 0, y: 0, width: 0, height: 0 }, o = this.getAnchor(i), r = e.getBBox(); o[0] += t.plotLeft - (e.translateX || 0), o[1] += t.plotTop - (e.translateY || 0), s.x = Math.min(0, o[0]), s.y = Math.min(0, o[1]), s.width = o[0] < 0 ? Math.max(Math.abs(o[0]), r.width - o[0]) : Math.max(Math.abs(o[0]), r.width), s.height = o[1] < 0 ? Math.max(Math.abs(o[1]), r.height - Math.abs(o[1])) : Math.max(Math.abs(o[1]), r.height), this.tracker ? this.tracker.attr(s) : (this.tracker = e.renderer.rect(s).addClass("highcharts-tracker").add(e), t.styledMode || this.tracker.attr({ fill: "rgba(0,0,0,0)" })) } styledModeFormat(t) { return t.replace('style="font-size: 0.8em"', 'class="highcharts-header"').replace(/style="color:{(point|series)\.color}"/g, 'class="highcharts-color-{$1.colorIndex} {series.options.className} {point.options.className}"') } headerFooterFormatter(t, e) { let i = t.series, s = i.tooltipOptions, o = i.xAxis, r = o == null ? void 0 : o.dateTime, a = { isFooter: e, point: t }, n = s.xDateFormat || "", l = s[e ? "footerFormat" : "headerFormat"]; return $o(this, "headerFormatter", a, function (c) { if (r && !n && Jc(t.key) && (n = r.getXDateFormat(t.key, s.dateTimeLabelFormats)), r && n) { if (Qc(n)) { let d = n; Gc[0] = p => i.chart.time.dateFormat(d, p), n = "%0" } (t.tooltipDateKeys || ["key"]).forEach(d => { l = l.replace(RegExp("point\\." + d + "([ \\)}])"), `(point.${d}:${n})$1`) }) } i.chart.styledMode && (l = this.styledModeFormat(l)), c.text = hn(l, t, this.chart) }), a.text || "" } update(t) { this.destroy(), this.init(this.chart, tp(!0, this.options, t)) } updatePosition(t) { var v; let { chart: e, container: i, distance: s, options: o, pointer: r, renderer: a } = this, { height: n = 0, width: l = 0 } = this.getLabel(), { fixed: c, positioner: d } = o, { left: p, top: u, scaleX: g, scaleY: m } = r.getChartPosition(), f = (d || c && this.getFixedPosition || this.getPosition).call(this, l, n, t), y = C.doc, x = (t.plotX || 0) + e.plotLeft, b = (t.plotY || 0) + e.plotTop, w; if (a && i) { if (d || c) { let { scrollLeft: S = 0, scrollTop: A = 0 } = ((v = e.scrollablePlotArea) == null ? void 0 : v.scrollingContainer) || {}; f.x += S + p - s, f.y += A + u - s } w = (o.borderWidth || 0) + 2 * s + 2, a.setSize(Xe(l + w, 0, y.documentElement.clientWidth) - 1, n + w, !1), (g !== 1 || m !== 1) && (cn(i, { transform: `scale(${g}, ${m})` }), x *= g, b *= m), x += p - f.x, b += u - f.y } this.move(Math.round(f.x), Math.round(f.y || 0), x, b) } } (function (h) { h.compose = function (t) { ep(Hc, "Core.Tooltip") && $c(t, "afterInit", function () { let e = this.chart; e.options.tooltip && (e.tooltip = new h(e, e.options.tooltip, this)) }) } })(_o || (_o = {})); let un = _o, { animObject: sp } = mt, { defaultOptions: op } = wt, { format: rp } = At, { addEvent: ap, crisp: np, erase: lp, extend: gs, fireEvent: Jo, getNestedProperty: hp, isArray: dp, isFunction: cp, isNumber: ee, isObject: ms, merge: gn, pick: ie, syncTimeout: pp, removeEvent: mn, uniqueKey: up } = I; class bi { animateBeforeDestroy() { let t = this, e = { x: t.startXPos, opacity: 0 }, i = t.getGraphicalProps(); i.singular.forEach(function (s) { t[s] = t[s].animate(s === "dataLabel" ? { x: t[s].startXPos, y: t[s].startYPos, opacity: 0 } : e) }), i.plural.forEach(function (s) { t[s].forEach(function (o) { o.element && o.animate(gs({ x: t.startXPos }, o.startYPos ? { x: o.startXPos, y: o.startYPos } : {})) }) }) } applyOptions(t, e) { let i = this.series, s = i.options.pointValKey || i.pointValKey; return gs(this, t = bi.prototype.optionsToObject.call(this, t)), this.options = this.options ? gs(this.options, t) : t, t.group && delete this.group, t.dataLabels && delete this.dataLabels, s && (this.y = bi.prototype.getNestedProperty.call(this, s)), this.selected && (this.state = "select"), "name" in this && e === void 0 && i.xAxis && i.xAxis.hasNames && (this.x = i.xAxis.nameToX(this)), this.x === void 0 && i ? this.x = e ?? i.autoIncrement() : ee(t.x) && i.options.relativeXValue ? this.x = i.autoIncrement(t.x) : typeof this.x == "string" && (e ?? (e = i.chart.time.parse(this.x)), ee(e) && (this.x = e)), this.isNull = this.isValid && !this.isValid(), this.formatPrefix = this.isNull ? "null" : "point", this } destroy() { if (!this.destroyed) { let t = this, e = t.series, i = e.chart, s = e.options.dataSorting, o = i.hoverPoints, r = sp(t.series.chart.renderer.globalAnimation), a = () => { for (let n in (t.graphic || t.graphics || t.dataLabel || t.dataLabels) && (mn(t), t.destroyElements()), t) delete t[n] }; t.legendItem && i.legend.destroyItem(t), o && (t.setState(), lp(o, t), o.length || (i.hoverPoints = null)), t === i.hoverPoint && t.onMouseOut(), s != null && s.enabled ? (this.animateBeforeDestroy(), pp(a, r.duration)) : a(), i.pointCount-- } this.destroyed = !0 } destroyElements(t) { let e = this, i = e.getGraphicalProps(t); i.singular.forEach(function (s) { e[s] = e[s].destroy() }), i.plural.forEach(function (s) { e[s].forEach(function (o) { o != null && o.element && o.destroy() }), delete e[s] }) } firePointEvent(t, e, i) { let s = this, o = this.series.options; s.manageEvent(t), t === "click" && o.allowPointSelect && (i = function (r) { !s.destroyed && s.select && s.select(null, r.ctrlKey || r.metaKey || r.shiftKey) }), Jo(s, t, e, i) } getClassName() { var t; return "highcharts-point" + (this.selected ? " highcharts-point-select" : "") + (this.negative ? " highcharts-negative" : "") + (this.isNull ? " highcharts-null-point" : "") + (this.colorIndex !== void 0 ? " highcharts-color-" + this.colorIndex : "") + (this.options.className ? " " + this.options.className : "") + ((t = this.zone) != null && t.className ? " " + this.zone.className.replace("highcharts-negative", "") : "") } getGraphicalProps(t) { let e, i, s = this, o = [], r = { singular: [], plural: [] }; for ((t = t || { graphic: 1, dataLabel: 1 }).graphic && o.push("graphic", "connector"), t.dataLabel && o.push("dataLabel", "dataLabelPath", "dataLabelUpper"), i = o.length; i--;)s[e = o[i]] && r.singular.push(e); return ["graphic", "dataLabel"].forEach(function (a) { let n = a + "s"; t[a] && s[n] && r.plural.push(n) }), r } getNestedProperty(t) { if (t) return t.indexOf("custom.") === 0 ? hp(t, this.options) : this[t] } getZone() { let t = this.series, e = t.zones, i = t.zoneAxis || "y", s, o = 0; for (s = e[0]; this[i] >= s.value;)s = e[++o]; return this.nonZonedColor || (this.nonZonedColor = this.color), s != null && s.color && !this.options.color ? this.color = s.color : this.color = this.nonZonedColor, s } hasNewShapeType() { return (this.graphic && (this.graphic.symbolName || this.graphic.element.nodeName)) !== this.shapeType } constructor(t, e, i) { this.formatPrefix = "point", this.visible = !0, this.point = this, this.series = t, this.applyOptions(e, i), this.id ?? (this.id = up()), this.resolveColor(), this.dataLabelOnNull ?? (this.dataLabelOnNull = t.options.nullInteraction), t.chart.pointCount++, Jo(this, "afterInit") } isValid() { return (ee(this.x) || this.x instanceof Date) && ee(this.y) } optionsToObject(t) { var c; let e = this.series, i = e.options.keys, s = i || e.pointArrayMap || ["y"], o = s.length, r = {}, a, n = 0, l = 0; if (ee(t) || t === null) r[s[0]] = t; else if (dp(t)) for (!i && t.length > o && ((a = typeof t[0]) == "string" ? (c = e.xAxis) != null && c.dateTime ? r.x = e.chart.time.parse(t[0]) : r.name = t[0] : a === "number" && (r.x = t[0]), n++); l < o;)i && t[n] === void 0 || (s[l].indexOf(".") > 0 ? bi.prototype.setNestedProperty(r, t[n], s[l]) : r[s[l]] = t[n]), n++, l++; else typeof t == "object" && (r = t, t.dataLabels && (e.hasDataLabels = () => !0), t.marker && (e._hasPointMarkers = !0)); return r } pos(t, e = this.plotY) { if (!this.destroyed) { let { plotX: i, series: s } = this, { chart: o, xAxis: r, yAxis: a } = s, n = 0, l = 0; if (ee(i) && ee(e)) return t && (n = r ? r.pos : o.plotLeft, l = a ? a.pos : o.plotTop), o.inverted && r && a ? [a.len - e + l, r.len - i + n] : [i + n, e + l] } } resolveColor() { let t = this.series, e = t.chart.options.chart, i = t.chart.styledMode, s, o, r = e.colorCount, a; delete this.nonZonedColor, t.options.colorByPoint ? (i || (s = (o = t.options.colors || t.chart.options.colors)[t.colorCounter], r = o.length), a = t.colorCounter, t.colorCounter++, t.colorCounter === r && (t.colorCounter = 0)) : (i || (s = t.color), a = t.colorIndex), this.colorIndex = ie(this.options.colorIndex, a), this.color = ie(this.options.color, s) } setNestedProperty(t, e, i) { return i.split(".").reduce(function (s, o, r, a) { let n = a.length - 1 === r; return s[o] = n ? e : ms(s[o], !0) ? s[o] : {}, s[o] }, t), t } shouldDraw() { return !this.isNull } tooltipFormatter(t) { var n; let { chart: e, pointArrayMap: i = ["y"], tooltipOptions: s } = this.series, { valueDecimals: o = "", valuePrefix: r = "", valueSuffix: a = "" } = s; return e.styledMode && (t = ((n = e.tooltip) == null ? void 0 : n.styledModeFormat(t)) || t), i.forEach(l => { l = "{point." + l, (r || a) && (t = t.replace(RegExp(l + "}", "g"), r + l + "}" + a)), t = t.replace(RegExp(l + "}", "g"), l + ":,." + o + "f}") }), rp(t, this, e) } update(t, e, i, s) { let o, r = this, a = r.series, n = r.graphic, l = a.chart, c = a.options; function d() { r.applyOptions(t); let p = n && r.hasMockGraphic, u = r.y === null ? !p : p; n && u && (r.graphic = n.destroy(), delete r.hasMockGraphic), ms(t, !0) && (n != null && n.element && t && t.marker && t.marker.symbol !== void 0 && (r.graphic = n.destroy()), t != null && t.dataLabels && r.dataLabel && (r.dataLabel = r.dataLabel.destroy())), o = r.index; let g = {}; for (let m of a.dataColumnKeys()) g[m] = r[m]; a.dataTable.setRow(g, o), c.data[o] = ms(c.data[o], !0) || ms(t, !0) ? r.options : ie(t, c.data[o]), a.isDirty = a.isDirtyData = !0, !a.fixedBox && a.hasCartesianSeries && (l.isDirtyBox = !0), c.legendType === "point" && (l.isDirtyLegend = !0), e && l.redraw(i) } e = ie(e, !0), s === !1 ? d() : r.firePointEvent("update", { options: t }, d) } remove(t, e) { this.series.removePoint(this.series.data.indexOf(this), t, e) } select(t, e) { let i = this, s = i.series, o = s.chart; t = ie(t, !i.selected), this.selectedStaging = t, i.firePointEvent(t ? "select" : "unselect", { accumulate: e }, function () { i.selected = i.options.selected = t, s.options.data[s.data.indexOf(i)] = i.options, i.setState(t && "select"), e || o.getSelectedPoints().forEach(function (r) { let a = r.series; r.selected && r !== i && (r.selected = r.options.selected = !1, a.options.data[a.data.indexOf(r)] = r.options, r.setState(o.hoverPoints && a.options.inactiveOtherPoints ? "inactive" : ""), r.firePointEvent("unselect")) }) }), delete this.selectedStaging } onMouseOver(t) { let { inverted: e, pointer: i } = this.series.chart; i && (t = t ? i.normalize(t) : i.getChartCoordinatesFromPoint(this, e), i.runPointActions(t, this)) } onMouseOut() { let t = this.series.chart; this.firePointEvent("mouseOut"), this.series.options.inactiveOtherPoints || (t.hoverPoints || []).forEach(function (e) { e.setState() }), t.hoverPoints = t.hoverPoint = null } manageEvent(t) { var s, o, r, a, n, l, c; let e = gn(this.series.options.point, this.options), i = (s = e.events) == null ? void 0 : s[t]; cp(i) && (!((o = this.hcEvents) != null && o[t]) || ((a = (r = this.hcEvents) == null ? void 0 : r[t]) == null ? void 0 : a.map(d => d.fn).indexOf(i)) === -1) ? ((n = this.importedUserEvent) == null || n.call(this), this.importedUserEvent = ap(this, t, i), this.hcEvents && (this.hcEvents[t].userEvent = !0)) : this.importedUserEvent && !i && ((l = this.hcEvents) != null && l[t]) && ((c = this.hcEvents) != null && c[t].userEvent) && (mn(this, t), delete this.hcEvents[t], Object.keys(this.hcEvents) || delete this.importedUserEvent) } setState(t, e) { var S, A; let i = this.series, s = this.state, o = i.options.states[t || "normal"] || {}, r = op.plotOptions[i.type].marker && i.options.marker, a = r && r.enabled === !1, n = ((S = r == null ? void 0 : r.states) == null ? void 0 : S[t || "normal"]) || {}, l = n.enabled === !1, c = this.marker || {}, d = i.chart, p = r && i.markerAttribs, u = i.halo, g, m, f, y = i.stateMarkerGraphic, x; if ((t = t || "") === this.state && !e || this.selected && t !== "select" || o.enabled === !1 || t && (l || a && n.enabled === !1) || t && c.states && c.states[t] && c.states[t].enabled === !1) return; if (this.state = t, p && (g = i.markerAttribs(this, t)), this.graphic && !this.hasMockGraphic) { if (s && this.graphic.removeClass("highcharts-point-" + s), t && this.graphic.addClass("highcharts-point-" + t), !d.styledMode) { m = i.pointAttribs(this, t), f = ie(d.options.chart.animation, o.animation); let M = m.opacity; i.options.inactiveOtherPoints && ee(M) && (this.dataLabels || []).forEach(function (k) { k && !k.hasClass("highcharts-data-label-hidden") && (k.animate({ opacity: M }, f), k.connector && k.connector.animate({ opacity: M }, f)) }), this.graphic.animate(m, f) } g && this.graphic.animate(g, ie(d.options.chart.animation, n.animation, r.animation)), y && y.hide() } else t && n && (x = c.symbol || i.symbol, y && y.currentSymbol !== x && (y = y.destroy()), g && (y ? y[e ? "animate" : "attr"]({ x: g.x, y: g.y }) : x && (i.stateMarkerGraphic = y = d.renderer.symbol(x, g.x, g.y, g.width, g.height, gn(r, n)).add(i.markerGroup), y.currentSymbol = x)), !d.styledMode && y && this.state !== "inactive" && y.attr(i.pointAttribs(this, t))), y && (y[t && this.isInside ? "show" : "hide"](), y.element.point = this, y.addClass(this.getClassName(), !0)); let b = o.halo, w = this.graphic || y, v = (w == null ? void 0 : w.visibility) || "inherit"; b != null && b.size && w && v !== "hidden" && !this.isCluster ? (u || (i.halo = u = d.renderer.path().add(w.parentGroup)), u.show()[e ? "animate" : "attr"]({ d: this.haloPath(b.size) }), u.attr({ class: "highcharts-halo highcharts-color-" + ie(this.colorIndex, i.colorIndex) + (this.className ? " " + this.className : ""), visibility: v, zIndex: -1 }), u.point = this, d.styledMode || u.attr(gs({ fill: this.color || i.color, "fill-opacity": b.opacity }, et.filterUserAttributes(b.attributes || {})))) : (A = u == null ? void 0 : u.point) != null && A.haloPath && !u.point.destroyed && u.animate({ d: u.point.haloPath(0) }, null, u.hide), Jo(this, "afterSetState", { state: t }) } haloPath(t) { let e = this.pos(); return e ? this.series.chart.renderer.symbols.circle(np(e[0], 1) - t, e[1] - t, 2 * t, 2 * t) : [] } } let $t = bi, { parse: gp } = _, { charts: Qo, composed: mp, isTouchDevice: fp } = C, { addEvent: Lt, attr: yp, css: tr, extend: er, find: fn, fireEvent: se, isNumber: fs, isObject: ys, objectEach: xp, offset: bp, pick: Ft, pushUnique: vp, splat: yn } = I; class ct { applyInactiveState(t = []) { let e = []; t.forEach(i => { let s = i.series; e.push(s), s.linkedParent && e.push(s.linkedParent), s.linkedSeries && e.push.apply(e, s.linkedSeries), s.navigatorSeries && e.push(s.navigatorSeries), s.boosted && s.markerGroup && e.push.apply(e, this.chart.series.filter(o => o.markerGroup === s.markerGroup)) }), this.chart.series.forEach(i => { e.indexOf(i) === -1 ? i.setState("inactive", !0) : i.options.inactiveOtherPoints && i.setAllPointsToState("inactive") }) } destroy() { let t = this; this.eventsToUnbind.forEach(e => e()), this.eventsToUnbind = [], !C.chartCount && (ct.unbindDocumentMouseUp.forEach(e => e.unbind()), ct.unbindDocumentMouseUp.length = 0, ct.unbindDocumentTouchEnd && (ct.unbindDocumentTouchEnd = ct.unbindDocumentTouchEnd())), clearInterval(t.tooltipTimeout), xp(t, function (e, i) { t[i] = void 0 }) } getSelectionMarkerAttrs(t, e) { let i = { args: { chartX: t, chartY: e }, attrs: {}, shapeType: "rect" }; return se(this, "getSelectionMarkerAttrs", i, s => { let o, { chart: r, zoomHor: a, zoomVert: n } = this, { mouseDownX: l = 0, mouseDownY: c = 0 } = r, d = s.attrs; d.x = r.plotLeft, d.y = r.plotTop, d.width = a ? 1 : r.plotWidth, d.height = n ? 1 : r.plotHeight, a && (d.width = Math.max(1, Math.abs(o = t - l)), d.x = (o > 0 ? 0 : o) + l), n && (d.height = Math.max(1, Math.abs(o = e - c)), d.y = (o > 0 ? 0 : o) + c) }), i } drag(t) { let { chart: e } = this, { mouseDownX: i = 0, mouseDownY: s = 0 } = e, { panning: o, panKey: r, selectionMarkerFill: a } = e.options.chart, n = e.plotLeft, l = e.plotTop, c = e.plotWidth, d = e.plotHeight, p = ys(o) ? o.enabled : o, u = r && t[`${r}Key`], g = t.chartX, m = t.chartY, f, y = this.selectionMarker; if ((!y || !y.touch) && (g < n ? g = n : g > n + c && (g = n + c), m < l ? m = l : m > l + d && (m = l + d), this.hasDragged = Math.sqrt(Math.pow(i - g, 2) + Math.pow(s - m, 2)), this.hasDragged > 10)) { f = e.isInsidePlot(i - n, s - l, { visiblePlotOnly: !0 }); let { shapeType: x, attrs: b } = this.getSelectionMarkerAttrs(g, m); this.hasZoom && f && !u && !y && (this.selectionMarker = y = e.renderer[x](), y.attr({ class: "highcharts-selection-marker", zIndex: 7 }).add(), e.styledMode || y.attr({ fill: a || gp("#334eff").setOpacity(.25).get() })), y && y.attr(b), f && !y && p && e.pan(t, o) } } dragStart(t) { let e = this.chart; e.mouseIsDown = t.type, e.cancelClick = !1, e.mouseDownX = t.chartX, e.mouseDownY = t.chartY } getSelectionBox(t) { let e = { args: { marker: t }, result: t.getBBox() }; return se(this, "getSelectionBox", e), e.result } drop(t) { let e, { chart: i, selectionMarker: s } = this; for (let o of i.axes) o.isPanning && (o.isPanning = !1, (o.options.startOnTick || o.options.endOnTick || o.series.some(r => r.boosted)) && (o.forceRedraw = !0, o.setExtremes(o.userMin, o.userMax, !1), e = !0)); if (e && i.redraw(), s && t) { if (this.hasDragged) { let o = this.getSelectionBox(s); i.transform({ axes: i.axes.filter(r => r.zoomEnabled && (r.coll === "xAxis" && this.zoomX || r.coll === "yAxis" && this.zoomY)), selection: { originalEvent: t, xAxis: [], yAxis: [], ...o }, from: o }) } fs(i.index) && (this.selectionMarker = s.destroy()) } i && fs(i.index) && (tr(i.container, { cursor: i._cursor }), i.cancelClick = this.hasDragged > 10, i.mouseIsDown = !1, this.hasDragged = 0, this.pinchDown = []) } findNearestKDPoint(t, e, i) { let s; return t.forEach(function (o) { let r = !(o.noSharedTooltip && e) && 0 > o.options.findNearestPointBy.indexOf("y"), a = o.searchPoint(i, r); ys(a, !0) && a.series && (!ys(s, !0) || function (n, l) { var u, g; let c = n.distX - l.distX, d = n.dist - l.dist, p = ((u = l.series.group) == null ? void 0 : u.zIndex) - ((g = n.series.group) == null ? void 0 : g.zIndex); return c !== 0 && e ? c : d !== 0 ? d : p !== 0 ? p : n.series.index > l.series.index ? -1 : 1 }(s, a) > 0) && (s = a) }), s } getChartCoordinatesFromPoint(t, e) { let { xAxis: i, yAxis: s } = t.series, o = t.shapeArgs; if (i && s) { let r = t.clientX ?? t.plotX ?? 0, a = t.plotY || 0; return t.isNode && o && fs(o.x) && fs(o.y) && (r = o.x, a = o.y), e ? { chartX: s.len + s.pos - a, chartY: i.len + i.pos - r } : { chartX: r + i.pos, chartY: a + s.pos } } if (o != null && o.x && o.y) return { chartX: o.x, chartY: o.y } } getChartPosition() { if (this.chartPosition) return this.chartPosition; let { container: t } = this.chart, e = bp(t); this.chartPosition = { left: e.left, top: e.top, scaleX: 1, scaleY: 1 }; let { offsetHeight: i, offsetWidth: s } = t; return s > 2 && i > 2 && (this.chartPosition.scaleX = e.width / s, this.chartPosition.scaleY = e.height / i), this.chartPosition } getCoordinates(t) { let e = { xAxis: [], yAxis: [] }; for (let i of this.chart.axes) e[i.isXAxis ? "xAxis" : "yAxis"].push({ axis: i, value: i.toValue(t[i.horiz ? "chartX" : "chartY"]) }); return e } getHoverData(t, e, i, s, o, r) { let a = [], n = function (u) { return u.visible && !(!o && u.directTouch) && Ft(u.options.enableMouseTracking, !0) }, l = e, c, d = { chartX: r ? r.chartX : void 0, chartY: r ? r.chartY : void 0, shared: o }; se(this, "beforeGetHoverData", d), c = l && !l.stickyTracking ? [l] : i.filter(u => u.stickyTracking && (d.filter || n)(u)); let p = s && t || !r ? t : this.findNearestKDPoint(c, o, r); return l = p == null ? void 0 : p.series, p && (o && !l.noSharedTooltip ? (c = i.filter(function (u) { return d.filter ? d.filter(u) : n(u) && !u.noSharedTooltip })).forEach(function (u) { var f; let g = (f = u.options) == null ? void 0 : f.nullInteraction, m = fn(u.points, function (y) { return y.x === p.x && (!y.isNull || !!g) }); ys(m) && (u.boosted && u.boost && (m = u.boost.getPoint(m)), a.push(m)) }) : a.push(p)), se(this, "afterGetHoverData", d = { hoverPoint: p }), { hoverPoint: d.hoverPoint, hoverSeries: l, hoverPoints: a } } getPointFromEvent(t) { let e = t.target, i; for (; e && !i;)i = e.point, e = e.parentNode; return i } onTrackerMouseOut(t) { let e = this.chart, i = t.relatedTarget, s = e.hoverSeries; this.isDirectTouch = !1, !s || !i || s.stickyTracking || this.inClass(i, "highcharts-tooltip") || this.inClass(i, "highcharts-series-" + s.index) && this.inClass(i, "highcharts-tracker") || s.onMouseOut() } inClass(t, e) { let i = t, s; for (; i;) { if (s = yp(i, "class")) { if (s.indexOf(e) !== -1) return !0; if (s.indexOf("highcharts-container") !== -1) return !1 } i = i.parentElement } } constructor(t, e) { var i; this.hasDragged = 0, this.pointerCaptureEventsToUnbind = [], this.eventsToUnbind = [], this.options = e, this.chart = t, this.runChartClick = !!((i = e.chart.events) != null && i.click), this.pinchDown = [], this.setDOMEvents(), se(this, "afterInit") } normalize(t, e) { let i = t.touches, s = i ? i.length ? i.item(0) : Ft(i.changedTouches, t.changedTouches)[0] : t; e || (e = this.getChartPosition()); let o = s.pageX - e.left, r = s.pageY - e.top; return er(t, { chartX: Math.round(o /= e.scaleX), chartY: Math.round(r /= e.scaleY) }) } onContainerClick(t) { let e = this.chart, i = e.hoverPoint, s = this.normalize(t), o = e.plotLeft, r = e.plotTop; !e.cancelClick && (i && this.inClass(s.target, "highcharts-tracker") ? (se(i.series, "click", er(s, { point: i })), e.hoverPoint && i.firePointEvent("click", s)) : (er(s, this.getCoordinates(s)), e.isInsidePlot(s.chartX - o, s.chartY - r, { visiblePlotOnly: !0 }) && se(e, "click", s))) } onContainerMouseDown(t) { var i; let e = (1 & (t.buttons || t.button)) == 1; t = this.normalize(t), C.isFirefox && t.button !== 0 && this.onContainerMouseMove(t), (t.button === void 0 || e) && (this.zoomOption(t), e && ((i = t.preventDefault) == null || i.call(t)), this.dragStart(t)) } onContainerMouseLeave(t) { let { pointer: e } = Qo[Ft(ct.hoverChartIndex, -1)] || {}; t = this.normalize(t), this.onContainerMouseMove(t), e && !this.inClass(t.relatedTarget, "highcharts-tooltip") && (e.reset(), e.chartPosition = void 0) } onContainerMouseEnter() { delete this.chartPosition } onContainerMouseMove(t) { var o; let e = this.chart, i = e.tooltip, s = this.normalize(t); this.setHoverChartIndex(t), (e.mouseIsDown === "mousedown" || this.touchSelect(s)) && this.drag(s), !((o = e.exporting) != null && o.openMenu) && (this.inClass(s.target, "highcharts-tracker") || e.isInsidePlot(s.chartX - e.plotLeft, s.chartY - e.plotTop, { visiblePlotOnly: !0 })) && !(i != null && i.shouldStickOnContact(s)) && (this.inClass(s.target, "highcharts-no-tooltip") ? this.reset(!1, 0) : this.runPointActions(s)) } onDocumentTouchEnd(t) { this.onDocumentMouseUp(t) } onContainerTouchMove(t) { this.touchSelect(t) ? this.onContainerMouseMove(t) : this.touch(t) } onContainerTouchStart(t) { this.touchSelect(t) ? this.onContainerMouseDown(t) : (this.zoomOption(t), this.touch(t, !0)) } onDocumentMouseMove(t) { let e = this.chart, i = e.tooltip, s = this.chartPosition, o = this.normalize(t, s); !s || e.isInsidePlot(o.chartX - e.plotLeft, o.chartY - e.plotTop, { visiblePlotOnly: !0 }) || i != null && i.shouldStickOnContact(o) || o.target !== e.container.ownerDocument && this.inClass(o.target, "highcharts-tracker") || this.reset() } onDocumentMouseUp(t) { var e, i; (i = (e = Qo[Ft(ct.hoverChartIndex, -1)]) == null ? void 0 : e.pointer) == null || i.drop(t) } pinch(t) { let e = this, { chart: i, hasZoom: s, lastTouches: o } = e, r = [].map.call(t.touches || [], d => e.normalize(d)), a = r.length, n = a === 1 && (e.inClass(t.target, "highcharts-tracker") && i.runTrackerClick || e.runChartClick), l = i.tooltip, c = a === 1 && Ft(l == null ? void 0 : l.options.followTouchMove, !0); a > 1 ? e.initiated = !0 : c && (e.initiated = !1), s && e.initiated && !n && t.cancelable !== !1 && t.preventDefault(), t.type === "touchstart" ? (e.pinchDown = r, e.res = !0, i.mouseDownX = t.chartX) : c ? this.runPointActions(e.normalize(t)) : o && (se(i, "touchpan", { originalEvent: t, touches: r }, () => { let d = p => { let u = p[0], g = p[1] || u; return { x: u.chartX, y: u.chartY, width: g.chartX - u.chartX, height: g.chartY - u.chartY } }; i.transform({ axes: i.axes.filter(p => p.zoomEnabled && (this.zoomHor && p.horiz || this.zoomVert && !p.horiz)), to: d(r), from: d(o), trigger: t.type }) }), e.res && (e.res = !1, this.reset(!1, 0))), e.lastTouches = r } reset(t, e) { let i = this.chart, s = i.hoverSeries, o = i.hoverPoint, r = i.hoverPoints, a = i.tooltip, n = a != null && a.shared ? r : o; t && n && yn(n).forEach(function (l) { l.series.isCartesian && l.plotX === void 0 && (t = !1) }), t ? a && n && yn(n).length && (a.refresh(n), a.shared && r ? r.forEach(function (l) { l.setState(l.state, !0), l.series.isCartesian && (l.series.xAxis.crosshair && l.series.xAxis.drawCrosshair(null, l), l.series.yAxis.crosshair && l.series.yAxis.drawCrosshair(null, l)) }) : o && (o.setState(o.state, !0), i.axes.forEach(function (l) { l.crosshair && o.series[l.coll] === l && l.drawCrosshair(null, o) }))) : (o && o.onMouseOut(), r && r.forEach(function (l) { l.setState() }), s && s.onMouseOut(), a && a.hide(e), this.unDocMouseMove && (this.unDocMouseMove = this.unDocMouseMove()), i.axes.forEach(function (l) { l.hideCrosshair() }), i.hoverPoints = i.hoverPoint = void 0) } runPointActions(t, e, i) { var m; let s = this.chart, o = s.series, r = (m = s.tooltip) != null && m.options.enabled ? s.tooltip : void 0, a = !!r && r.shared, n = e || s.hoverPoint, l = (n == null ? void 0 : n.series) || s.hoverSeries, c = (!t || t.type !== "touchmove") && (!!e || (l == null ? void 0 : l.directTouch) && this.isDirectTouch), d = this.getHoverData(n, l, o, c, a, t); n = d.hoverPoint, l = d.hoverSeries; let p = d.hoverPoints, u = (l == null ? void 0 : l.tooltipOptions.followPointer) && !l.tooltipOptions.split, g = a && l && !l.noSharedTooltip; if (n && (i || n !== s.hoverPoint || r != null && r.isHidden)) { if ((s.hoverPoints || []).forEach(function (f) { p.indexOf(f) === -1 && f.setState() }), s.hoverSeries !== l && l.onMouseOver(), this.applyInactiveState(p), (p || []).forEach(function (f) { f.setState("hover") }), s.hoverPoint && s.hoverPoint.firePointEvent("mouseOut"), !n.series) return; s.hoverPoints = p, s.hoverPoint = n, n.firePointEvent("mouseOver", void 0, () => { r && n && r.refresh(g ? p : n, t) }) } else if (u && r && !r.isHidden) { let f = r.getAnchor([{}], t); s.isInsidePlot(f[0], f[1], { visiblePlotOnly: !0 }) && r.updatePosition({ plotX: f[0], plotY: f[1] }) } this.unDocMouseMove || (this.unDocMouseMove = Lt(s.container.ownerDocument, "mousemove", f => { var y, x; return (x = (y = Qo[ct.hoverChartIndex ?? -1]) == null ? void 0 : y.pointer) == null ? void 0 : x.onDocumentMouseMove(f) }), this.eventsToUnbind.push(this.unDocMouseMove)), s.axes.forEach(function (f) { var b; let y, x = ((b = f.crosshair) == null ? void 0 : b.snap) ?? !0; x && ((y = s.hoverPoint) && y.series[f.coll] === f || (y = fn(p, w => { var v; return ((v = w.series) == null ? void 0 : v[f.coll]) === f }))), y || !x ? f.drawCrosshair(t, y) : f.hideCrosshair() }) } setDOMEvents() { let t = this.chart.container, e = t.ownerDocument; t.onmousedown = this.onContainerMouseDown.bind(this), t.onmousemove = this.onContainerMouseMove.bind(this), t.onclick = this.onContainerClick.bind(this), this.eventsToUnbind.push(Lt(t, "mouseenter", this.onContainerMouseEnter.bind(this)), Lt(t, "mouseleave", this.onContainerMouseLeave.bind(this))), ct.unbindDocumentMouseUp.some(s => s.doc === e) || ct.unbindDocumentMouseUp.push({ doc: e, unbind: Lt(e, "mouseup", this.onDocumentMouseUp.bind(this)) }); let i = this.chart.renderTo.parentElement; for (; i && i.tagName !== "BODY";)this.eventsToUnbind.push(Lt(i, "scroll", () => { delete this.chartPosition })), i = i.parentElement; this.eventsToUnbind.push(Lt(t, "touchstart", this.onContainerTouchStart.bind(this), { passive: !1 }), Lt(t, "touchmove", this.onContainerTouchMove.bind(this), { passive: !1 })), ct.unbindDocumentTouchEnd || (ct.unbindDocumentTouchEnd = Lt(e, "touchend", this.onDocumentTouchEnd.bind(this), { passive: !1 })), this.setPointerCapture(), Lt(this.chart, "redraw", this.setPointerCapture.bind(this)) } setPointerCapture() { var o, r; if (!fp) return; let t = this.pointerCaptureEventsToUnbind, e = this.chart, i = e.container, s = Ft((o = e.options.tooltip) == null ? void 0 : o.followTouchMove, !0) && e.series.some(a => a.options.findNearestPointBy.indexOf("y") > -1); !this.hasPointerCapture && s ? (t.push(Lt(i, "pointerdown", a => { var n, l; (n = a.target) != null && n.hasPointerCapture(a.pointerId) && ((l = a.target) == null || l.releasePointerCapture(a.pointerId)) }), Lt(i, "pointermove", a => { var n, l; (l = (n = e.pointer) == null ? void 0 : n.getPointFromEvent(a)) == null || l.onMouseOver(a) })), e.styledMode || tr(i, { "touch-action": "none" }), i.className += " highcharts-no-touch-action", this.hasPointerCapture = !0) : this.hasPointerCapture && !s && (t.forEach(a => a()), t.length = 0, e.styledMode || tr(i, { "touch-action": Ft((r = e.options.chart.style) == null ? void 0 : r["touch-action"], "manipulation") }), i.className = i.className.replace(" highcharts-no-touch-action", ""), this.hasPointerCapture = !1) } setHoverChartIndex(t) { var s; let e = this.chart, i = C.charts[Ft(ct.hoverChartIndex, -1)]; if (i && i !== e) { let o = { relatedTarget: e.container }; t && !(t != null && t.relatedTarget) && Object.assign({}, t, o), (s = i.pointer) == null || s.onContainerMouseLeave(t || o) } i != null && i.mouseIsDown || (ct.hoverChartIndex = e.index) } touch(t, e) { var r; let i, { chart: s, pinchDown: o = [] } = this; this.setHoverChartIndex(), (t = this.normalize(t)).touches.length === 1 ? s.isInsidePlot(t.chartX - s.plotLeft, t.chartY - s.plotTop, { visiblePlotOnly: !0 }) && !((r = s.exporting) != null && r.openMenu) ? (e && this.runPointActions(t), t.type === "touchmove" && (i = !!o[0] && Math.pow(o[0].chartX - t.chartX, 2) + Math.pow(o[0].chartY - t.chartY, 2) >= 16), Ft(i, !0) && this.pinch(t)) : e && this.reset() : t.touches.length === 2 && this.pinch(t) } touchSelect(t) { return !!(this.chart.zooming.singleTouch && t.touches && t.touches.length === 1) } zoomOption(t) { let e = this.chart, i = e.inverted, s = e.zooming.type || "", o, r; /touch/.test(t.type) && (s = Ft(e.zooming.pinchType, s)), this.zoomX = o = /x/.test(s), this.zoomY = r = /y/.test(s), this.zoomHor = o && !i || r && i, this.zoomVert = r && !i || o && i, this.hasZoom = o || r } } ct.unbindDocumentMouseUp = [], function (h) { h.compose = function (t) { vp(mp, "Core.Pointer") && Lt(t, "beforeRender", function () { this.pointer = new h(this, this.options) }) } }(ct || (ct = {})); let xn = ct; (function (h) { h.setLength = function (t, e, i) { return Array.isArray(t) ? (t.length = e, t) : t[i ? "subarray" : "slice"](0, e) }, h.splice = function (t, e, i, s, o = []) { if (Array.isArray(t)) return Array.isArray(o) || (o = Array.from(o)), { removed: t.splice(e, i, ...o), array: t }; let r = Object.getPrototypeOf(t).constructor, a = t[s ? "subarray" : "slice"](e, e + i), n = new r(t.length - i + o.length); return n.set(t.subarray(0, e), 0), n.set(o, e), n.set(t.subarray(e + i), e + o.length), { removed: a, array: n } } })(eo || (eo = {})); let { setLength: wp, splice: bn } = eo, { fireEvent: ir, objectEach: vi, uniqueKey: wi } = I, xs = class { constructor(h = {}) { this.autoId = !h.id, this.columns = {}, this.id = h.id || wi(), this.modified = this, this.rowCount = 0, this.versionTag = wi(); let t = 0; vi(h.columns || {}, (e, i) => { this.columns[i] = e.slice(), t = Math.max(t, e.length) }), this.applyRowCount(t) } applyRowCount(h) { this.rowCount = h, vi(this.columns, (t, e) => { t.length !== h && (this.columns[e] = wp(t, h)) }) } deleteRows(h, t = 1) { if (t > 0 && h < this.rowCount) { let e = 0; vi(this.columns, (i, s) => { this.columns[s] = bn(i, h, t).array, e = i.length }), this.rowCount = e } ir(this, "afterDeleteRows", { rowIndex: h, rowCount: t }), this.versionTag = wi() } getColumn(h, t) { return this.columns[h] } getColumns(h, t) { return (h || Object.keys(this.columns)).reduce((e, i) => (e[i] = this.columns[i], e), {}) } getRow(h, t) { return (t || Object.keys(this.columns)).map(e => { var i; return (i = this.columns[e]) == null ? void 0 : i[h] }) } setColumn(h, t = [], e = 0, i) { this.setColumns({ [h]: t }, e, i) } setColumns(h, t, e) { let i = this.rowCount; vi(h, (s, o) => { this.columns[o] = s.slice(), i = s.length }), this.applyRowCount(i), e != null && e.silent || (ir(this, "afterSetColumns"), this.versionTag = wi()) } setRow(h, t = this.rowCount, e, i) { let { columns: s } = this, o = e ? this.rowCount + 1 : t + 1; vi(h, (r, a) => { let n = s[a] || (i == null ? void 0 : i.addColumns) !== !1 && Array(o); n && (e ? n = bn(n, t, 0, !0, [r]).array : n[t] = r, s[a] = n) }), o > this.rowCount && this.applyRowCount(o), i != null && i.silent || (ir(this, "afterSetRows"), this.versionTag = wi()) } }, { extend: Sp, merge: Mp, pick: vn } = I; (function (h) { function t(e, i, s) { var w, v; let o = this.legendItem = this.legendItem || {}, { chart: r, options: a } = this, { baseline: n = 0, symbolWidth: l, symbolHeight: c } = e, d = this.symbol || "circle", p = c / 2, u = r.renderer, g = o.group, m = n - Math.round((((w = e.fontMetrics) == null ? void 0 : w.b) || c) * (s ? .4 : .3)), f = {}, y, x = a.marker, b = 0; if (r.styledMode || (f["stroke-width"] = Math.min(a.lineWidth || 0, 24), a.dashStyle ? f.dashstyle = a.dashStyle : a.linecap !== "square" && (f["stroke-linecap"] = "round")), o.line = u.path().addClass("highcharts-graph").attr(f).add(g), s && (o.area = u.path().addClass("highcharts-area").add(g)), f["stroke-linecap"] && (b = Math.min(o.line.strokeWidth(), l) / 2), l) { let S = [["M", b, m], ["L", l - b, m]]; o.line.attr({ d: S }), (v = o.area) == null || v.attr({ d: [...S, ["L", l - b, n], ["L", b, n]] }) } if (x && x.enabled !== !1 && l) { let S = Math.min(vn(x.radius, p), p); d.indexOf("url") === 0 && (x = Mp(x, { width: c, height: c }), S = 0), o.symbol = y = u.symbol(d, l / 2 - S, m - S, 2 * S, 2 * S, Sp({ context: "legend" }, x)).addClass("highcharts-point").add(g), y.isMarker = !0 } } h.areaMarker = function (e, i) { t.call(this, e, i, !0) }, h.lineMarker = t, h.rectangle = function (e, i) { let s = i.legendItem || {}, o = e.options, r = e.symbolHeight, a = o.squareSymbol, n = a ? r : e.symbolWidth; s.symbol = this.chart.renderer.rect(a ? (e.symbolWidth - r) / 2 : 0, e.baseline - r + 1, n, r, vn(e.options.symbolRadius, r / 2)).addClass("highcharts-point").attr({ zIndex: 3 }).add(s.group) } })(io || (io = {})); let sr = io, { defaultOptions: wn } = wt, { extend: kp, extendClass: Ap, merge: Cp } = I; (function (h) { function t(e, i) { let s = wn.plotOptions || {}, o = i.defaultOptions, r = i.prototype; return r.type = e, r.pointClass || (r.pointClass = $t), !h.seriesTypes[e] && (o && (s[e] = o), h.seriesTypes[e] = i, !0) } h.seriesTypes = C.seriesTypes, h.registerSeriesType = t, h.seriesType = function (e, i, s, o, r) { let a = wn.plotOptions || {}; if (i = i || "", a[e] = Cp(a[i], s), delete h.seriesTypes[e], t(e, Ap(h.seriesTypes[i] || function () { }, o)), h.seriesTypes[e].prototype.type = e, r) { class n extends $t { } kp(n.prototype, r), h.seriesTypes[e].prototype.pointClass = n } return h.seriesTypes[e] } })(so || (so = {})); let G = so, { animObject: Sn, setAnimation: Tp } = mt, { defaultOptions: bs } = wt, { registerEventOptions: Pp } = os, { svg: Lp, win: Op } = C, { seriesTypes: He } = G, { format: Ep } = At, { arrayMax: or, arrayMin: Mn, clamp: kn, correctFloat: An, crisp: Ip, defined: ht, destroyObjectProperties: Dp, diffObjects: Bp, erase: Cn, error: vs, extend: Ge, find: zp, fireEvent: st, getClosestDistance: Np, getNestedProperty: Tn, insertItem: Pn, isArray: Ln, isNumber: pt, isString: Up, merge: Si, objectEach: rr, pick: ot, removeEvent: jp, syncTimeout: On } = I; class Bt { constructor() { this.zoneAxis = "y" } init(t, e) { var n, l, c; let i; st(this, "init", { options: e }), this.dataTable ?? (this.dataTable = new xs); let s = t.series; this.eventsToUnbind = [], this.chart = t, this.options = this.setOptions(e); let o = this.options, r = o.visible !== !1; this.linkedSeries = [], this.bindAxes(), Ge(this, { name: o.name, state: "", visible: r, selected: o.selected === !0 }), Pp(this, o); let a = o.events; (a != null && a.click || (l = (n = o.point) == null ? void 0 : n.events) != null && l.click || o.allowPointSelect) && (t.runTrackerClick = !0), this.getColor(), this.getSymbol(), this.isCartesian && (t.hasCartesianSeries = !0), s.length && (i = s[s.length - 1]), this._i = ot(i == null ? void 0 : i._i, -1) + 1, this.opacity = this.options.opacity, t.orderItems("series", Pn(this, s)), (c = o.dataSorting) != null && c.enabled ? this.setDataSortingOptions() : this.points || this.data || this.setData(o.data, !1), st(this, "afterInit") } is(t) { return He[t] && this instanceof He[t] } bindAxes() { let t, e = this, i = e.options, s = e.chart; st(this, "bindAxes", null, function () { (e.axisTypes || []).forEach(function (o) { (s[o] || []).forEach(function (r) { t = r.options, (ot(i[o], 0) === r.index || i[o] !== void 0 && i[o] === t.id) && (Pn(e, r.series), e[o] = r, r.isDirty = !0) }), e[o] || e.optionalAxis === o || vs(18, !0, s) }) }), st(this, "afterBindAxes") } hasData() { return this.visible && this.dataMax !== void 0 && this.dataMin !== void 0 || this.visible && this.dataTable.rowCount > 0 } hasMarkerChanged(t, e) { let i = t.marker, s = e.marker || {}; return i && (s.enabled && !i.enabled || s.symbol !== i.symbol || s.height !== i.height || s.width !== i.width) } autoIncrement(t) { let e, i = this.options, { pointIntervalUnit: s, relativeXValue: o } = this.options, r = this.chart.time, a = this.xIncrement ?? r.parse(i.pointStart) ?? 0; if (this.pointInterval = e = ot(this.pointInterval, i.pointInterval, 1), o && pt(t) && (e *= t), s) { let n = r.toParts(a); s === "day" ? n[2] += e : s === "month" ? n[1] += e : s === "year" && (n[0] += e), e = r.makeTime.apply(r, n) - a } return o && pt(t) ? a + e : (this.xIncrement = a + e, a) } setDataSortingOptions() { let t = this.options; Ge(this, { requireSorting: !1, sorted: !1, enabledDataSorting: !0, allowDG: !1 }), ht(t.pointRange) || (t.pointRange = 1) } setOptions(t) { var f, y; let e, i = this.chart, s = i.options.plotOptions, o = i.userOptions || {}, r = Si(t), a = i.styledMode, n = { plotOptions: s, userOptions: r }; st(this, "setOptions", n); let l = n.plotOptions[this.type], c = o.plotOptions || {}, d = c.series || {}, p = bs.plotOptions[this.type] || {}, u = c[this.type] || {}; l.dataLabels = this.mergeArrays(p.dataLabels, l.dataLabels), this.userOptions = n.userOptions; let g = Si(l, s.series, u, r); this.tooltipOptions = Si(bs.tooltip, (f = bs.plotOptions.series) == null ? void 0 : f.tooltip, p == null ? void 0 : p.tooltip, i.userOptions.tooltip, (y = c.series) == null ? void 0 : y.tooltip, u.tooltip, r.tooltip), this.stickyTracking = ot(r.stickyTracking, u.stickyTracking, d.stickyTracking, !!this.tooltipOptions.shared && !this.noSharedTooltip || g.stickyTracking), l.marker === null && delete g.marker, this.zoneAxis = g.zoneAxis || "y"; let m = this.zones = (g.zones || []).map(x => ({ ...x })); return (g.negativeColor || g.negativeFillColor) && !g.zones && (e = { value: g[this.zoneAxis + "Threshold"] || g.threshold || 0, className: "highcharts-negative" }, a || (e.color = g.negativeColor, e.fillColor = g.negativeFillColor), m.push(e)), m.length && ht(m[m.length - 1].value) && m.push(a ? {} : { color: this.color, fillColor: this.fillColor }), st(this, "afterSetOptions", { options: g }), g } getName() { return this.options.name ?? Ep(this.chart.options.lang.seriesName, this, this.chart) } getCyclic(t, e, i) { let s, o, r = this.chart, a = `${t}Index`, n = `${t}Counter`, l = (i == null ? void 0 : i.length) || r.options.chart.colorCount; !e && (ht(o = ot(t === "color" ? this.options.colorIndex : void 0, this[a])) ? s = o : (r.series.length || (r[n] = 0), s = r[n] % l, r[n] += 1), i && (e = i[s])), s !== void 0 && (this[a] = s), this[t] = e } getColor() { this.chart.styledMode ? this.getCyclic("color") : this.options.colorByPoint ? this.color = "#cccccc" : this.getCyclic("color", this.options.color || bs.plotOptions[this.type].color, this.chart.options.colors) } getPointsCollection() { return (this.hasGroupedData ? this.points : this.data) || [] } getSymbol() { let t = this.options.marker; this.getCyclic("symbol", t.symbol, this.chart.options.symbols) } getColumn(t, e) { return (e ? this.dataTable.modified : this.dataTable).getColumn(t, !0) || [] } findPointIndex(t, e) { var d; let i, s, o, { id: r, x: a } = t, n = this.points, l = this.options.dataSorting, c = this.cropStart || 0; if (r) { let p = this.chart.get(r); p instanceof $t && (i = p) } else if (this.linkedParent || this.enabledDataSorting || this.options.relativeXValue) { let p = u => !u.touched && u.index === t.index; if (l != null && l.matchByName ? p = u => !u.touched && u.name === t.name : this.options.relativeXValue && (p = u => !u.touched && u.options.x === t.x), !(i = zp(n, p))) return } return i && (o = i == null ? void 0 : i.index) !== void 0 && (s = !0), o === void 0 && pt(a) && (o = this.getColumn("x").indexOf(a, e)), o !== -1 && o !== void 0 && this.cropped && (o = o >= c ? o - c : o), !s && pt(o) && ((d = n[o]) != null && d.touched) && (o = void 0), o } updateData(t, e) { var m; let { options: i, requireSorting: s } = this, o = i.dataSorting, r = this.points, a = [], n = t.length === r.length, l, c, d, p, u = !0; if (this.xIncrement = null, t.forEach((f, y) => { var S; let x, b = ht(f) && this.pointClass.prototype.optionsToObject.call({ series: this }, f) || {}, { id: w, x: v } = b; w || pt(v) ? ((x = this.findPointIndex(b, p)) === -1 || x === void 0 ? a.push(f) : r[x] && f !== ((S = i.data) == null ? void 0 : S[x]) ? (r[x].update(f, !1, void 0, !1), r[x].touched = !0, s && (p = x + 1)) : r[x] && (r[x].touched = !0), (!n || y !== x || o != null && o.enabled || this.hasDerivedData) && (l = !0)) : a.push(f) }, this), l) for (c = r.length; c--;)(d = r[c]) && !d.touched && ((m = d.remove) == null || m.call(d, !1, e)); else n && !(o != null && o.enabled) ? (t.forEach((f, y) => { f === r[y].y || r[y].destroyed || r[y].update(f, !1, void 0, !1) }), a.length = 0) : u = !1; if (r.forEach(f => { f && (f.touched = !1) }), !u) return !1; a.forEach(f => { this.addPoint(f, !1, void 0, void 0, !1) }, this); let g = this.getColumn("x"); return this.xIncrement === null && g.length && (this.xIncrement = or(g), this.autoIncrement()), !0 } dataColumnKeys() { return ["x", ...this.pointArrayMap || ["y"]] } setData(t, e = !0, i, s) { var A, M; let o = this.points, r = (o == null ? void 0 : o.length) || 0, a = this.options, n = this.chart, l = a.dataSorting, c = this.xAxis, d = a.turboThreshold, p = this.dataTable, u = this.dataColumnKeys(), g = this.pointValKey || "y", m = (this.pointArrayMap || []).length, f = a.keys, y, x, b = 0, w = 1, v; n.options.chart.allowMutatingData || (a.data && delete this.options.data, this.userOptions.data && delete this.userOptions.data, v = Si(!0, t)); let S = (t = v || t || []).length; if (l != null && l.enabled && (t = this.sortData(t)), n.options.chart.allowMutatingData && s !== !1 && S && r && !this.cropped && !this.hasGroupedData && this.visible && !this.boosted && (x = this.updateData(t, i)), !x) { this.xIncrement = null, this.colorCounter = 0; let k = d && !a.relativeXValue && S > d; if (k) { let T = this.getFirstValidPoint(t), P = this.getFirstValidPoint(t, S - 1, -1), L = O => !!(Ln(O) && (f || pt(O[0]))); if (pt(T) && pt(P)) { let O = [], B = []; for (let D of t) O.push(this.autoIncrement()), B.push(D); p.setColumns({ x: O, [g]: B }) } else if (L(T) && L(P)) if (m) { let O = +(T.length === m), B = Array(u.length).fill(0).map(() => []); for (let D of t) { O && B[0].push(this.autoIncrement()); for (let z = O; z <= m; z++)(A = B[z]) == null || A.push(D[z - O]) } p.setColumns(u.reduce((D, z, E) => (D[z] = B[E], D), {})) } else { f && (b = f.indexOf("x"), w = f.indexOf("y"), b = b >= 0 ? b : 0, w = w >= 0 ? w : 1), T.length === 1 && (w = 0); let O = [], B = []; if (b === w) for (let D of t) O.push(this.autoIncrement()), B.push(D[w]); else for (let D of t) O.push(D[b]), B.push(D[w]); p.setColumns({ x: O, [g]: B }) } else k = !1 } if (!k) { let T = u.reduce((P, L) => (P[L] = [], P), {}); for (y = 0; y < S; y++) { let P = this.pointClass.prototype.applyOptions.apply({ series: this }, [t[y]]); for (let L of u) T[L][y] = P[L] } p.setColumns(T) } for (Up(this.getColumn("y")[0]) && vs(14, !0, n), this.data = [], this.options.data = this.userOptions.data = t, y = r; y--;)(M = o[y]) == null || M.destroy(); c && (c.minRange = c.userMinRange), this.isDirty = n.isDirtyBox = !0, this.isDirtyData = !!o, i = !1 } a.legendType === "point" && (this.processData(), this.generatePoints()), e && n.redraw(i) } sortData(t) { let e = this, i = e.options.dataSorting.sortKey || "y", s = function (o, r) { return ht(r) && o.pointClass.prototype.optionsToObject.call({ series: o }, r) || {} }; return t.forEach(function (o, r) { t[r] = s(e, o), t[r].index = r }, this), t.concat().sort((o, r) => { let a = Tn(i, o), n = Tn(i, r); return n < a ? -1 : +(n > a) }).forEach(function (o, r) { o.x = r }, this), e.linkedSeries && e.linkedSeries.forEach(function (o) { var n; let r = o.options, a = r.data; !((n = r.dataSorting) != null && n.enabled) && a && (a.forEach(function (l, c) { a[c] = s(o, l), t[c] && (a[c].x = t[c].x, a[c].index = c) }), o.setData(a, !1)) }), t } getProcessedData(t) { let e = this, { dataTable: i, isCartesian: s, options: o, xAxis: r } = e, a = o.cropThreshold, n = t || e.getExtremesFromAll, l = r == null ? void 0 : r.logarithmic, c = i.rowCount, d, p, u = 0, g, m, f, y = e.getColumn("x"), x = i, b = !1; return r && (m = (g = r.getExtremes()).min, f = g.max, b = !!(r.categories && !r.names.length), s && e.sorted && !n && (!a || c > a || e.forceCrop) && (y[c - 1] < m || y[0] > f ? x = new xs : e.getColumn(e.pointValKey || "y").length && (y[0] < m || y[c - 1] > f) && (x = (d = this.cropData(i, m, f)).modified, u = d.start, p = !0))), y = x.getColumn("x") || [], { modified: x, cropped: p, cropStart: u, closestPointRange: Np([l ? y.map(l.log2lin) : y], () => e.requireSorting && !b && vs(15, !1, e.chart)) } } processData(t) { let e = this.xAxis, i = this.dataTable; if (this.isCartesian && !this.isDirty && !e.isDirty && !this.yAxis.isDirty && !t) return !1; let s = this.getProcessedData(); i.modified = s.modified, this.cropped = s.cropped, this.cropStart = s.cropStart, this.closestPointRange = this.basePointRange = s.closestPointRange, st(this, "afterProcessData") } cropData(t, e, i) { let s = t.getColumn("x", !0) || [], o = s.length, r = {}, a, n, l = 0, c = o; for (a = 0; a < o; a++)if (s[a] >= e) { l = Math.max(0, a - 1); break } for (n = a; n < o; n++)if (s[n] > i) { c = n + 1; break } for (let d of this.dataColumnKeys()) { let p = t.getColumn(d, !0); p && (r[d] = p.slice(l, c)) } return { modified: new xs({ columns: r }), start: l, end: c } } generatePoints() { var v, S, A; let t = this.options, e = this.processedData || t.data, i = this.dataTable.modified, s = this.getColumn("x", !0), o = this.pointClass, r = i.rowCount, a = this.cropStart || 0, n = this.hasGroupedData, l = t.keys, c = [], d = (v = t.dataGrouping) != null && v.groupAll ? a : 0, p = (S = this.xAxis) == null ? void 0 : S.categories, u = this.pointArrayMap || ["y"], g = this.dataColumnKeys(), m, f, y, x, b = this.data, w; if (!b && !n) { let M = []; M.length = (e == null ? void 0 : e.length) || 0, b = this.data = M } for (l && n && (this.options.keys = !1), x = 0; x < r; x++)f = a + x, n ? ((y = new o(this, i.getRow(x, g) || [])).dataGroup = this.groupMap[d + x], (A = y.dataGroup) != null && A.options && (y.options = y.dataGroup.options, Ge(y, y.dataGroup.options), delete y.dataLabels)) : (y = b[f], w = e ? e[f] : i.getRow(x, u), y || w === void 0 || (b[f] = y = new o(this, w, s[x]))), y && (y.index = n ? d + x : f, c[x] = y, y.category = (p == null ? void 0 : p[y.x]) ?? y.x, y.key = y.name ?? y.category); if (this.options.keys = l, b && (r !== (m = b.length) || n)) for (x = 0; x < m; x++)x !== a || n || (x += r), b[x] && (b[x].destroyElements(), b[x].plotX = void 0); this.data = b, this.points = c, st(this, "afterGeneratePoints") } getXExtremes(t) { return { min: Mn(t), max: or(t) } } getExtremes(t, e) { var v; let { xAxis: i, yAxis: s } = this, o = e || this.getExtremesFromAll || this.options.getExtremesFromAll, r = o && this.cropped ? this.dataTable : this.dataTable.modified, a = r.rowCount, n = t || this.stackedYData, l = n ? [n] : ((v = this.keysAffectYAxis || this.pointArrayMap || ["y"]) == null ? void 0 : v.map(S => r.getColumn(S, !0) || [])) || [], c = this.getColumn("x", !0), d = [], p = this.requireSorting && !this.is("column") ? 1 : 0, u = !!s && s.positiveValuesOnly, g = o || this.cropped || !i, m, f, y, x = 0, b = 0; for (i && (x = (m = i.getExtremes()).min, b = m.max), y = 0; y < a; y++)if (f = c[y], g || (c[y + p] || f) >= x && (c[y - p] || f) <= b) for (let S of l) { let A = S[y]; pt(A) && (A > 0 || !u) && d.push(A) } let w = { activeYData: d, dataMin: Mn(d), dataMax: or(d) }; return st(this, "afterGetExtremes", { dataExtremes: w }), w } applyExtremes() { let t = this.getExtremes(); return this.dataMin = t.dataMin, this.dataMax = t.dataMax, t } getFirstValidPoint(t, e = 0, i = 1) { let s = t.length, o = e; for (; o >= 0 && o < s;) { if (ht(t[o])) return t[o]; o += i } } translate() { var b; this.generatePoints(); let t = this.options, e = t.stacking, i = this.xAxis, s = this.enabledDataSorting, o = this.yAxis, r = this.points, a = r.length, n = this.pointPlacementToXValue(), l = !!n, c = t.threshold, d = t.startFromThreshold ? c : 0, p = (t == null ? void 0 : t.nullInteraction) && o.len, u, g, m, f, y = Number.MAX_VALUE; function x(w) { return kn(w, -1e9, 1e9) } for (u = 0; u < a; u++) { let w, v = r[u], S = v.x, A, M, k = v.y, T = v.low, P = e && ((b = o.stacking) == null ? void 0 : b.stacks[(this.negStacks && k < (d ? 0 : c) ? "-" : "") + this.stackKey]); v.plotX = pt(g = i.translate(S, !1, !1, !1, !0, n)) ? An(x(g)) : void 0, e && this.visible && P && P[S] && (f = this.getStackIndicator(f, S, this.index), !v.isNull && f.key && (M = (A = P[S]).points[f.key]), A && Ln(M) && (T = M[0], k = M[1], T === d && f.key === P[S].base && (T = ot(pt(c) ? c : o.min)), o.positiveValuesOnly && ht(T) && T <= 0 && (T = void 0), v.total = v.stackTotal = ot(A.total), v.percentage = ht(v.y) && A.total ? v.y / A.total * 100 : void 0, v.stackY = k, this.irregularWidths || A.setOffset(this.pointXOffset || 0, this.barW || 0, void 0, void 0, void 0, this.xAxis))), v.yBottom = ht(T) ? x(o.translate(T, !1, !0, !1, !0)) : void 0, this.dataModify && (k = this.dataModify.modifyValue(k, u)), pt(k) && v.plotX !== void 0 ? w = pt(w = o.translate(k, !1, !0, !1, !0)) ? x(w) : void 0 : !pt(k) && p && (w = p), v.plotY = w, v.isInside = this.isPointInside(v), v.clientX = l ? An(i.translate(S, !1, !1, !1, !0, n)) : g, v.negative = (v.y || 0) < (c || 0), v.isNull || v.visible === !1 || (m !== void 0 && (y = Math.min(y, Math.abs(g - m))), m = g), v.zone = this.zones.length ? v.getZone() : void 0, !v.graphic && this.group && s && (v.isNew = !0) } this.closestPointRangePx = y, st(this, "afterTranslate") } getValidPoints(t, e, i) { let s = this.chart; return (t || this.points || []).filter(function (o) { let { plotX: r, plotY: a } = o; return (!!i || !o.isNull && !!pt(a)) && (!e || !!s.isInsidePlot(r, a, { inverted: s.inverted })) && o.visible !== !1 }) } getSharedClipKey() { return this.sharedClipKey = (this.options.xAxis || 0) + "," + (this.options.yAxis || 0), this.sharedClipKey } setClip() { let { chart: t, group: e, markerGroup: i } = this, s = t.sharedClips, o = t.renderer, r = t.getClipBox(this), a = this.getSharedClipKey(), n = s[a]; n ? n.animate(r) : s[a] = n = o.clipRect(r), e && e.clip(this.options.clip === !1 ? void 0 : n), i && i.clip() } animate(t) { let { chart: e, group: i, markerGroup: s } = this, o = e.inverted, r = Sn(this.options.animation), a = [this.getSharedClipKey(), r.duration, r.easing, r.defer].join(","), n = e.sharedClips[a], l = e.sharedClips[a + "m"]; if (t && i) { let c = e.getClipBox(this); if (n) n.attr("height", c.height); else { c.width = 0, o && (c.x = e.plotHeight), n = e.renderer.clipRect(c), e.sharedClips[a] = n; let d = { x: -99, y: -99, width: o ? e.plotWidth + 199 : 99, height: o ? 99 : e.plotHeight + 199 }; l = e.renderer.clipRect(d), e.sharedClips[a + "m"] = l } i.clip(n), s == null || s.clip(l) } else if (n && !n.hasClass("highcharts-animating")) { let c = e.getClipBox(this), d = r.step; (s != null && s.element.childNodes.length || e.series.length > 1) && (r.step = function (p, u) { d && d.apply(u, arguments), u.prop === "width" && (l != null && l.element) && l.attr(o ? "height" : "width", p + 99) }), n.addClass("highcharts-animating").animate(c, r) } } afterAnimate() { this.setClip(), rr(this.chart.sharedClips, (t, e, i) => { t && !this.chart.container.querySelector(`[clip-path="url(#${t.id})"]`) && (t.destroy(), delete i[e]) }), this.finishedAnimating = !0, st(this, "afterAnimate") } drawPoints(t = this.points) { let e, i, s, o, r, a, n, l = this.chart, c = l.styledMode, { colorAxis: d, options: p } = this, u = p.marker, g = p.nullInteraction, m = this[this.specialGroup || "markerGroup"], f = this.xAxis, y = ot(u.enabled, !f || !!f.isRadial || null, this.closestPointRangePx >= u.enabledThreshold * u.radius); if (u.enabled !== !1 || this._hasPointMarkers) for (e = 0; e < t.length; e++) { o = (s = (i = t[e]).graphic) ? "animate" : "attr", r = i.marker || {}, a = !!i.marker; let x = i.isNull; if ((y && !ht(r.enabled) || r.enabled) && (!x || g) && i.visible !== !1) { let b = ot(r.symbol, this.symbol, "rect"); n = this.markerAttribs(i, i.selected && "select"), this.enabledDataSorting && (i.startXPos = f.reversed ? -(n.width || 0) : f.width); let w = i.isInside !== !1; if (!s && w && ((n.width || 0) > 0 || i.hasImage) && (i.graphic = s = l.renderer.symbol(b, n.x, n.y, n.width, n.height, a ? r : u).add(m), this.enabledDataSorting && l.hasRendered && (s.attr({ x: i.startXPos }), o = "animate")), s && o === "animate" && s[w ? "show" : "hide"](w).animate(n), s) { let v = this.pointAttribs(i, c || !i.selected ? void 0 : "select"); c ? d && s.css({ fill: v.fill }) : s[o](v) } s && s.addClass(i.getClassName(), !0) } else s && (i.graphic = s.destroy()) } } markerAttribs(t, e) { let i = this.options, s = i.marker, o = t.marker || {}, r = o.symbol || s.symbol, a = {}, n, l, c = ot(o.radius, s == null ? void 0 : s.radius); e && (n = s.states[e], l = o.states && o.states[e], c = ot(l == null ? void 0 : l.radius, n == null ? void 0 : n.radius, c && c + ((n == null ? void 0 : n.radiusPlus) || 0))), t.hasImage = r && r.indexOf("url") === 0, t.hasImage && (c = 0); let d = t.pos(); return pt(c) && d && (i.crisp && (d[0] = Ip(d[0], t.hasImage ? 0 : r === "rect" ? (s == null ? void 0 : s.lineWidth) || 0 : 1)), a.x = d[0] - c, a.y = d[1] - c), c && (a.width = a.height = 2 * c), a } pointAttribs(t, e) { var y; let i = this.options, s = i.marker, o = t == null ? void 0 : t.options, r = (o == null ? void 0 : o.marker) || {}, a = o == null ? void 0 : o.color, n = t == null ? void 0 : t.color, l = (y = t == null ? void 0 : t.zone) == null ? void 0 : y.color, c, d, p = this.color, u, g, m = ot(r.lineWidth, s.lineWidth), f = t != null && t.isNull && i.nullInteraction ? 0 : 1; return p = a || l || n || p, u = r.fillColor || s.fillColor || p, g = r.lineColor || s.lineColor || p, e = e || "normal", c = s.states[e] || {}, m = ot((d = r.states && r.states[e] || {}).lineWidth, c.lineWidth, m + ot(d.lineWidthPlus, c.lineWidthPlus, 0)), u = d.fillColor || c.fillColor || u, g = d.lineColor || c.lineColor || g, { stroke: g, "stroke-width": m, fill: u, opacity: f = ot(d.opacity, c.opacity, f) } } destroy(t) { var n, l; let e, i, s = this, o = s.chart, r = /AppleWebKit\/533/.test(Op.navigator.userAgent), a = s.data || []; for (st(s, "destroy", { keepEventsForUpdate: t }), this.removeEvents(t), (s.axisTypes || []).forEach(function (c) { i = s[c], i != null && i.series && (Cn(i.series, s), i.isDirty = i.forceRedraw = !0) }), s.legendItem && s.chart.legend.destroyItem(s), e = a.length; e--;)(l = (n = a[e]) == null ? void 0 : n.destroy) == null || l.call(n); for (let c of s.zones) Dp(c, void 0, !0); I.clearTimeout(s.animationTimeout), rr(s, function (c, d) { c instanceof Dt && !c.survive && c[r && d === "group" ? "hide" : "destroy"]() }), o.hoverSeries === s && (o.hoverSeries = void 0), Cn(o.series, s), o.orderItems("series"), rr(s, function (c, d) { t && d === "hcEvents" || delete s[d] }) } applyZones() { let { area: t, chart: e, graph: i, zones: s, points: o, xAxis: r, yAxis: a, zoneAxis: n } = this, { inverted: l, renderer: c } = e, d = this[`${n}Axis`], { isXAxis: p, len: u = 0, minPointOffset: g = 0 } = d || {}, m = ((i == null ? void 0 : i.strokeWidth()) || 0) / 2 + 1, f = (y, x = 0, b = 0) => { l && (b = u - b); let { translated: w = 0, lineClip: v } = y, S = b - w; v == null || v.push(["L", x, Math.abs(S) < m ? b - m * (S <= 0 ? -1 : 1) : w]) }; if (s.length && (i || t) && d && pt(d.min)) { let y = d.getExtremes().max + g, x = v => { v.forEach((S, A) => { (S[0] === "M" || S[0] === "L") && (v[A] = [S[0], p ? u - S[1] : S[1], p ? S[2] : u - S[2]]) }) }; if (s.forEach(v => { v.lineClip = [], v.translated = kn(d.toPixels(ot(v.value, y), !0) || 0, 0, u) }), i && !this.showLine && i.hide(), t && t.hide(), n === "y" && o.length < r.len) for (let v of o) { let { plotX: S, plotY: A, zone: M } = v, k = M && s[s.indexOf(M) - 1]; M && f(M, S, A), k && f(k, S, A) } let b = [], w = d.toPixels(d.getExtremes().min - g, !0); s.forEach(v => { var z, E; let S = v.lineClip || [], A = Math.round(v.translated || 0); r.reversed && S.reverse(); let { clip: M, simpleClip: k } = v, T = 0, P = 0, L = r.len, O = a.len; p ? (T = A, L = w) : (P = A, O = w); let B = [["M", T, P], ["L", L, P], ["L", L, O], ["L", T, O], ["Z"]], D = [B[0], ...S, B[1], B[2], ...b, B[3], B[4]]; b = S.reverse(), w = A, l && (x(D), t && x(B)), M ? (M.animate({ d: D }), k == null || k.animate({ d: B })) : (M = v.clip = c.path(D), t && (k = v.simpleClip = c.path(B))), i && ((z = v.graph) == null || z.clip(M)), t && ((E = v.area) == null || E.clip(k)) }) } else this.visible && (i && i.show(), t && t.show()) } plotGroup(t, e, i, s, o) { let r = this[t], a = !r, n = { visibility: i, zIndex: s || .1 }; return ht(this.opacity) && !this.chart.styledMode && this.state !== "inactive" && (n.opacity = this.opacity), r || (this[t] = r = this.chart.renderer.g().add(o)), r.addClass("highcharts-" + e + " highcharts-series-" + this.index + " highcharts-" + this.type + "-series " + (ht(this.colorIndex) ? "highcharts-color-" + this.colorIndex + " " : "") + (this.options.className || "") + (r.hasClass("highcharts-tracker") ? " highcharts-tracker" : ""), !0), r.attr(n)[a ? "attr" : "animate"](this.getPlotBox(e)), r } getPlotBox(t) { let e = this.xAxis, i = this.yAxis, s = this.chart, o = s.inverted && !s.polar && e && this.invertible && t === "series"; s.inverted && (e = i, i = this.xAxis); let r = { scale: 1, translateX: e ? e.left : s.plotLeft, translateY: i ? i.top : s.plotTop, name: t }; st(this, "getPlotBox", r); let { scale: a, translateX: n, translateY: l } = r; return { translateX: n, translateY: l, rotation: 90 * !!o, rotationOriginX: o ? a * (e.len - i.len) / 2 : 0, rotationOriginY: o ? a * (e.len + i.len) / 2 : 0, scaleX: o ? -a : a, scaleY: a } } removeEvents(t) { let { eventsToUnbind: e } = this; t || jp(this), e.length && (e.forEach(i => { i() }), e.length = 0) } render() { var c, d, p, u, g; let t = this, { chart: e, options: i, hasRendered: s } = t, o = Sn(i.animation), r = t.visible ? "inherit" : "hidden", a = i.zIndex, n = e.seriesGroup, l = t.finishedAnimating ? 0 : o.duration; st(this, "render"), t.plotGroup("group", "series", r, a, n), t.markerGroup = t.plotGroup("markerGroup", "markers", r, a, n), i.clip !== !1 && t.setClip(), l && ((c = t.animate) == null || c.call(t, !0)), t.drawGraph && (t.drawGraph(), t.applyZones()), t.visible && t.drawPoints(), (d = t.drawDataLabels) == null || d.call(t), (p = t.redrawPoints) == null || p.call(t), i.enableMouseTracking && ((u = t.drawTracker) == null || u.call(t)), l && ((g = t.animate) == null || g.call(t)), s || (l && o.defer && (l += o.defer), t.animationTimeout = On(() => { t.afterAnimate() }, l || 0)), t.isDirty = !1, t.hasRendered = !0, st(t, "afterRender") } redraw() { let t = this.isDirty || this.isDirtyData; this.translate(), this.render(), t && delete this.kdTree } reserveSpace() { return this.visible || !this.chart.options.chart.ignoreHiddenSeries } searchPoint(t, e) { let { xAxis: i, yAxis: s } = this, o = this.chart.inverted; return this.searchKDTree({ clientX: o ? i.len - t.chartY + i.pos : t.chartX - i.pos, plotY: o ? s.len - t.chartX + s.pos : t.chartY - s.pos }, e, t) } buildKDTree(t) { this.buildingKdTree = !0; let e = this, i = e.options, s = i.findNearestPointBy.indexOf("y") > -1 ? 2 : 1; delete e.kdTree, On(function () { e.kdTree = function o(r, a, n) { let l, c, d = r == null ? void 0 : r.length; if (d) return l = e.kdAxisArray[a % n], r.sort((p, u) => (p[l] || 0) - (u[l] || 0)), { point: r[c = Math.floor(d / 2)], left: o(r.slice(0, c), a + 1, n), right: o(r.slice(c + 1), a + 1, n) } }(e.getValidPoints(void 0, !e.directTouch, i == null ? void 0 : i.nullInteraction), s, s), e.buildingKdTree = !1 }, i.kdNow || (t == null ? void 0 : t.type) === "touchstart" ? 0 : 1) } searchKDTree(t, e, i, s, o) { let r = this, [a, n] = this.kdAxisArray, l = e ? "distX" : "dist", c = (r.options.findNearestPointBy || "").indexOf("y") > -1 ? 2 : 1, d = !!r.isBubble, p = s || ((g, m, f) => { let y = g[f] || 0, x = m[f] || 0; return [y === x && g.index > m.index || y < x ? g : m, !1] }), u = o || ((g, m) => g < m); if (this.kdTree || this.buildingKdTree || this.buildKDTree(i), this.kdTree) return function g(m, f, y, x) { var T; let b = f.point, w = r.kdAxisArray[y % x], v = b, S = !1; (function (P, L) { var W; let O = P[a], B = L[a], D = ht(O) && ht(B) ? O - B : null, z = P[n], E = L[n], N = ht(z) && ht(E) ? z - E : 0, V = d && ((W = L.marker) == null ? void 0 : W.radius) || 0; L.dist = Math.sqrt((D && D * D || 0) + N * N) - V, L.distX = ht(D) ? Math.abs(D) - V : Number.MAX_VALUE })(m, b); let A = (m[w] || 0) - (b[w] || 0) + (d && ((T = b.marker) == null ? void 0 : T.radius) || 0), M = A < 0 ? "left" : "right", k = A < 0 ? "right" : "left"; return f[M] && ([v, S] = p(b, g(m, f[M], y + 1, x), l)), f[k] && u(Math.sqrt(A * A), v[l], S) && (v = p(v, g(m, f[k], y + 1, x), l)[0]), v }(t, this.kdTree, c, c) } pointPlacementToXValue() { let { options: t, xAxis: e } = this, i = t.pointPlacement; return i === "between" && (i = e.reversed ? -.5 : .5), pt(i) ? i * (t.pointRange || e.pointRange) : 0 } isPointInside(t) { let { chart: e, xAxis: i, yAxis: s } = this, { plotX: o = -1, plotY: r = -1 } = t; return r >= 0 && r <= (s ? s.len : e.plotHeight) && o >= 0 && o <= (i ? i.len : e.plotWidth) } drawTracker() { var p; let t = this, e = t.options, i = e.trackByArea, s = [].concat((i ? t.areaPath : t.graphPath) || []), o = t.chart, r = o.pointer, a = o.renderer, n = ((p = o.options.tooltip) == null ? void 0 : p.snap) || 0, l = () => { e.enableMouseTracking && o.hoverSeries !== t && t.onMouseOver() }, c = "rgba(192,192,192," + (Lp ? 1e-4 : .002) + ")", d = t.tracker; d ? d.attr({ d: s }) : t.graph && (t.tracker = d = a.path(s).attr({ visibility: t.visible ? "inherit" : "hidden", zIndex: 2 }).addClass(i ? "highcharts-tracker-area" : "highcharts-tracker-line").add(t.group), o.styledMode || d.attr({ "stroke-linecap": "round", "stroke-linejoin": "round", stroke: c, fill: i ? c : "none", "stroke-width": t.graph.strokeWidth() + (i ? 0 : 2 * n) }), [t.tracker, t.markerGroup, t.dataLabelsGroup].forEach(u => { u && (u.addClass("highcharts-tracker").on("mouseover", l).on("mouseout", g => { r == null || r.onTrackerMouseOut(g) }), e.cursor && !o.styledMode && u.css({ cursor: e.cursor }), u.on("touchstart", l)) })), st(this, "afterDrawTracker") } addPoint(t, e, i, s, o) { let r, a, n = this.options, { chart: l, data: c, dataTable: d, xAxis: p } = this, u = (p == null ? void 0 : p.hasNames) && p.names, g = n.data, m = this.getColumn("x"); e = ot(e, !0); let f = { series: this }; this.pointClass.prototype.applyOptions.apply(f, [t]); let y = f.x; if (a = m.length, this.requireSorting && y < m[a - 1]) for (r = !0; a && m[a - 1] > y;)a--; d.setRow(f, a, !0, { addColumns: !1 }), u && f.name && (u[y] = f.name), g == null || g.splice(a, 0, t), (r || this.processedData) && (this.data.splice(a, 0, null), this.processData()), n.legendType === "point" && this.generatePoints(), i && (c[0] && c[0].remove ? c[0].remove(!1) : ([c, g].filter(ht).forEach(x => { x.shift() }), d.deleteRows(0))), o !== !1 && st(this, "addPoint", { point: f }), this.isDirty = !0, this.isDirtyData = !0, e && l.redraw(s) } removePoint(t, e, i) { let s = this, { chart: o, data: r, points: a, dataTable: n } = s, l = r[t], c = function () { [(a == null ? void 0 : a.length) === r.length ? a : void 0, r, s.options.data].filter(ht).forEach(d => { d.splice(t, 1) }), n.deleteRows(t), l == null || l.destroy(), s.isDirty = !0, s.isDirtyData = !0, e && o.redraw() }; Tp(i, o), e = ot(e, !0), l ? l.firePointEvent("remove", null, c) : c() } remove(t, e, i, s) { let o = this, r = o.chart; function a() { o.destroy(s), r.isDirtyLegend = r.isDirtyBox = !0, r.linkSeries(s), ot(t, !0) && r.redraw(e) } i !== !1 ? st(o, "remove", null, a) : a() } update(t, e) { var y, x; st(this, "update", { options: t = Bp(t, this.userOptions) }); let i = this, s = i.chart, o = i.userOptions, r = i.initialType || i.type, a = s.options.plotOptions, n = He[r].prototype, l = i.finishedAnimating && { animation: !1 }, c = {}, d, p, u = Bt.keepProps.slice(), g = t.type || o.type || s.options.chart.type, m = !(this.hasDerivedData || g && g !== this.type || t.keys !== void 0 || t.pointStart !== void 0 || t.pointInterval !== void 0 || t.relativeXValue !== void 0 || t.joinBy || t.mapData || ["dataGrouping", "pointStart", "pointInterval", "pointIntervalUnit", "keys"].some(b => i.hasOptionChanged(b))); g = g || r, m ? (u.push.apply(u, Bt.keepPropsForPoints), t.visible !== !1 && u.push("area", "graph"), i.parallelArrays.forEach(function (b) { u.push(b + "Data") }), t.data && (t.dataSorting && Ge(i.options.dataSorting, t.dataSorting), this.setData(t.data, !1))) : this.dataTable.modified = this.dataTable, t = Si(o, { index: o.index === void 0 ? i.index : o.index, pointStart: ((y = a == null ? void 0 : a.series) == null ? void 0 : y.pointStart) ?? o.pointStart ?? i.getColumn("x")[0] }, !m && { data: i.options.data }, t, l), m && t.data && (t.data = i.options.data), (u = ["group", "markerGroup", "dataLabelsGroup", "transformGroup"].concat(u)).forEach(function (b) { u[b] = i[b], delete i[b] }); let f = !1; if (He[g]) { if (f = g !== i.type, i.remove(!1, !1, !1, !0), f) if (s.propFromSeries(), Object.setPrototypeOf) Object.setPrototypeOf(i, He[g].prototype); else { let b = Object.hasOwnProperty.call(i, "hcEvents") && i.hcEvents; for (p in n) i[p] = void 0; Ge(i, He[g].prototype), b ? i.hcEvents = b : delete i.hcEvents } } else vs(17, !0, s, { missingModuleFor: g }); if (u.forEach(function (b) { i[b] = u[b] }), i.init(s, t), m && this.points) for (let b of ((d = i.options).visible === !1 ? (c.graphic = 1, c.dataLabel = 1) : (this.hasMarkerChanged(d, o) && (c.graphic = 1), (x = i.hasDataLabels) != null && x.call(i) || (c.dataLabel = 1)), this.points)) b != null && b.series && (b.resolveColor(), Object.keys(c).length && b.destroyElements(c), d.showInLegend === !1 && b.legendItem && s.legend.destroyItem(b)); i.initialType = r, s.linkSeries(), s.setSortedData(), f && i.linkedSeries.length && (i.isDirtyData = !0), st(this, "afterUpdate"), ot(e, !0) && s.redraw(!!m && void 0) } setName(t) { this.name = this.options.name = this.userOptions.name = t, this.chart.isDirtyLegend = !0 } hasOptionChanged(t) { var a, n; let e = this.chart, i = this.options[t], s = e.options.plotOptions, o = this.userOptions[t], r = ot((a = s == null ? void 0 : s[this.type]) == null ? void 0 : a[t], (n = s == null ? void 0 : s.series) == null ? void 0 : n[t]); return o && !ht(r) ? i !== o : i !== ot(r, i) } onMouseOver() { let t = this.chart, e = t.hoverSeries, i = t.pointer; i == null || i.setHoverChartIndex(), e && e !== this && e.onMouseOut(), this.options.events.mouseOver && st(this, "mouseOver"), this.setState("hover"), t.hoverSeries = this } onMouseOut() { let t = this.options, e = this.chart, i = e.tooltip, s = e.hoverPoint; e.hoverSeries = null, s && s.onMouseOut(), this && t.events.mouseOut && st(this, "mouseOut"), i && !this.stickyTracking && (!i.shared || this.noSharedTooltip) && i.hide(), e.series.forEach(function (o) { o.setState("", !0) }) } setState(t, e) { let i = this, s = i.options, o = i.graph, r = s.inactiveOtherPoints, a = s.states, n = ot(a[t || "normal"] && a[t || "normal"].animation, i.chart.options.chart.animation), l = s.lineWidth, c = s.opacity; if (t = t || "", i.state !== t && ([i.group, i.markerGroup, i.dataLabelsGroup].forEach(function (d) { d && (i.state && d.removeClass("highcharts-series-" + i.state), t && d.addClass("highcharts-series-" + t)) }), i.state = t, !i.chart.styledMode)) { if (a[t] && a[t].enabled === !1) return; if (t && (l = a[t].lineWidth || l + (a[t].lineWidthPlus || 0), c = ot(a[t].opacity, c)), o && !o.dashstyle && pt(l)) for (let d of [o, ...this.zones.map(p => p.graph)]) d == null || d.animate({ "stroke-width": l }, n); r || [i.group, i.markerGroup, i.dataLabelsGroup, i.labelBySeries].forEach(function (d) { d && d.animate({ opacity: c }, n) }) } e && r && i.points && i.setAllPointsToState(t || void 0) } setAllPointsToState(t) { this.points.forEach(function (e) { e.setState && e.setState(t) }) } setVisible(t, e) { var n; let i = this, s = i.chart, o = s.options.chart.ignoreHiddenSeries, r = i.visible; i.visible = t = i.options.visible = i.userOptions.visible = t === void 0 ? !r : t; let a = t ? "show" : "hide";["group", "dataLabelsGroup", "markerGroup", "tracker", "tt"].forEach(l => { var c; (c = i[l]) == null || c[a]() }), (s.hoverSeries === i || ((n = s.hoverPoint) == null ? void 0 : n.series) === i) && i.onMouseOut(), i.legendItem && s.legend.colorizeItem(i, t), i.isDirty = !0, i.options.stacking && s.series.forEach(l => { l.options.stacking && l.visible && (l.isDirty = !0) }), i.linkedSeries.forEach(l => { l.setVisible(t, !1) }), o && (s.isDirtyBox = !0), st(i, a), e !== !1 && s.redraw() } show() { this.setVisible(!0) } hide() { this.setVisible(!1) } select(t) { this.selected = t = this.options.selected = t === void 0 ? !this.selected : t, this.checkbox && (this.checkbox.checked = t), st(this, t ? "select" : "unselect") } shouldShowTooltip(t, e, i = {}) { return i.series = this, i.visiblePlotOnly = !0, this.chart.isInsidePlot(t, e, i) } drawLegendSymbol(t, e) { var i; (i = sr[this.options.legendSymbol || "rectangle"]) == null || i.call(this, t, e) } } Bt.defaultOptions = { lineWidth: 2, allowPointSelect: !1, crisp: !0, showCheckbox: !1, animation: { duration: 1e3 }, enableMouseTracking: !0, events: {}, marker: { enabledThreshold: 2, lineColor: "#ffffff", lineWidth: 0, radius: 4, states: { normal: { animation: !0 }, hover: { animation: { duration: 150 }, enabled: !0, radiusPlus: 2, lineWidthPlus: 1 }, select: { fillColor: "#cccccc", lineColor: "#000000", lineWidth: 2 } } }, point: { events: {} }, dataLabels: { animation: {}, align: "center", borderWidth: 0, defer: !0, formatter: function () { let { numberFormatter: h } = this.series.chart; return typeof this.y != "number" ? "" : h(this.y, -1) }, padding: 5, style: { fontSize: "0.7em", fontWeight: "bold", color: "contrast", textOutline: "1px contrast" }, verticalAlign: "bottom", x: 0, y: 0 }, cropThreshold: 300, opacity: 1, pointRange: 0, softThreshold: !0, states: { normal: { animation: !0 }, hover: { animation: { duration: 150 }, lineWidthPlus: 1, marker: {}, halo: { size: 10, opacity: .25 } }, select: { animation: { duration: 0 } }, inactive: { animation: { duration: 150 }, opacity: .2 } }, stickyTracking: !0, turboThreshold: 1e3, findNearestPointBy: "x" }, Bt.types = G.seriesTypes, Bt.registerType = G.registerSeriesType, Bt.keepProps = ["colorIndex", "eventOptions", "navigatorSeries", "symbolIndex", "baseSeries"], Bt.keepPropsForPoints = ["data", "isDirtyData", "isDirtyCanvas", "points", "dataTable", "processedData", "xIncrement", "cropped", "_hasPointMarkers", "hasDataLabels", "nodes", "layout", "level", "mapMap", "mapData", "minY", "maxY", "minX", "maxX", "transformGroups"], Ge(Bt.prototype, { axisTypes: ["xAxis", "yAxis"], coll: "series", colorCounter: 0, directTouch: !1, invertible: !0, isCartesian: !0, kdAxisArray: ["clientX", "plotY"], parallelArrays: ["x", "y"], pointClass: $t, requireSorting: !0, sorted: !0 }), G.series = Bt; let Tt = Bt, { animObject: Rp, setAnimation: Wp } = mt, { registerEventOptions: En } = os, { composed: Fp, marginNames: In } = C, { distribute: Xp } = Ki, { format: Yp } = At, { addEvent: ws, createElement: Hp, css: Gp, defined: ar, discardElement: Vp, find: Zp, fireEvent: Kt, isNumber: Dn, merge: be, pick: Ot, pushUnique: $p, relativeLength: Kp, stableSort: qp, syncTimeout: _p } = I; class nr { constructor(t, e) { this.allItems = [], this.initialItemY = 0, this.itemHeight = 0, this.itemMarginBottom = 0, this.itemMarginTop = 0, this.itemX = 0, this.itemY = 0, this.lastItemY = 0, this.lastLineHeight = 0, this.legendHeight = 0, this.legendWidth = 0, this.maxItemWidth = 0, this.maxLegendWidth = 0, this.offsetWidth = 0, this.padding = 0, this.pages = [], this.symbolHeight = 0, this.symbolWidth = 0, this.titleHeight = 0, this.totalItemWidth = 0, this.widthOption = 0, this.chart = t, this.setOptions(e), e.enabled && (this.render(), En(this, e), ws(this.chart, "endResize", function () { this.legend.positionCheckboxes() })), ws(this.chart, "render", () => { this.options.enabled && this.proximate && (this.proximatePositions(), this.positionItems()) }) } setOptions(t) { let e = Ot(t.padding, 8); this.options = t, this.chart.styledMode || (this.itemStyle = t.itemStyle, this.itemHiddenStyle = be(this.itemStyle, t.itemHiddenStyle)), this.itemMarginTop = t.itemMarginTop, this.itemMarginBottom = t.itemMarginBottom, this.padding = e, this.initialItemY = e - 5, this.symbolWidth = Ot(t.symbolWidth, 16), this.pages = [], this.proximate = t.layout === "proximate" && !this.chart.inverted, this.baseline = void 0 } update(t, e) { let i = this.chart; this.setOptions(be(!0, this.options, t)), "events" in this.options && En(this, this.options), this.destroy(), i.isDirtyLegend = i.isDirtyBox = !0, Ot(e, !0) && i.redraw(), Kt(this, "afterUpdate", { redraw: e }) } colorizeItem(t, e) { var l; let i = t.color, { area: s, group: o, label: r, line: a, symbol: n } = t.legendItem || {}; if ((t instanceof Tt || t instanceof $t) && (t.color = ((l = t.options) == null ? void 0 : l.legendSymbolColor) || i), o == null || o[e ? "removeClass" : "addClass"]("highcharts-legend-item-hidden"), !this.chart.styledMode) { let { itemHiddenStyle: c = {} } = this, d = c.color, { fillColor: p, fillOpacity: u, lineColor: g, marker: m } = t.options, f = y => (!e && (y.fill && (y.fill = d), y.stroke && (y.stroke = d)), y); r == null || r.css(be(e ? this.itemStyle : c)), a == null || a.attr(f({ stroke: g || t.color })), n && n.attr(f(m && n.isMarker ? t.pointAttribs() : { fill: t.color })), s == null || s.attr(f({ fill: p || t.color, "fill-opacity": p ? 1 : u ?? .75 })) } t.color = i, Kt(this, "afterColorizeItem", { item: t, visible: e }) } positionItems() { this.allItems.forEach(this.positionItem, this), this.chart.isResizing || this.positionCheckboxes() } positionItem(t) { let { group: e, x: i = 0, y: s = 0 } = t.legendItem || {}, o = this.options, r = o.symbolPadding, a = !o.rtl, n = t.checkbox; if (e != null && e.element) { let l = { translateX: a ? i : this.legendWidth - i - 2 * r - 4, translateY: s }; e[ar(e.translateY) ? "animate" : "attr"](l, void 0, () => { Kt(this, "afterPositionItem", { item: t }) }) } n && (n.x = i, n.y = s) } destroyItem(t) { let e = t.checkbox, i = t.legendItem || {}; for (let s of ["group", "label", "line", "symbol"]) i[s] && (i[s] = i[s].destroy()); e && Vp(e), t.legendItem = void 0 } destroy() { for (let t of this.getAllItems()) this.destroyItem(t); for (let t of ["clipRect", "up", "down", "pager", "nav", "box", "title", "group"]) this[t] && (this[t] = this[t].destroy()); this.display = null } positionCheckboxes() { var o; let t, e = (o = this.group) == null ? void 0 : o.alignAttr, i = this.clipHeight || this.legendHeight, s = this.titleHeight; e && (t = e.translateY, this.allItems.forEach(function (r) { let a, n = r.checkbox; n && (a = t + s + n.y + (this.scrollOffset || 0) + 3, Gp(n, { left: e.translateX + r.checkboxOffset + n.x - 20 + "px", top: a + "px", display: this.proximate || a > t - 6 && a < t + i - 6 ? "" : "none" })) }, this)) } renderTitle() { let t = this.options, e = this.padding, i = t.title, s, o = 0; i.text && (this.title || (this.title = this.chart.renderer.label(i.text, e - 3, e - 4, void 0, void 0, void 0, t.useHTML, void 0, "legend-title").attr({ zIndex: 1 }), this.chart.styledMode || this.title.css(i.style), this.title.add(this.group)), i.width || this.title.css({ width: this.maxLegendWidth + "px" }), o = (s = this.title.getBBox()).height, this.offsetWidth = s.width, this.contentGroup.attr({ translateY: o })), this.titleHeight = o } setText(t) { let e = this.options; t.legendItem.label.attr({ text: e.labelFormat ? Yp(e.labelFormat, t, this.chart) : e.labelFormatter.call(t) }) } renderItem(t) { var A; let e = t.legendItem = t.legendItem || {}, i = this.chart, s = i.renderer, o = this.options, r = o.layout === "horizontal", a = this.symbolWidth, n = o.symbolPadding || 0, l = this.itemStyle, c = this.itemHiddenStyle, d = r ? Ot(o.itemDistance, 20) : 0, p = !o.rtl, u = !t.series, g = !u && t.series.drawLegendSymbol ? t.series : t, m = g.options, f = !!this.createCheckboxForItem && m && m.showCheckbox, y = o.useHTML, x = t.options.className, b = e.label, w = a + n + d + 20 * !!f; !b && (e.group = s.g("legend-item").addClass("highcharts-" + g.type + "-series highcharts-color-" + t.colorIndex + (x ? " " + x : "") + (u ? " highcharts-series-" + t.index : "")).attr({ zIndex: 1 }).add(this.scrollGroup), e.label = b = s.text("", p ? a + n : -n, this.baseline || 0, y), i.styledMode || b.css(be(t.visible ? l : c)), b.attr({ align: p ? "left" : "right", zIndex: 2 }).add(e.group), !this.baseline && (this.fontMetrics = s.fontMetrics(b), this.baseline = this.fontMetrics.f + 3 + this.itemMarginTop, b.attr("y", this.baseline), this.symbolHeight = Ot(o.symbolHeight, this.fontMetrics.f), o.squareSymbol && (this.symbolWidth = Ot(o.symbolWidth, Math.max(this.symbolHeight, 16)), w = this.symbolWidth + n + d + 20 * !!f, p && b.attr("x", this.symbolWidth + n))), g.drawLegendSymbol(this, t), this.setItemEvents && this.setItemEvents(t, b, y)), f && !t.checkbox && this.createCheckboxForItem && this.createCheckboxForItem(t), this.colorizeItem(t, t.visible), (i.styledMode || !l.width) && b.css({ width: (o.itemWidth || this.widthOption || i.spacingBox.width) - w + "px" }), this.setText(t); let v = b.getBBox(), S = ((A = this.fontMetrics) == null ? void 0 : A.h) || 0; t.itemWidth = t.checkboxOffset = o.itemWidth || e.labelWidth || v.width + w, this.maxItemWidth = Math.max(this.maxItemWidth, t.itemWidth), this.totalItemWidth += t.itemWidth, this.itemHeight = t.itemHeight = Math.round(e.labelHeight || (v.height > 1.5 * S ? v.height : S)) } layoutItem(t) { let e = this.options, i = this.padding, s = e.layout === "horizontal", o = t.itemHeight, r = this.itemMarginBottom, a = this.itemMarginTop, n = s ? Ot(e.itemDistance, 20) : 0, l = this.maxLegendWidth, c = e.alignColumns && this.totalItemWidth > l ? this.maxItemWidth : t.itemWidth, d = t.legendItem || {}; s && this.itemX - i + c > l && (this.itemX = i, this.lastLineHeight && (this.itemY += a + this.lastLineHeight + r), this.lastLineHeight = 0), this.lastItemY = a + this.itemY + r, this.lastLineHeight = Math.max(o, this.lastLineHeight), d.x = this.itemX, d.y = this.itemY, s ? this.itemX += c : (this.itemY += a + o + r, this.lastLineHeight = o), this.offsetWidth = this.widthOption || Math.max((s ? this.itemX - i - (t.checkbox ? 0 : n) : c) + i, this.offsetWidth) } getAllItems() { let t = []; return this.chart.series.forEach(function (e) { var s; let i = e == null ? void 0 : e.options; e && Ot(i.showInLegend, !ar(i.linkedTo) && void 0, !0) && (t = t.concat(((s = e.legendItem) == null ? void 0 : s.labels) || (i.legendType === "point" ? e.data : e))) }), Kt(this, "afterGetAllItems", { allItems: t }), t } getAlignment() { let t = this.options; return this.proximate ? t.align.charAt(0) + "tv" : t.floating ? "" : t.align.charAt(0) + t.verticalAlign.charAt(0) + t.layout.charAt(0) } adjustMargins(t, e) { let i = this.chart, s = this.options, o = this.getAlignment(); o && [/(lth|ct|rth)/, /(rtv|rm|rbv)/, /(rbh|cb|lbh)/, /(lbv|lm|ltv)/].forEach(function (r, a) { r.test(o) && !ar(t[a]) && (i[In[a]] = Math.max(i[In[a]], i.legend[(a + 1) % 2 ? "legendHeight" : "legendWidth"] + [1, -1, -1, 1][a] * s[a % 2 ? "x" : "y"] + Ot(s.margin, 12) + e[a] + (i.titleOffset[a] || 0))) }) } proximatePositions() { let t, e = this.chart, i = [], s = this.options.align === "left"; for (let o of (this.allItems.forEach(function (r) { let a, n, l = s, c, d; r.yAxis && (r.xAxis.options.reversed && (l = !l), r.points && (a = Zp(l ? r.points : r.points.slice(0).reverse(), function (p) { return Dn(p.plotY) })), n = this.itemMarginTop + r.legendItem.label.getBBox().height + this.itemMarginBottom, d = r.yAxis.top - e.plotTop, c = r.visible ? (a ? a.plotY : r.yAxis.height) + (d - .3 * n) : d + r.yAxis.height, i.push({ target: c, size: n, item: r })) }, this), Xp(i, e.plotHeight))) t = o.item.legendItem || {}, Dn(o.pos) && (t.y = e.plotTop - e.spacing[0] + o.pos) } render() { let t = this.chart, e = t.renderer, i = this.options, s = this.padding, o = this.getAllItems(), r, a, n, l = this.group, c, d = this.box; this.itemX = s, this.itemY = this.initialItemY, this.offsetWidth = 0, this.lastItemY = 0, this.widthOption = Kp(i.width, t.spacingBox.width - s), c = t.spacingBox.width - 2 * s - i.x, ["rm", "lm"].indexOf(this.getAlignment().substring(0, 2)) > -1 && (c /= 2), this.maxLegendWidth = this.widthOption || c, l || (this.group = l = e.g("legend").addClass(i.className || "").attr({ zIndex: 7 }).add(), this.contentGroup = e.g().attr({ zIndex: 1 }).add(l), this.scrollGroup = e.g().add(this.contentGroup)), this.renderTitle(), qp(o, (p, u) => { var g, m; return (((g = p.options) == null ? void 0 : g.legendIndex) || 0) - (((m = u.options) == null ? void 0 : m.legendIndex) || 0) }), i.reversed && o.reverse(), this.allItems = o, this.display = r = !!o.length, this.lastLineHeight = 0, this.maxItemWidth = 0, this.totalItemWidth = 0, this.itemHeight = 0, o.forEach(this.renderItem, this), o.forEach(this.layoutItem, this), a = (this.widthOption || this.offsetWidth) + s, n = this.lastItemY + this.lastLineHeight + this.titleHeight, n = this.handleOverflow(n) + s, d || (this.box = d = e.rect().addClass("highcharts-legend-box").attr({ r: i.borderRadius }).add(l)), t.styledMode || d.attr({ stroke: i.borderColor, "stroke-width": i.borderWidth || 0, fill: i.backgroundColor || "none" }).shadow(i.shadow), a > 0 && n > 0 && d[d.placed ? "animate" : "attr"](d.crisp.call({}, { x: 0, y: 0, width: a, height: n }, d.strokeWidth())), l[r ? "show" : "hide"](), t.styledMode && l.getStyle("display") === "none" && (a = n = 0), this.legendWidth = a, this.legendHeight = n, r && this.align(), this.proximate || this.positionItems(), Kt(this, "afterRender") } align(t = this.chart.spacingBox) { let e = this.chart, i = this.options, s = t.y; /(lth|ct|rth)/.test(this.getAlignment()) && e.titleOffset[0] > 0 ? s += e.titleOffset[0] : /(lbh|cb|rbh)/.test(this.getAlignment()) && e.titleOffset[2] > 0 && (s -= e.titleOffset[2]), s !== t.y && (t = be(t, { y: s })), e.hasRendered || (this.group.placed = !1), this.group.align(be(i, { width: this.legendWidth, height: this.legendHeight, verticalAlign: this.proximate ? "top" : i.verticalAlign }), !0, t) } handleOverflow(t) { let e = this, i = this.chart, s = i.renderer, o = this.options, r = o.y, a = o.verticalAlign === "top", n = this.padding, l = o.maxHeight, c = o.navigation, d = Ot(c.animation, !0), p = c.arrowSize || 12, u = this.pages, g = this.allItems, m = function (M) { typeof M == "number" ? A.attr({ height: M }) : A && (e.clipRect = A.destroy(), e.contentGroup.clip()), e.contentGroup.div && (e.contentGroup.div.style.clip = M ? "rect(" + n + "px,9999px," + (n + M) + "px,0)" : "auto") }, f = function (M) { return e[M] = s.circle(0, 0, 1.3 * p).translate(p / 2, p / 2).add(S), i.styledMode || e[M].attr("fill", "rgba(0,0,0,0.0001)"), e[M] }, y, x, b, w, v = i.spacingBox.height + (a ? -r : r) - n, S = this.nav, A = this.clipRect; return o.layout !== "horizontal" || o.verticalAlign === "middle" || o.floating || (v /= 2), l && (v = Math.min(v, l)), u.length = 0, t && v > 0 && t > v && c.enabled !== !1 ? (this.clipHeight = y = Math.max(v - 20 - this.titleHeight - n, 0), this.currentPage = Ot(this.currentPage, 1), this.fullHeight = t, g.forEach((M, k) => { let T = (b = M.legendItem || {}).y || 0, P = Math.round(b.label.getBBox().height), L = u.length; (!L || T - u[L - 1] > y && (x || T) !== u[L - 1]) && (u.push(x || T), L++), b.pageIx = L - 1, x && w && (w.pageIx = L - 1), k === g.length - 1 && T + P - u[L - 1] > y && T > u[L - 1] && (u.push(T), b.pageIx = L), T !== x && (x = T), w = b }), A || (A = e.clipRect = s.clipRect(0, n - 2, 9999, 0), e.contentGroup.clip(A)), m(y), S || (this.nav = S = s.g().attr({ zIndex: 1 }).add(this.group), this.up = s.symbol("triangle", 0, 0, p, p).add(S), f("upTracker").on("click", function () { e.scroll(-1, d) }), this.pager = s.text("", 15, 10).addClass("highcharts-legend-navigation"), !i.styledMode && c.style && this.pager.css(c.style), this.pager.add(S), this.down = s.symbol("triangle-down", 0, 0, p, p).add(S), f("downTracker").on("click", function () { e.scroll(1, d) })), e.scroll(0), t = v) : S && (m(), this.nav = S.destroy(), this.scrollGroup.attr({ translateY: 1 }), this.clipHeight = 0), t } scroll(t, e) { let i = this.chart, s = this.pages, o = s.length, r = this.clipHeight, a = this.options.navigation, n = this.pager, l = this.padding, c = this.currentPage + t; c > o && (c = o), c > 0 && (e !== void 0 && Wp(e, i), this.nav.attr({ translateX: l, translateY: r + this.padding + 7 + this.titleHeight, visibility: "inherit" }), [this.up, this.upTracker].forEach(function (d) { d.attr({ class: c === 1 ? "highcharts-legend-nav-inactive" : "highcharts-legend-nav-active" }) }), n.attr({ text: c + "/" + o }), [this.down, this.downTracker].forEach(function (d) { d.attr({ x: 18 + this.pager.getBBox().width, class: c === o ? "highcharts-legend-nav-inactive" : "highcharts-legend-nav-active" }) }, this), i.styledMode || (this.up.attr({ fill: c === 1 ? a.inactiveColor : a.activeColor }), this.upTracker.css({ cursor: c === 1 ? "default" : "pointer" }), this.down.attr({ fill: c === o ? a.inactiveColor : a.activeColor }), this.downTracker.css({ cursor: c === o ? "default" : "pointer" })), this.scrollOffset = -s[c - 1] + this.initialItemY, this.scrollGroup.animate({ translateY: this.scrollOffset }), this.currentPage = c, this.positionCheckboxes(), _p(() => { Kt(this, "afterScroll", { currentPage: c }) }, Rp(Ot(e, i.renderer.globalAnimation, !0)).duration)) } setItemEvents(t, e, i) { let s = this, o = t.legendItem || {}, r = s.chart.renderer.boxWrapper, a = t instanceof $t, n = t instanceof Tt, l = "highcharts-legend-" + (a ? "point" : "series") + "-active", c = s.chart.styledMode, d = i ? [e, o.symbol] : [o.group], p = u => { s.allItems.forEach(g => { t !== g && [g].concat(g.linkedSeries || []).forEach(m => { m.setState(u, !a) }) }) }; for (let u of d) u && u.on("mouseover", function () { t.visible && p("inactive"), t.setState("hover"), t.visible && r.addClass(l), c || e.css(s.options.itemHoverStyle) }).on("mouseout", function () { s.chart.styledMode || e.css(be(t.visible ? s.itemStyle : s.itemHiddenStyle)), p(""), r.removeClass(l), t.setState() }).on("click", function (g) { let m = function () { t.setVisible && t.setVisible(), p(t.visible ? "inactive" : "") }; r.removeClass(l), Kt(s, "itemClick", { browserEvent: g, legendItem: t }, m), a ? t.firePointEvent("legendItemClick", { browserEvent: g }) : n && Kt(t, "legendItemClick", { browserEvent: g }) }) } createCheckboxForItem(t) { t.checkbox = Hp("input", { type: "checkbox", className: "highcharts-legend-checkbox", checked: t.selected, defaultChecked: t.selected }, this.options.itemCheckboxStyle, this.chart.container), ws(t.checkbox, "click", function (e) { let i = e.target; Kt(t.series || t, "checkboxClick", { checked: i.checked, item: t }, function () { t.select() }) }) } } (function (h) { h.compose = function (t) { $p(Fp, "Core.Legend") && ws(t, "beforeMargins", function () { this.legend = new h(this, this.options.legend) }) } })(nr || (nr = {})); let Bn = nr, { animate: lr, animObject: Jp, setAnimation: hr } = mt, { defaultOptions: dr } = wt, { numberFormat: Qp } = At, { registerEventOptions: zn } = os, { charts: ve, doc: Mi, marginNames: Nn, svg: tu, win: Un } = C, { seriesTypes: cr } = G, { addEvent: pr, attr: jn, createElement: ur, css: zt, defined: oe, diffObjects: Rn, discardElement: eu, erase: iu, error: gr, extend: re, find: mr, fireEvent: Z, getAlignFactor: su, getStyle: fr, isArray: ou, isNumber: Ve, isObject: ru, isString: Ss, merge: Xt, objectEach: yr, pick: yt, pInt: au, relativeLength: Wn, removeEvent: Fn, splat: Ms, syncTimeout: nu, uniqueKey: lu } = I; class we { static chart(t, e, i) { return new we(t, e, i) } constructor(t, e, i) { this.sharedClips = {}; let s = [...arguments]; (Ss(t) || t.nodeName) && (this.renderTo = s.shift()), this.init(s[0], s[1]) } setZoomOptions() { let t = this.options.chart, e = t.zooming; this.zooming = { ...e, type: yt(t.zoomType, e.type), key: yt(t.zoomKey, e.key), pinchType: yt(t.pinchType, e.pinchType), singleTouch: yt(t.zoomBySingleTouch, e.singleTouch, !1), resetButton: Xt(e.resetButton, t.resetZoomButton) } } init(t, e) { Z(this, "init", { args: arguments }, function () { var r; let i = Xt(dr, t), s = i.chart, o = this.renderTo || s.renderTo; this.userOptions = re({}, t), (this.renderTo = Ss(o) ? Mi.getElementById(o) : o) || gr(13, !0, this), this.margin = [], this.spacing = [], this.labelCollectors = [], this.callback = e, this.isResizing = 0, this.options = i, this.axes = [], this.series = [], this.locale = i.lang.locale ?? ((r = this.renderTo.closest("[lang]")) == null ? void 0 : r.lang), this.time = new Mo(re(i.time || {}, { locale: this.locale }), i.lang), i.time = this.time.options, this.numberFormatter = (s.numberFormatter || Qp).bind(this), this.styledMode = s.styledMode, this.hasCartesianSeries = s.showAxes, this.index = ve.length, ve.push(this), C.chartCount++, zn(this, s), this.xAxis = [], this.yAxis = [], this.pointCount = this.colorCounter = this.symbolCounter = 0, this.setZoomOptions(), Z(this, "afterInit"), this.firstRender() }) } initSeries(t) { let e = this.options.chart, i = t.type || e.type, s = cr[i]; s || gr(17, !0, this, { missingModuleFor: i }); let o = new s; return typeof o.init == "function" && o.init(this, t), o } setSortedData() { this.getSeriesOrderByLinks().forEach(function (t) { t.points || t.data || !t.enabledDataSorting || t.setData(t.options.data, !1) }) } getSeriesOrderByLinks() { return this.series.concat().sort(function (t, e) { return t.linkedSeries.length || e.linkedSeries.length ? e.linkedSeries.length - t.linkedSeries.length : 0 }) } orderItems(t, e = 0) { let i = this[t], s = this.options[t] = Ms(this.options[t]).slice(), o = this.userOptions[t] = this.userOptions[t] ? Ms(this.userOptions[t]).slice() : []; if (this.hasRendered && (s.splice(e), o.splice(e)), i) for (let r = e, a = i.length; r < a; ++r) { let n = i[r]; n && (n.index = r, n instanceof Tt && (n.name = n.getName()), n.options.isInternal || (s[r] = n.options, o[r] = n.userOptions)) } } getClipBox(t, e) { var c, d; let i = this.inverted, { xAxis: s, yAxis: o } = t || {}, { x: r, y: a, width: n, height: l } = Xt(this.clipBox); return t && (s && s.len !== this.plotSizeX && (n = s.len), o && o.len !== this.plotSizeY && (l = o.len), i && !t.invertible && ([n, l] = [l, n])), e && (r += ((c = i ? o : s) == null ? void 0 : c.pos) ?? this.plotLeft, a += ((d = i ? s : o) == null ? void 0 : d.pos) ?? this.plotTop), { x: r, y: a, width: n, height: l } } isInsidePlot(t, e, i = {}) { var f; let { inverted: s, plotBox: o, plotLeft: r, plotTop: a, scrollablePlotBox: n } = this, { scrollLeft: l = 0, scrollTop: c = 0 } = i.visiblePlotOnly && ((f = this.scrollablePlotArea) == null ? void 0 : f.scrollingContainer) || {}, d = i.series, p = i.visiblePlotOnly && n || o, u = i.inverted ? e : t, g = i.inverted ? t : e, m = { x: u, y: g, isInsidePlot: !0, options: i }; if (!i.ignoreX) { let y = d && (s && !this.polar ? d.yAxis : d.xAxis) || { pos: r, len: 1 / 0 }, x = i.paneCoordinates ? y.pos + u : r + u; x >= Math.max(l + r, y.pos) && x <= Math.min(l + r + p.width, y.pos + y.len) || (m.isInsidePlot = !1) } if (!i.ignoreY && m.isInsidePlot) { let y = !s && i.axis && !i.axis.isXAxis && i.axis || d && (s ? d.xAxis : d.yAxis) || { pos: a, len: 1 / 0 }, x = i.paneCoordinates ? y.pos + g : a + g; x >= Math.max(c + a, y.pos) && x <= Math.min(c + a + p.height, y.pos + y.len) || (m.isInsidePlot = !1) } return Z(this, "afterIsInsidePlot", m), m.isInsidePlot } redraw(t) { Z(this, "beforeRedraw"); let e = this.hasCartesianSeries ? this.axes : this.colorAxis || [], i = this.series, s = this.pointer, o = this.legend, r = this.userOptions.legend, a = this.renderer, n = a.isHidden(), l = [], c, d, p, u = this.isDirtyBox, g = this.isDirtyLegend, m; for (a.rootFontSize = a.boxWrapper.getStyle("font-size"), this.setResponsive && this.setResponsive(!1), hr(!!this.hasRendered && t, this), n && this.temporaryDisplay(), this.layOutTitles(!1), p = i.length; p--;)if (((m = i[p]).options.stacking || m.options.centerInCategory) && (d = !0, m.isDirty)) { c = !0; break } if (c) for (p = i.length; p--;)(m = i[p]).options.stacking && (m.isDirty = !0); i.forEach(function (f) { f.isDirty && (f.options.legendType === "point" ? (typeof f.updateTotals == "function" && f.updateTotals(), g = !0) : r && (r.labelFormatter || r.labelFormat) && (g = !0)), f.isDirtyData && Z(f, "updatedData") }), g && o && o.options.enabled && (o.render(), this.isDirtyLegend = !1), d && this.getStacks(), e.forEach(function (f) { f.updateNames(), f.setScale() }), this.getMargins(), e.forEach(function (f) { f.isDirty && (u = !0) }), e.forEach(function (f) { let y = f.min + "," + f.max; f.extKey !== y && (f.extKey = y, l.push(function () { Z(f, "afterSetExtremes", re(f.eventArgs, f.getExtremes())), delete f.eventArgs })), (u || d) && f.redraw() }), u && this.drawChartBox(), Z(this, "predraw"), i.forEach(function (f) { (u || f.isDirty) && f.visible && f.redraw(), f.isDirtyData = !1 }), s && s.reset(!0), a.draw(), Z(this, "redraw"), Z(this, "render"), n && this.temporaryDisplay(!0), l.forEach(function (f) { f.call() }) } get(t) { let e = this.series; function i(o) { return o.id === t || o.options && o.options.id === t } let s = mr(this.axes, i) || mr(this.series, i); for (let o = 0; !s && o < e.length; o++)s = mr(e[o].points || [], i); return s } createAxes() { let t = this.userOptions; for (let e of (Z(this, "createAxes"), ["xAxis", "yAxis"])) for (let i of t[e] = Ms(t[e] || {})) new xi(this, i, e); Z(this, "afterCreateAxes") } getSelectedPoints() { return this.series.reduce((t, e) => (e.getPointsCollection().forEach(i => { yt(i.selectedStaging, i.selected) && t.push(i) }), t), []) } getSelectedSeries() { return this.series.filter(t => t.selected) } setTitle(t, e, i) { this.applyDescription("title", t), this.applyDescription("subtitle", e), this.applyDescription("caption", void 0), this.layOutTitles(i) } applyDescription(t, e) { var r; let i = this, s = this.options[t] = Xt(this.options[t], e), o = this[t]; o && e && (this[t] = o = o.destroy()), s && !o && ((o = this.renderer.text(s.text, 0, 0, s.useHTML).attr({ align: s.align, class: "highcharts-" + t, zIndex: s.zIndex || 4 }).css({ textOverflow: "ellipsis", whiteSpace: "nowrap" }).add()).update = function (a, n) { i.applyDescription(t, a), i.layOutTitles(n) }, this.styledMode || o.css(re(t === "title" ? { fontSize: this.options.isStock ? "1em" : "1.2em" } : {}, s.style)), o.textPxLength = o.getBBox().width, o.css({ whiteSpace: (r = s.style) == null ? void 0 : r.whiteSpace }), this[t] = o) } layOutTitles(t = !0) { var a, n, l, c; let e = [0, 0, 0], { options: i, renderer: s, spacingBox: o } = this;["title", "subtitle", "caption"].forEach(d => { var f; let p = this[d], u = this.options[d], g = Xt(o), m = (p == null ? void 0 : p.textPxLength) || 0; if (p && u) { Z(this, "layOutTitle", { alignTo: g, key: d, textPxLength: m }); let y = s.fontMetrics(p), x = y.b, b = y.h, w = u.verticalAlign || "top", v = w === "top", S = v && u.minScale || 1, A = d === "title" ? v ? -3 : 0 : v ? e[0] + 2 : 0, M = Math.min(g.width / m, 1), k = Math.max(S, M), T = Xt({ y: w === "bottom" ? x : A + x }, { align: d === "title" ? M < S ? "left" : "center" : (f = this.title) == null ? void 0 : f.alignValue }, u), P = (u.width || (M > S ? this.chartWidth : g.width) / k) + "px"; p.alignValue !== T.align && (p.placed = !1); let L = Math.round(p.css({ width: P }).getBBox(u.useHTML).height); if (T.height = L, p.align(T, !1, g).attr({ align: T.align, scaleX: k, scaleY: k, "transform-origin": `${g.x + m * k * su(T.align)} ${b}` }), !u.floating) { let O = L * (L < 1.2 * b ? 1 : k); w === "top" ? e[0] = Math.ceil(e[0] + O) : w === "bottom" && (e[2] = Math.ceil(e[2] + O)) } } }, this), e[0] && (((a = i.title) == null ? void 0 : a.verticalAlign) || "top") === "top" && (e[0] += ((n = i.title) == null ? void 0 : n.margin) || 0), e[2] && ((l = i.caption) == null ? void 0 : l.verticalAlign) === "bottom" && (e[2] += ((c = i.caption) == null ? void 0 : c.margin) || 0); let r = !this.titleOffset || this.titleOffset.join(",") !== e.join(","); this.titleOffset = e, Z(this, "afterLayOutTitles"), !this.isDirtyBox && r && (this.isDirtyBox = this.isDirtyLegend = r, this.hasRendered && t && this.isDirtyBox && this.redraw()) } getContainerBox() { let t = [].map.call(this.renderTo.children, i => { if (i !== this.container) { let s = i.style.display; return i.style.display = "none", [i, s] } }), e = { width: fr(this.renderTo, "width", !0) || 0, height: fr(this.renderTo, "height", !0) || 0 }; return t.filter(Boolean).forEach(([i, s]) => { i.style.display = s }), e } getChartSize() { var r; let t = this.options.chart, e = t.width, i = t.height, s = this.getContainerBox(), o = s.height <= 1 || !((r = this.renderTo.parentElement) != null && r.style.height) && this.renderTo.style.height === "100%"; this.chartWidth = Math.max(0, e || s.width || 600), this.chartHeight = Math.max(0, Wn(i, this.chartWidth) || (o ? 400 : s.height)), this.containerBox = s } temporaryDisplay(t) { let e = this.renderTo, i; if (t) for (; e != null && e.style;)e.hcOrigStyle && (zt(e, e.hcOrigStyle), delete e.hcOrigStyle), e.hcOrigDetached && (Mi.body.removeChild(e), e.hcOrigDetached = !1), e = e.parentNode; else for (; e != null && e.style && (Mi.body.contains(e) || e.parentNode || (e.hcOrigDetached = !0, Mi.body.appendChild(e)), (fr(e, "display", !1) === "none" || e.hcOricDetached) && (e.hcOrigStyle = { display: e.style.display, height: e.style.height, overflow: e.style.overflow }, i = { display: "block", overflow: "hidden" }, e !== this.renderTo && (i.height = 0), zt(e, i), e.offsetWidth || e.style.setProperty("display", "block", "important")), (e = e.parentNode) !== Mi.body);); } setClassName(t) { this.container.className = "highcharts-container " + (t || "") } getContainer() { var p, u; let t, e = this.options, i = e.chart, s = "data-highcharts-chart", o = lu(), r = this.renderTo, a = au(jn(r, s)); Ve(a) && ve[a] && ve[a].hasRendered && ve[a].destroy(), jn(r, s, this.index), r.innerHTML = et.emptyHTML, i.skipClone || r.offsetWidth || this.temporaryDisplay(), this.getChartSize(); let n = this.chartHeight, l = this.chartWidth; zt(r, { overflow: "hidden" }), this.styledMode || (t = re({ position: "relative", overflow: "hidden", width: l + "px", height: n + "px", textAlign: "left", lineHeight: "normal", zIndex: 0, "-webkit-tap-highlight-color": "rgba(0,0,0,0)", userSelect: "none", "touch-action": "manipulation", outline: "none", padding: "0px" }, i.style || {})); let c = ur("div", { id: o }, t, r); this.container = c, this.getChartSize(), l !== this.chartWidth && (l = this.chartWidth, this.styledMode || zt(c, { width: yt((p = i.style) == null ? void 0 : p.width, l + "px") })), this.containerBox = this.getContainerBox(), this._cursor = c.style.cursor; let d = i.renderer || !tu ? pi.getRendererType(i.renderer) : ye; if (this.renderer = new d(c, l, n, void 0, i.forExport, (u = e.exporting) == null ? void 0 : u.allowHTML, this.styledMode), hr(void 0, this), this.setClassName(i.className), this.styledMode) for (let g in e.defs) this.renderer.definition(e.defs[g]); else this.renderer.setStyle(i.style); this.renderer.chartIndex = this.index, Z(this, "afterGetContainer") } getMargins(t) { var o; let { spacing: e, margin: i, titleOffset: s } = this; this.resetMargins(), s[0] && !oe(i[0]) && (this.plotTop = Math.max(this.plotTop, s[0] + e[0])), s[2] && !oe(i[2]) && (this.marginBottom = Math.max(this.marginBottom, s[2] + e[2])), (o = this.legend) != null && o.display && this.legend.adjustMargins(i, e), Z(this, "getMargins"), t || this.getAxisMargins() } getAxisMargins() { let t = this, e = t.axisOffset = [0, 0, 0, 0], i = t.colorAxis, s = t.margin, o = function (r) { r.forEach(function (a) { a.visible && a.getOffset() }) }; t.hasCartesianSeries ? o(t.axes) : i != null && i.length && o(i), Nn.forEach(function (r, a) { oe(s[a]) || (t[r] += e[a]) }), t.setChartSize() } getOptions() { return Rn(this.userOptions, dr) } reflow(t) { var o, r; let e = this, i = e.containerBox, s = e.getContainerBox(); (o = e.pointer) == null || delete o.chartPosition, !((r = e.exporting) != null && r.isPrinting) && !e.isResizing && i && s.width && ((s.width !== i.width || s.height !== i.height) && (I.clearTimeout(e.reflowTimeout), e.reflowTimeout = nu(function () { e.container && e.setSize(void 0, void 0, !1) }, 100 * !!t)), e.containerBox = s) } setReflow() { let t = this, e = i => { var s; (s = t.options) != null && s.chart.reflow && t.hasLoaded && t.reflow(i) }; if (typeof ResizeObserver == "function") new ResizeObserver(e).observe(t.renderTo); else { let i = pr(Un, "resize", e); pr(this, "destroy", i) } } setSize(t, e, i) { let s = this, o = s.renderer; s.isResizing += 1, hr(i, s); let r = o.globalAnimation; s.oldChartHeight = s.chartHeight, s.oldChartWidth = s.chartWidth, t !== void 0 && (s.options.chart.width = t), e !== void 0 && (s.options.chart.height = e), s.getChartSize(); let { chartWidth: a, chartHeight: n, scrollablePixelsX: l = 0, scrollablePixelsY: c = 0 } = s; (s.isDirtyBox || a !== s.oldChartWidth || n !== s.oldChartHeight) && (s.styledMode || (r ? lr : zt)(s.container, { width: `${a + l}px`, height: `${n + c}px` }, r), s.setChartSize(!0), o.setSize(a, n, r), s.axes.forEach(function (d) { d.isDirty = !0, d.setScale() }), s.isDirtyLegend = !0, s.isDirtyBox = !0, s.layOutTitles(), s.getMargins(), s.redraw(r), s.oldChartHeight = void 0, Z(s, "resize"), setTimeout(() => { s && Z(s, "endResize") }, Jp(r).duration)), s.isResizing -= 1 } setChartSize(t) { let e, i, s, o, { chartHeight: r, chartWidth: a, inverted: n, spacing: l, renderer: c } = this, d = this.clipOffset, p = Math[n ? "floor" : "round"]; this.plotLeft = e = Math.round(this.plotLeft), this.plotTop = i = Math.round(this.plotTop), this.plotWidth = s = Math.max(0, Math.round(a - e - (this.marginRight ?? 0))), this.plotHeight = o = Math.max(0, Math.round(r - i - (this.marginBottom ?? 0))), this.plotSizeX = n ? o : s, this.plotSizeY = n ? s : o, this.spacingBox = c.spacingBox = { x: l[3], y: l[0], width: a - l[3] - l[1], height: r - l[0] - l[2] }, this.plotBox = c.plotBox = { x: e, y: i, width: s, height: o }, d && (this.clipBox = { x: p(d[3]), y: p(d[0]), width: p(this.plotSizeX - d[1] - d[3]), height: p(this.plotSizeY - d[0] - d[2]) }), t || (this.axes.forEach(function (u) { u.setAxisSize(), u.setAxisTranslation() }), c.alignElements()), Z(this, "afterSetChartSize", { skipAxes: t }) } resetMargins() { Z(this, "resetMargins"); let t = this, e = t.options.chart, i = e.plotBorderWidth || 0, s = Math.round(i) / 2;["margin", "spacing"].forEach(function (o) { let r = e[o], a = ru(r) ? r : [r, r, r, r];["Top", "Right", "Bottom", "Left"].forEach(function (n, l) { t[o][l] = yt(e[o + n], a[l]) }) }), Nn.forEach(function (o, r) { t[o] = yt(t.margin[r], t.spacing[r]) }), t.axisOffset = [0, 0, 0, 0], t.clipOffset = [s, s, s, s], t.plotBorderWidth = i } drawChartBox() { let t = this.options.chart, e = this.renderer, i = this.chartWidth, s = this.chartHeight, o = this.styledMode, r = this.plotBGImage, a = t.backgroundColor, n = t.plotBackgroundColor, l = t.plotBackgroundImage, c = this.plotLeft, d = this.plotTop, p = this.plotWidth, u = this.plotHeight, g = this.plotBox, m = this.clipRect, f = this.clipBox, y = this.chartBackground, x = this.plotBackground, b = this.plotBorder, w, v, S, A = "animate"; y || (this.chartBackground = y = e.rect().addClass("highcharts-background").add(), A = "attr"), o ? w = v = y.strokeWidth() : (v = (w = t.borderWidth || 0) + 8 * !!t.shadow, S = { fill: a || "none" }, (w || y["stroke-width"]) && (S.stroke = t.borderColor, S["stroke-width"] = w), y.attr(S).shadow(t.shadow)), y[A]({ x: v / 2, y: v / 2, width: i - v - w % 2, height: s - v - w % 2, r: t.borderRadius }), A = "animate", x || (A = "attr", this.plotBackground = x = e.rect().addClass("highcharts-plot-background").add()), x[A](g), !o && (x.attr({ fill: n || "none" }).shadow(t.plotShadow), l && (r ? (l !== r.attr("href") && r.attr("href", l), r.animate(g)) : this.plotBGImage = e.image(l, c, d, p, u).add())), m ? m.animate({ width: f.width, height: f.height }) : this.clipRect = e.clipRect(f), A = "animate", b || (A = "attr", this.plotBorder = b = e.rect().addClass("highcharts-plot-border").attr({ zIndex: 1 }).add()), o || b.attr({ stroke: t.plotBorderColor, "stroke-width": t.plotBorderWidth || 0, fill: "none" }), b[A](b.crisp(g, -b.strokeWidth())), this.isDirtyBox = !1, Z(this, "afterDrawChartBox") } propFromSeries() { let t, e, i, s = this, o = s.options.chart, r = s.options.series;["inverted", "angular", "polar"].forEach(function (a) { for (e = cr[o.type], i = o[a] || e && e.prototype[a], t = r == null ? void 0 : r.length; !i && t--;)(e = cr[r[t].type]) && e.prototype[a] && (i = !0); s[a] = i }) } linkSeries(t) { let e = this, i = e.series; i.forEach(function (s) { s.linkedSeries.length = 0 }), i.forEach(function (s) { let { linkedTo: o } = s.options; if (Ss(o)) { let r; (r = o === ":previous" ? e.series[s.index - 1] : e.get(o)) && r.linkedParent !== s && (r.linkedSeries.push(s), s.linkedParent = r, r.enabledDataSorting && s.setDataSortingOptions(), s.visible = yt(s.options.visible, r.options.visible, s.visible)) } }), Z(this, "afterLinkSeries", { isUpdating: t }) } renderSeries() { this.series.forEach(function (t) { t.translate(), t.render() }) } render() { var c; let t = this.axes, e = this.colorAxis, i = this.renderer, s = this.options.chart.axisLayoutRuns || 2, o = d => { d.forEach(p => { p.visible && p.render() }) }, r = 0, a = !0, n, l = 0; for (let d of (this.setTitle(), Z(this, "beforeMargins"), (c = this.getStacks) == null || c.call(this), this.getMargins(!0), this.setChartSize(), t)) { let { options: p } = d, { labels: u } = p; if (this.hasCartesianSeries && d.horiz && d.visible && u.enabled && d.series.length && d.coll !== "colorAxis" && !this.polar) { r = p.tickLength, d.createGroups(); let g = new Fe(d, 0, "", !0), m = g.createLabel("x", u); if (g.destroy(), m && yt(u.reserveSpace, !Ve(p.crossing)) && (r = m.getBBox().height + u.distance + Math.max(p.offset || 0, 0)), r) { m == null || m.destroy(); break } } } for (this.plotHeight = Math.max(this.plotHeight - r, 0); (a || n || s > 1) && l < s;) { let d = this.plotWidth, p = this.plotHeight; for (let u of t) l === 0 ? u.setScale() : (u.horiz && a || !u.horiz && n) && u.setTickInterval(!0); l === 0 ? this.getAxisMargins() : this.getMargins(), a = d / this.plotWidth > (l ? 1 : 1.1), n = p / this.plotHeight > (l ? 1 : 1.05), l++ } this.drawChartBox(), this.hasCartesianSeries ? o(t) : e != null && e.length && o(e), this.seriesGroup || (this.seriesGroup = i.g("series-group").attr({ zIndex: 3 }).shadow(this.options.chart.seriesGroupShadow).add()), this.dataLabelsGroup || (this.dataLabelsGroup = i.g("datalabels-group").attr({ zIndex: 6 }).add()), this.renderSeries(), this.addCredits(), this.setResponsive && this.setResponsive(), this.hasRendered = !0 } addCredits(t) { let e = this, i = Xt(!0, this.options.credits, t); i.enabled && !this.credits && (this.credits = this.renderer.text(i.text + (this.mapCredits || ""), 0, 0).addClass("highcharts-credits").on("click", function () { i.href && (Un.location.href = i.href) }).attr({ align: i.position.align, zIndex: 8 }), e.styledMode || this.credits.css(i.style), this.credits.add().align(i.position), this.credits.update = function (s) { e.credits = e.credits.destroy(), e.addCredits(s) }) } destroy() { var a, n; let t, e = this, i = e.axes, s = e.series, o = e.container, r = o == null ? void 0 : o.parentNode; for (Z(e, "destroy"), e.renderer.forExport ? iu(ve, e) : ve[e.index] = void 0, C.chartCount--, e.renderTo.removeAttribute("data-highcharts-chart"), Fn(e), t = i.length; t--;)i[t] = i[t].destroy(); for ((n = (a = this.scroller) == null ? void 0 : a.destroy) == null || n.call(a), t = s.length; t--;)s[t] = s[t].destroy();["title", "subtitle", "chartBackground", "plotBackground", "plotBGImage", "plotBorder", "seriesGroup", "clipRect", "credits", "pointer", "rangeSelector", "legend", "resetZoomButton", "tooltip", "renderer"].forEach(l => { var c, d; e[l] = (d = (c = e[l]) == null ? void 0 : c.destroy) == null ? void 0 : d.call(c) }), o && (o.innerHTML = et.emptyHTML, Fn(o), r && eu(o)), yr(e, function (l, c) { delete e[c] }) } firstRender() { var s; let t = this, e = t.options; t.getContainer(), t.resetMargins(), t.setChartSize(), t.propFromSeries(), t.createAxes(); let i = ou(e.series) ? e.series : []; e.series = [], i.forEach(function (o) { t.initSeries(o) }), t.linkSeries(), t.setSortedData(), Z(t, "beforeRender"), t.render(), (s = t.pointer) == null || s.getChartPosition(), t.renderer.imgCount || t.hasLoaded || t.onload(), t.temporaryDisplay(!0) } onload() { this.callbacks.concat([this.callback]).forEach(function (t) { t && this.index !== void 0 && t.apply(this, [this]) }, this), Z(this, "load"), Z(this, "render"), oe(this.index) && this.setReflow(), this.warnIfA11yModuleNotLoaded(), this.hasLoaded = !0 } warnIfA11yModuleNotLoaded() { let { options: t, title: e } = this; t && !this.accessibility && (this.renderer.boxWrapper.attr({ role: "img", "aria-label": ((e == null ? void 0 : e.element.textContent) || "").replace(/</g, "&lt;") }), t.accessibility && t.accessibility.enabled === !1 || gr('Highcharts warning: Consider including the "accessibility.js" module to make your chart more usable for people with disabilities. Set the "accessibility.enabled" option to false to remove this warning. See https://www.highcharts.com/docs/accessibility/accessibility-module.', !1, this)) } addSeries(t, e, i) { let s, o = this; return t && (e = yt(e, !0), Z(o, "addSeries", { options: t }, function () { s = o.initSeries(t), o.isDirtyLegend = !0, o.linkSeries(), s.enabledDataSorting && s.setData(t.data, !1), Z(o, "afterAddSeries", { series: s }), e && o.redraw(i) })), s } addAxis(t, e, i, s) { return this.createAxis(e ? "xAxis" : "yAxis", { axis: t, redraw: i, animation: s }) } addColorAxis(t, e, i) { return this.createAxis("colorAxis", { axis: t, redraw: e, animation: i }) } createAxis(t, e) { let i = new xi(this, e.axis, t); return yt(e.redraw, !0) && this.redraw(e.animation), i } showLoading(t) { let e = this, i = e.options, s = i.loading, o = function () { r && zt(r, { left: e.plotLeft + "px", top: e.plotTop + "px", width: e.plotWidth + "px", height: e.plotHeight + "px" }) }, r = e.loadingDiv, a = e.loadingSpan; r || (e.loadingDiv = r = ur("div", { className: "highcharts-loading highcharts-loading-hidden" }, null, e.container)), a || (e.loadingSpan = a = ur("span", { className: "highcharts-loading-inner" }, null, r), pr(e, "redraw", o)), r.className = "highcharts-loading", et.setElementHTML(a, yt(t, i.lang.loading, "")), !e.styledMode && (zt(r, re(s.style, { zIndex: 10 })), zt(a, s.labelStyle), e.loadingShown || (zt(r, { opacity: 0, display: "" }), lr(r, { opacity: s.style.opacity || .5 }, { duration: s.showDuration || 0 }))), e.loadingShown = !0, o() } hideLoading() { let t = this.options, e = this.loadingDiv; e && (e.className = "highcharts-loading highcharts-loading-hidden", this.styledMode || lr(e, { opacity: 0 }, { duration: t.loading.hideDuration || 100, complete: function () { zt(e, { display: "none" }) } })), this.loadingShown = !1 } update(t, e, i, s) { let o, r, a, n = this, l = { credits: "addCredits", title: "setTitle", subtitle: "setSubtitle", caption: "setCaption" }, c = t.isResponsiveOptions, d = []; Z(n, "update", { options: t }), c || n.setResponsive(!1, !0), t = Rn(t, n.options), n.userOptions = Xt(n.userOptions, t); let p = t.chart; p && (Xt(!0, n.options.chart, p), this.setZoomOptions(), "className" in p && n.setClassName(p.className), ("inverted" in p || "polar" in p || "type" in p) && (n.propFromSeries(), o = !0), "alignTicks" in p && (o = !0), "events" in p && zn(this, p), yr(p, function (m, f) { n.propsRequireUpdateSeries.indexOf("chart." + f) !== -1 && (r = !0), n.propsRequireDirtyBox.indexOf(f) !== -1 && (n.isDirtyBox = !0), n.propsRequireReflow.indexOf(f) !== -1 && (n.isDirtyBox = !0, c || (a = !0)) }), !n.styledMode && p.style && n.renderer.setStyle(n.options.chart.style || {})), !n.styledMode && t.colors && (this.options.colors = t.colors), yr(t, function (m, f) { n[f] && typeof n[f].update == "function" ? n[f].update(m, !1) : typeof n[l[f]] == "function" ? n[l[f]](m) : f !== "colors" && n.collectionsWithUpdate.indexOf(f) === -1 && Xt(!0, n.options[f], t[f]), f !== "chart" && n.propsRequireUpdateSeries.indexOf(f) !== -1 && (r = !0) }), this.collectionsWithUpdate.forEach(function (m) { t[m] && (Ms(t[m]).forEach(function (f, y) { let x, b = oe(f.id); b && (x = n.get(f.id)), !x && n[m] && (x = n[m][yt(f.index, y)]) && (b && oe(x.options.id) || x.options.isInternal) && (x = void 0), x && x.coll === m && (x.update(f, !1), i && (x.touched = !0)), !x && i && n.collectionsWithInit[m] && (n.collectionsWithInit[m][0].apply(n, [f].concat(n.collectionsWithInit[m][1] || []).concat([!1])).touched = !0) }), i && n[m].forEach(function (f) { f.touched || f.options.isInternal ? delete f.touched : d.push(f) })) }), d.forEach(function (m) { m.chart && m.remove && m.remove(!1) }), o && n.axes.forEach(function (m) { m.update({}, !1) }), r && n.getSeriesOrderByLinks().forEach(function (m) { m.chart && m.update({}, !1) }, this); let u = p == null ? void 0 : p.width, g = p && (Ss(p.height) ? Wn(p.height, u || n.chartWidth) : p.height); a || Ve(u) && u !== n.chartWidth || Ve(g) && g !== n.chartHeight ? n.setSize(u, g, s) : yt(e, !0) && n.redraw(s), Z(n, "afterUpdate", { options: t, redraw: e, animation: s }) } setSubtitle(t, e) { this.applyDescription("subtitle", t), this.layOutTitles(e) } setCaption(t, e) { this.applyDescription("caption", t), this.layOutTitles(e) } showResetZoom() { let t = this, e = dr.lang, i = t.zooming.resetButton, s = i.theme, o = i.relativeTo === "chart" || i.relativeTo === "spacingBox" ? null : "plotBox"; function r() { t.zoomOut() } Z(this, "beforeShowResetZoom", null, function () { t.resetZoomButton = t.renderer.button(e.resetZoom, null, null, r, s).attr({ align: i.position.align, title: e.resetZoomTitle }).addClass("highcharts-reset-zoom").add().align(i.position, !1, o) }), Z(this, "afterShowResetZoom") } zoomOut() { Z(this, "selection", { resetSelection: !0 }, () => this.transform({ reset: !0, trigger: "zoom" })) } pan(t, e) { let i = this, s = typeof e == "object" ? e : { enabled: e, type: "x" }, o = s.type, r = o && i[{ x: "xAxis", xy: "axes", y: "yAxis" }[o]].filter(n => n.options.panningEnabled && !n.options.isInternal), a = i.options.chart; a != null && a.panning && (a.panning = s), Z(this, "pan", { originalEvent: t }, () => { i.transform({ axes: r, event: t, to: { x: t.chartX - (i.mouseDownX || 0), y: t.chartY - (i.mouseDownY || 0) }, trigger: "pan" }), zt(i.container, { cursor: "move" }) }) } transform(t) { var g; let { axes: e = this.axes, event: i, from: s = {}, reset: o, selection: r, to: a = {}, trigger: n } = t, { inverted: l, time: c } = this; (g = this.hoverPoints) == null || g.forEach(m => m.setState()), Z(this, "transform", t); let d = t.hasZoomed || !1, p, u; for (let m of e) { let { horiz: f, len: y, minPointOffset: x = 0, options: b, reversed: w } = m, v = f ? "width" : "height", S = f ? "x" : "y", A = yt(a[v], m.len), M = yt(s[v], m.len), k = 10 > Math.abs(A) ? 1 : A / M, T = (s[S] || 0) + M / 2 - m.pos, P = T - ((a[S] ?? m.pos) + A / 2 - m.pos) / k, L = w && !l || !w && l ? -1 : 1; if (!o && (T < 0 || T > m.len)) continue; let O = m.chart.polar || m.isOrdinal ? 0 : x * L || 0, B = m.toValue(P, !0), D = m.toValue(P + y / k, !0), z = B + O, E = D - O, N = m.allExtremes; if (r && r[m.coll].push({ axis: m, min: Math.min(B, D), max: Math.max(B, D) }), z > E && ([z, E] = [E, z]), k === 1 && !o && m.coll === "yAxis" && !N) { for (let ft of m.series) { let tt = ft.getExtremes(ft.getProcessedData(!0).modified.getColumn("y") || [], !0); N ?? (N = { dataMin: Number.MAX_VALUE, dataMax: -Number.MAX_VALUE }), Ve(tt.dataMin) && Ve(tt.dataMax) && (N.dataMin = Math.min(tt.dataMin, N.dataMin), N.dataMax = Math.max(tt.dataMax, N.dataMax)) } m.allExtremes = N } let { dataMin: V, dataMax: W, min: F, max: lt } = re(m.getExtremes(), N || {}), X = c.parse(b.min), $ = c.parse(b.max), R = V ?? X, j = W ?? $, rt = E - z, K = m.categories ? 0 : Math.min(rt, j - R), J = R - K * (oe(X) ? 0 : b.minPadding), ut = j + K * (oe($) ? 0 : b.maxPadding), _t = m.allowZoomOutside || k === 1 || n !== "zoom" && k > 1, It = Math.min(X ?? J, J, _t ? F : J), vt = Math.max($ ?? ut, ut, _t ? lt : ut); (!m.isOrdinal || k !== 1 || o) && (z < It && (z = It, k >= 1 && (E = z + rt)), E > vt && (E = vt, k >= 1 && (z = E - rt)), (o || m.series.length && (z !== F || E !== lt) && z >= It && E <= vt) && (r ? r[m.coll].push({ axis: m, min: z, max: E }) : (m.isPanning = n !== "zoom", m.isPanning && (u = !0), m.setExtremes(o ? void 0 : z, o ? void 0 : E, !1, !1, { move: P, trigger: n, scale: k }), !o && (z > It || E < vt) && n !== "mousewheel" && (p = !0)), d = !0), this.hasCartesianSeries || o || n === "mousewheel" || (p = !0), i && (this[f ? "mouseDownX" : "mouseDownY"] = i[f ? "chartX" : "chartY"])) } return d && (r ? Z(this, "selection", r, () => { delete t.selection, t.trigger = "zoom", this.transform(t) }) : (!p || u || this.resetZoomButton ? !p && this.resetZoomButton && (this.resetZoomButton = this.resetZoomButton.destroy()) : this.showResetZoom(), this.redraw(n === "zoom" && (this.options.chart.animation ?? this.pointCount < 100)))), d } } re(we.prototype, { callbacks: [], collectionsWithInit: { xAxis: [we.prototype.addAxis, [!0]], yAxis: [we.prototype.addAxis, [!1]], series: [we.prototype.addSeries] }, collectionsWithUpdate: ["xAxis", "yAxis", "series"], propsRequireDirtyBox: ["backgroundColor", "borderColor", "borderWidth", "borderRadius", "plotBackgroundColor", "plotBackgroundImage", "plotBorderColor", "plotBorderWidth", "plotShadow", "shadow"], propsRequireReflow: ["margin", "marginTop", "marginRight", "marginBottom", "marginLeft", "spacing", "spacingTop", "spacingRight", "spacingBottom", "spacingLeft"], propsRequireUpdateSeries: ["chart.inverted", "chart.polar", "chart.ignoreHiddenSeries", "chart.type", "colors", "plotOptions", "time", "tooltip"] }); let xr = we, { stop: hu } = mt, { composed: du } = C, { addEvent: ae, createElement: ks, css: br, defined: vr, erase: cu, merge: Xn, pushUnique: Yn } = I; function pu() { let h = this.scrollablePlotArea; (this.scrollablePixelsX || this.scrollablePixelsY) && !h && (this.scrollablePlotArea = h = new ki(this)), h == null || h.applyFixed() } function Hn() { this.chart.scrollablePlotArea && (this.chart.scrollablePlotArea.isDirty = !0) } class ki { static compose(t, e, i) { Yn(du, this.compose) && (ae(t, "afterInit", Hn), ae(e, "afterSetChartSize", s => this.afterSetSize(s.target, s)), ae(e, "render", pu), ae(i, "show", Hn)) } static afterSetSize(t, e) { let i, s, o, { minWidth: r, minHeight: a } = t.options.chart.scrollablePlotArea || {}, { clipBox: n, plotBox: l, inverted: c, renderer: d } = t; if (!d.forExport && (r ? (t.scrollablePixelsX = i = Math.max(0, r - t.chartWidth), i && (t.scrollablePlotBox = Xn(t.plotBox), l.width = t.plotWidth += i, n[c ? "height" : "width"] += i, o = !0)) : a && (t.scrollablePixelsY = s = Math.max(0, a - t.chartHeight), vr(s) && (t.scrollablePlotBox = Xn(t.plotBox), l.height = t.plotHeight += s, n[c ? "width" : "height"] += s, o = !1)), vr(o) && !e.skipAxes)) for (let p of t.axes) (p.horiz === o || t.hasParallelCoordinates && p.coll === "yAxis") && (p.setAxisSize(), p.setAxisTranslation()) } constructor(t) { var u; let e, i = t.options.chart, s = pi.getRendererType(), o = i.scrollablePlotArea || {}, r = this.moveFixedElements.bind(this), a = { WebkitOverflowScrolling: "touch", overflowX: "hidden", overflowY: "hidden" }; t.scrollablePixelsX && (a.overflowX = "auto"), t.scrollablePixelsY && (a.overflowY = "auto"), this.chart = t; let n = this.parentDiv = ks("div", { className: "highcharts-scrolling-parent" }, { position: "relative" }, t.renderTo), l = this.scrollingContainer = ks("div", { className: "highcharts-scrolling" }, a, n), c = this.innerContainer = ks("div", { className: "highcharts-inner-container" }, void 0, l), d = this.fixedDiv = ks("div", { className: "highcharts-fixed" }, { position: "absolute", overflow: "hidden", pointerEvents: "none", zIndex: (((u = i.style) == null ? void 0 : u.zIndex) || 0) + 2, top: 0 }, void 0, !0), p = this.fixedRenderer = new s(d, t.chartWidth, t.chartHeight, i.style); this.mask = p.path().attr({ fill: i.backgroundColor || "#fff", "fill-opacity": o.opacity ?? .85, zIndex: -1 }).addClass("highcharts-scrollable-mask").add(), l.parentNode.insertBefore(d, l), br(t.renderTo, { overflow: "visible" }), ae(t, "afterShowResetZoom", r), ae(t, "afterApplyDrilldown", r), ae(t, "afterLayOutTitles", r), ae(l, "scroll", () => { let { pointer: g, hoverPoint: m } = t; g && (delete g.chartPosition, m && (e = m), g.runPointActions(void 0, e, !0)) }), c.appendChild(t.container) } applyFixed() { var T; let { chart: t, fixedRenderer: e, isDirty: i, scrollingContainer: s } = this, { axisOffset: o, chartWidth: r, chartHeight: a, container: n, plotHeight: l, plotLeft: c, plotTop: d, plotWidth: p, scrollablePixelsX: u = 0, scrollablePixelsY: g = 0 } = t, { scrollPositionX: m = 0, scrollPositionY: f = 0 } = t.options.chart.scrollablePlotArea || {}, y = r + u, x = a + g; e.setSize(r, a), (i ?? !0) && (this.isDirty = !1, this.moveFixedElements()), hu(t.container), br(n, { width: `${y}px`, height: `${x}px` }), t.renderer.boxWrapper.attr({ width: y, height: x, viewBox: [0, 0, y, x].join(" ") }), (T = t.chartBackground) == null || T.attr({ width: y, height: x }), br(s, { width: `${r}px`, height: `${a}px` }), vr(i) || (s.scrollLeft = u * m, s.scrollTop = g * f); let b = d - o[0] - 1, w = c - o[3] - 1, v = d + l + o[2] + 1, S = c + p + o[1] + 1, A = c + p - u, M = d + l - g, k = [["M", 0, 0]]; u ? k = [["M", 0, b], ["L", c - 1, b], ["L", c - 1, v], ["L", 0, v], ["Z"], ["M", A, b], ["L", r, b], ["L", r, v], ["L", A, v], ["Z"]] : g && (k = [["M", w, 0], ["L", w, d - 1], ["L", S, d - 1], ["L", S, 0], ["Z"], ["M", w, M], ["L", w, a], ["L", S, a], ["L", S, M], ["Z"]]), t.redrawTrigger !== "adjustHeight" && this.mask.attr({ d: k }) } moveFixedElements() { let t, { container: e, inverted: i, scrollablePixelsX: s, scrollablePixelsY: o } = this.chart, r = this.fixedRenderer, a = ki.fixedSelectors; if (s && !i ? t = ".highcharts-yaxis" : s && i || o && !i ? t = ".highcharts-xaxis" : o && i && (t = ".highcharts-yaxis"), t && !(this.chart.hasParallelCoordinates && t === ".highcharts-yaxis")) for (let n of [`${t}:not(.highcharts-radial-axis)`, `${t}-labels:not(.highcharts-radial-axis-labels)`]) Yn(a, n); else for (let n of [".highcharts-xaxis", ".highcharts-yaxis"]) for (let l of [`${n}:not(.highcharts-radial-axis)`, `${n}-labels:not(.highcharts-radial-axis-labels)`]) cu(a, l); for (let n of a) [].forEach.call(e.querySelectorAll(n), l => { (l.namespaceURI === r.SVG_NS ? r.box : r.box.parentNode).appendChild(l), l.style.pointerEvents = "auto" }) } } ki.fixedSelectors = [".highcharts-breadcrumbs-group", ".highcharts-contextbutton", ".highcharts-caption", ".highcharts-credits", ".highcharts-drillup-button", ".highcharts-legend", ".highcharts-legend-checkbox", ".highcharts-navigator-series", ".highcharts-navigator-xaxis", ".highcharts-navigator-yaxis", ".highcharts-navigator", ".highcharts-range-selector-group", ".highcharts-reset-zoom", ".highcharts-scrollbar", ".highcharts-subtitle", ".highcharts-title"]; let { format: uu } = At, { series: gu } = G, { destroyObjectProperties: mu, fireEvent: Gn, getAlignFactor: wr, isNumber: Sr, pick: Ai } = I, Vn = class { constructor(h, t, e, i, s) { let o = h.chart.inverted, r = h.reversed; this.axis = h; let a = this.isNegative = !!e != !!r; this.options = t = t || {}, this.x = i, this.total = null, this.cumulative = null, this.points = {}, this.hasValidPoints = !1, this.stack = s, this.leftCliff = 0, this.rightCliff = 0, this.alignOptions = { align: t.align || (o ? a ? "left" : "right" : "center"), verticalAlign: t.verticalAlign || (o ? "middle" : a ? "bottom" : "top"), y: t.y, x: t.x }, this.textAlign = t.textAlign || (o ? a ? "right" : "left" : "center") } destroy() { mu(this, this.axis) } render(h) { let t = this.axis.chart, e = this.options, i = e.format, s = i ? uu(i, this, t) : e.formatter.call(this); if (this.label) this.label.attr({ text: s, visibility: "hidden" }); else { this.label = t.renderer.label(s, null, void 0, e.shape, void 0, void 0, e.useHTML, !1, "stack-labels"); let o = { r: e.borderRadius || 0, text: s, padding: Ai(e.padding, 5), visibility: "hidden" }; t.styledMode || (o.fill = e.backgroundColor, o.stroke = e.borderColor, o["stroke-width"] = e.borderWidth, this.label.css(e.style || {})), this.label.attr(o), this.label.added || this.label.add(h) } this.label.labelrank = t.plotSizeY, Gn(this, "afterRender") } setOffset(h, t, e, i, s, o) { let { alignOptions: r, axis: a, label: n, options: l, textAlign: c } = this, d = a.chart, p = this.getStackBox({ xOffset: h, width: t, boxBottom: e, boxTop: i, defaultX: s, xAxis: o }), { verticalAlign: u } = r; if (n && p) { let g = n.getBBox(void 0, 0), m = n.padding, f = Ai(l.overflow, "justify") === "justify", y; r.x = l.x || 0, r.y = l.y || 0; let { x, y: b } = this.adjustStackPosition({ labelBox: g, verticalAlign: u, textAlign: c }); p.x -= x, p.y -= b, n.align(r, !1, p), (y = d.isInsidePlot(n.alignAttr.x + r.x + x, n.alignAttr.y + r.y + b)) || (f = !1), f && gu.prototype.justifyDataLabel.call(a, n, r, n.alignAttr, g, p), n.attr({ x: n.alignAttr.x, y: n.alignAttr.y, rotation: l.rotation, rotationOriginX: g.width * wr(l.textAlign || "center"), rotationOriginY: g.height / 2 }), Ai(!f && l.crop, !0) && (y = Sr(n.x) && Sr(n.y) && d.isInsidePlot(n.x - m + (n.width || 0), n.y) && d.isInsidePlot(n.x + m, n.y)), n[y ? "show" : "hide"]() } Gn(this, "afterSetOffset", { xOffset: h, width: t }) } adjustStackPosition({ labelBox: h, verticalAlign: t, textAlign: e }) { return { x: h.width / 2 + h.width / 2 * (2 * wr(e) - 1), y: h.height / 2 * 2 * (1 - wr(t)) } } getStackBox(h) { let t = this.axis, e = t.chart, { boxTop: i, defaultX: s, xOffset: o, width: r, boxBottom: a } = h, n = t.stacking.usePercentage ? 100 : Ai(i, this.total, 0), l = t.toPixels(n), c = h.xAxis || e.xAxis[0], d = Ai(s, c.translate(this.x)) + o, p = Math.abs(l - t.toPixels(a || Sr(t.min) && t.logarithmic && t.logarithmic.lin2log(t.min) || 0)), u = e.inverted, g = this.isNegative; return u ? { x: (g ? l : l - p) - e.plotLeft, y: c.height - d - r + c.top - e.plotTop, width: p, height: r } : { x: d + c.transB - e.plotLeft, y: (g ? l - p : l) - e.plotTop, width: r, height: p } } }, { getDeferredAnimation: fu } = mt, { series: { prototype: yu } } = G, { addEvent: Zn, correctFloat: Ci, defined: $n, destroyObjectProperties: xu, fireEvent: bu, isNumber: Mr, objectEach: Se, pick: kr } = I; function vu() { let h = this.inverted; this.axes.forEach(t => { var e; (e = t.stacking) != null && e.stacks && t.hasVisibleSeries && (t.stacking.oldStacks = t.stacking.stacks) }), this.series.forEach(t => { var i; let e = ((i = t.xAxis) == null ? void 0 : i.options) || {}; t.options.stacking && t.reserveSpace() && (t.stackKey = [t.type, kr(t.options.stack, ""), h ? e.top : e.left, h ? e.height : e.width].join(",")) }) } function wu() { var t; let h = this.stacking; if (h) { let e = h.stacks; Se(e, (i, s) => { xu(i), delete e[s] }), (t = h.stackTotalGroup) == null || t.destroy() } } function Su() { this.stacking || (this.stacking = new Pu(this)) } function Mu(h, t, e, i) { return !$n(h) || h.x !== t || i && h.stackKey !== i ? h = { x: t, index: 0, key: i, stackKey: i } : h.index++, h.key = [e, t, h.index].join(","), h } function ku() { let h, t = this, e = t.yAxis, i = t.stackKey || "", s = e.stacking.stacks, o = t.getColumn("x", !0), r = t.options.stacking, a = t[r + "Stacker"]; a && [i, "-" + i].forEach(n => { var u; let l = o.length, c, d, p; for (; l--;)c = o[l], h = t.getStackIndicator(h, c, t.index, n), d = (u = s[n]) == null ? void 0 : u[c], (p = d == null ? void 0 : d.points[h.key || ""]) && a.call(t, p, d, l) }) } function Au(h, t, e) { let i = t.total ? 100 / t.total : 0; h[0] = Ci(h[0] * i), h[1] = Ci(h[1] * i), this.stackedYData[e] = h[1] } function Cu(h) { (this.is("column") || this.is("columnrange")) && (this.options.centerInCategory && this.chart.series.length > 1 ? yu.setStackedPoints.call(this, h, "group") : h.stacking.resetStacks()) } function Tu(h, t) { var M, k; let e, i, s, o, r, a, n, l = t || this.options.stacking; if (!l || !this.reserveSpace() || ({ group: "xAxis" }[l] || "yAxis") !== h.coll) return; let c = this.getColumn("x", !0), d = this.getColumn(this.pointValKey || "y", !0), p = [], u = d.length, g = this.options, m = g.threshold || 0, f = g.startFromThreshold ? m : 0, y = g.stack, x = t ? `${this.type},${l}` : this.stackKey || "", b = "-" + x, w = this.negStacks, v = h.stacking, S = v.stacks, A = v.oldStacks; for (v.stacksTouched += 1, n = 0; n < u; n++) { let T = c[n] || 0, P = d[n], L = Mr(P) && P || 0; a = (e = this.getStackIndicator(e, T, this.index)).key || "", S[r = (i = w && L < (f ? 0 : m)) ? b : x] || (S[r] = {}), S[r][T] || ((M = A[r]) != null && M[T] ? (S[r][T] = A[r][T], S[r][T].total = null) : S[r][T] = new Vn(h, h.options.stackLabels, !!i, T, y)), s = S[r][T], P !== null ? (s.points[a] = s.points[this.index] = [kr(s.cumulative, f)], $n(s.cumulative) || (s.base = a), s.touched = v.stacksTouched, e.index > 0 && this.singleStacks === !1 && (s.points[a][0] = s.points[this.index + "," + T + ",0"][0])) : (delete s.points[a], delete s.points[this.index]); let O = s.total || 0; l === "percent" ? (o = i ? x : b, O = w && ((k = S[o]) != null && k[T]) ? (o = S[o][T]).total = Math.max(o.total || 0, O) + Math.abs(L) : Ci(O + Math.abs(L))) : l === "group" ? Mr(P) && O++ : O = Ci(O + L), l === "group" ? s.cumulative = (O || 1) - 1 : s.cumulative = Ci(kr(s.cumulative, f) + L), s.total = O, P !== null && (s.points[a].push(s.cumulative), p[n] = s.cumulative, s.hasValidPoints = !0) } l === "percent" && (v.usePercentage = !0), l !== "group" && (this.stackedYData = p), v.oldStacks = {} } class Pu { constructor(t) { this.oldStacks = {}, this.stacks = {}, this.stacksTouched = 0, this.axis = t } buildStacks() { let t, e, i = this.axis, s = i.series, o = i.coll === "xAxis", r = i.options.reversedStacks, a = s.length; for (this.resetStacks(), this.usePercentage = !1, e = a; e--;)t = s[r ? e : a - e - 1], o && t.setGroupedPoints(i), t.setStackedPoints(i); if (!o) for (e = 0; e < a; e++)s[e].modifyStacks(); bu(i, "afterBuildStacks") } cleanStacks() { this.oldStacks && (this.stacks = this.oldStacks, Se(this.stacks, t => { Se(t, e => { e.cumulative = e.total }) })) } resetStacks() { Se(this.stacks, t => { Se(t, (e, i) => { Mr(e.touched) && e.touched < this.stacksTouched ? (e.destroy(), delete t[i]) : (e.total = null, e.cumulative = null) }) }) } renderStackTotals() { var a; let t = this.axis, e = t.chart, i = e.renderer, s = this.stacks, o = fu(e, ((a = t.options.stackLabels) == null ? void 0 : a.animation) || !1), r = this.stackTotalGroup = this.stackTotalGroup || i.g("stack-labels").attr({ zIndex: 6, opacity: 0 }).add(); r.translate(e.plotLeft, e.plotTop), Se(s, n => { Se(n, l => { l.render(r) }) }), r.animate({ opacity: 1 }, o) } } (oo || (oo = {})).compose = function (h, t, e) { let i = t.prototype, s = e.prototype; i.getStacks || (Zn(h, "init", Su), Zn(h, "destroy", wu), i.getStacks = vu, s.getStackIndicator = Mu, s.modifyStacks = ku, s.percentStacker = Au, s.setGroupedPoints = Cu, s.setStackedPoints = Tu) }; let Lu = oo, { defined: Ou, merge: Kn, isObject: Eu } = I; class qn extends Tt { drawGraph() { let t = this.options, e = (this.gappedPath || this.getGraphPath).call(this), i = this.chart.styledMode;[this, ...this.zones].forEach((s, o) => { let r, a = s.graph, n = a ? "animate" : "attr", l = s.dashStyle || t.dashStyle; a ? (a.endX = this.preventGraphAnimation ? null : e.xMap, a.animate({ d: e })) : e.length && (s.graph = a = this.chart.renderer.path(e).addClass("highcharts-graph" + (o ? ` highcharts-zone-graph-${o - 1} ` : " ") + (o && s.className || "")).attr({ zIndex: 1 }).add(this.group)), a && !i && (r = { stroke: !o && t.lineColor || s.color || this.color || "#cccccc", "stroke-width": t.lineWidth || 0, fill: this.fillGraph && this.color || "none" }, l ? r.dashstyle = l : t.linecap !== "square" && (r["stroke-linecap"] = r["stroke-linejoin"] = "round"), a[n](r).shadow(t.shadow && Kn({ filterUnits: "userSpaceOnUse" }, Eu(t.shadow) ? t.shadow : {}))), a && (a.startX = e.xMap, a.isArea = e.isArea) }) } getGraphPath(t, e, i) { let s = this, o = s.options, r = [], a = [], n, l = o.step, c = (t = t || s.points).reversed; return c && t.reverse(), (l = { right: 1, center: 2 }[l] || l && 3) && c && (l = 4 - l), (t = this.getValidPoints(t, !1, o.nullInteraction || !(o.connectNulls && !e && !i))).forEach(function (d, p) { let u, g = d.plotX, m = d.plotY, f = t[p - 1], y = d.isNull || typeof m != "number"; (d.leftCliff || f != null && f.rightCliff) && !i && (n = !0), y && !Ou(e) && p > 0 ? n = !o.connectNulls : y && !e ? n = !0 : (p === 0 || n ? u = [["M", d.plotX, d.plotY]] : s.getPointSpline ? u = [s.getPointSpline(t, d, p)] : l ? (u = l === 1 ? [["L", f.plotX, m]] : l === 2 ? [["L", (f.plotX + g) / 2, f.plotY], ["L", (f.plotX + g) / 2, m]] : [["L", g, f.plotY]]).push(["L", g, m]) : u = [["L", g, m]], a.push(d.x), l && (a.push(d.x), l === 2 && a.push(d.x)), r.push.apply(r, u), n = !1) }), r.xMap = a, s.graphPath = r, r } } qn.defaultOptions = Kn(Tt.defaultOptions, { legendSymbol: "lineMarker" }), G.registerSeriesType("line", qn); let { seriesTypes: { line: Ar } } = G, { extend: Iu, merge: Du, objectEach: Bu, pick: As } = I; class Cr extends Ar { drawGraph() { this.areaPath = [], super.drawGraph.apply(this); let { areaPath: t, options: e } = this;[this, ...this.zones].forEach((i, s) => { let o = {}, r = i.fillColor || e.fillColor, a = i.area, n = a ? "animate" : "attr"; a ? (a.endX = this.preventGraphAnimation ? null : t.xMap, a.animate({ d: t })) : (o.zIndex = 0, (a = i.area = this.chart.renderer.path(t).addClass("highcharts-area" + (s ? ` highcharts-zone-area-${s - 1} ` : " ") + (s && i.className || "")).add(this.group)).isArea = !0), this.chart.styledMode || (o.fill = r || i.color || this.color, o["fill-opacity"] = r ? 1 : e.fillOpacity ?? .75, a.css({ pointerEvents: this.stickyTracking ? "none" : "auto" })), a[n](o), a.startX = t.xMap, a.shiftUnit = e.step ? 2 : 1 }) } getGraphPath(t) { let e, i, s, o = Ar.prototype.getGraphPath, r = this.options, a = r.stacking, n = this.yAxis, l = [], c = [], d = this.index, p = n.stacking.stacks[this.stackKey], u = r.threshold, g = Math.round(n.getThreshold(r.threshold)), m = As(r.connectNulls, a === "percent"), f = function (S, A, M) { let k = t[S], T = a && p[k.x].points[d], P = k[M + "Null"] || 0, L = k[M + "Cliff"] || 0, O, B, D = !0; L || P ? (O = (P ? T[0] : T[1]) + L, B = T[0] + L, D = !!P) : !a && t[A] && t[A].isNull && (O = B = u), O !== void 0 && (c.push({ plotX: e, plotY: O === null ? g : n.getThreshold(O), isNull: D, isCliff: !0 }), l.push({ plotX: e, plotY: B === null ? g : n.getThreshold(B), doCurve: !1 })) }; t = t || this.points, a && (t = this.getStackPoints(t)); for (let S = 0, A = t.length; S < A; ++S)a || (t[S].leftCliff = t[S].rightCliff = t[S].leftNull = t[S].rightNull = void 0), i = t[S].isNull, e = As(t[S].rectPlotX, t[S].plotX), s = a ? As(t[S].yBottom, g) : g, (!i || m) && (m || f(S, S - 1, "left"), i && !a && m || (c.push(t[S]), l.push({ x: S, plotX: e, plotY: s })), m || f(S, S + 1, "right")); let y = o.call(this, c, !0, !0); l.reversed = !0; let x = o.call(this, l, !0, !0), b = x[0]; b && b[0] === "M" && (x[0] = ["L", b[1], b[2]]); let w = y.concat(x); w.length && w.push(["Z"]); let v = o.call(this, c, !1, m); return this.chart.series.length > 1 && a && c.some(S => S.isCliff) && (w.hasStackedCliffs = v.hasStackedCliffs = !0), w.xMap = y.xMap, this.areaPath = w, v } getStackPoints(t) { let e = this, i = [], s = [], o = this.xAxis, r = this.yAxis, a = r.stacking.stacks[this.stackKey], n = {}, l = r.series, c = l.length, d = r.options.reversedStacks ? 1 : -1, p = l.indexOf(e); if (t = t || this.points, this.options.stacking) { for (let g = 0; g < t.length; g++)t[g].leftNull = t[g].rightNull = void 0, n[t[g].x] = t[g]; Bu(a, function (g, m) { g.total !== null && s.push(m) }), s.sort(function (g, m) { return g - m }); let u = l.map(g => g.visible); s.forEach(function (g, m) { let f = 0, y, x; if (n[g] && !n[g].isNull) i.push(n[g]), [-1, 1].forEach(function (b) { let w = b === 1 ? "rightNull" : "leftNull", v = a[s[m + b]], S = 0; if (v) { let A = p; for (; A >= 0 && A < c;) { let M = l[A].index; !(y = v.points[M]) && (M === e.index ? n[g][w] = !0 : u[A] && (x = a[g].points[M]) && (S -= x[1] - x[0])), A += d } } n[g][b === 1 ? "rightCliff" : "leftCliff"] = S }); else { let b = p; for (; b >= 0 && b < c;) { let w = l[b].index; if (y = a[g].points[w]) { f = y[1]; break } b += d } f = As(f, 0), f = r.translate(f, 0, 1, 0, 1), i.push({ isNull: !0, plotX: o.translate(g, 0, 0, 0, 1), x: g, plotY: f, yBottom: f }) } }) } return i } } Cr.defaultOptions = Du(Ar.defaultOptions, { threshold: 0, legendSymbol: "areaMarker" }), Iu(Cr.prototype, { singleStacks: !1 }), G.registerSeriesType("area", Cr); let { line: _n } = G.seriesTypes, { merge: zu, pick: Cs } = I; class Tr extends _n { getPointSpline(t, e, i) { let s, o, r, a, n = e.plotX || 0, l = e.plotY || 0, c = t[i - 1], d = t[i + 1]; function p(g) { return g && !g.isNull && g.doCurve !== !1 && !e.isCliff } if (p(c) && p(d)) { let g = c.plotX || 0, m = c.plotY || 0, f = d.plotX || 0, y = d.plotY || 0, x = 0; s = (1.5 * n + g) / 2.5, o = (1.5 * l + m) / 2.5, r = (1.5 * n + f) / 2.5, a = (1.5 * l + y) / 2.5, r !== s && (x = (a - o) * (r - n) / (r - s) + l - a), o += x, a += x, o > m && o > l ? (o = Math.max(m, l), a = 2 * l - o) : o < m && o < l && (o = Math.min(m, l), a = 2 * l - o), a > y && a > l ? (a = Math.max(y, l), o = 2 * l - a) : a < y && a < l && (a = Math.min(y, l), o = 2 * l - a), e.rightContX = r, e.rightContY = a, e.controlPoints = { low: [s, o], high: [r, a] } } let u = ["C", Cs(c.rightContX, c.plotX, 0), Cs(c.rightContY, c.plotY, 0), Cs(s, n, 0), Cs(o, l, 0), n, l]; return c.rightContX = c.rightContY = void 0, u } } Tr.defaultOptions = zu(_n.defaultOptions), G.registerSeriesType("spline", Tr); let Jn = Tr, { area: Nu, area: { prototype: Pr } } = G.seriesTypes, { extend: Uu, merge: ju } = I; class Lr extends Jn { } Lr.defaultOptions = ju(Jn.defaultOptions, Nu.defaultOptions), Uu(Lr.prototype, { getGraphPath: Pr.getGraphPath, getStackPoints: Pr.getStackPoints, drawGraph: Pr.drawGraph }), G.registerSeriesType("areaspline", Lr); let { animObject: Ru } = mt, { parse: Wu } = _, { noop: Fu } = C, { clamp: Ts, crisp: Ps, defined: Qn, extend: tl, fireEvent: el, isArray: il, isNumber: Ls, merge: Or, pick: Ti, objectEach: Xu } = I; class Os extends Tt { animate(t) { let e, i, s = this, o = this.yAxis, r = o.pos, a = o.reversed, n = s.options, { clipOffset: l, inverted: c } = this.chart, d = {}, p = c ? "translateX" : "translateY"; t && l ? (d.scaleY = .001, i = Ts(o.toPixels(n.threshold || 0), r, r + o.len), c ? d.translateX = (i += a ? -Math.floor(l[0]) : Math.ceil(l[2])) - o.len : d.translateY = i += a ? Math.ceil(l[0]) : -Math.floor(l[2]), s.clipBox && s.setClip(), s.group.attr(d)) : (e = Number(s.group.attr(p)), s.group.animate({ scaleY: 1 }, tl(Ru(s.options.animation), { step: function (u, g) { s.group && (d[p] = e + g.pos * (r - e), s.group.attr(d)) } }))) } init(t, e) { super.init.apply(this, arguments); let i = this; (t = i.chart).hasRendered && t.series.forEach(function (s) { s.type === i.type && (s.isDirty = !0) }) } getColumnMetrics() { var m, f; let t = this, e = t.options, i = t.xAxis, s = t.yAxis, o = i.options.reversedStacks, r = i.reversed && !o || !i.reversed && o, a = {}, n, l = 0; e.grouping === !1 ? l = 1 : t.chart.series.forEach(function (y) { let x, b = y.yAxis, w = y.options; y.type === t.type && y.reserveSpace() && s.len === b.len && s.pos === b.pos && (w.stacking && w.stacking !== "group" ? (a[n = y.stackKey] === void 0 && (a[n] = l++), x = a[n]) : w.grouping !== !1 && (x = l++), y.columnIndex = x) }); let c = Math.min(Math.abs(i.transA) * (!((m = i.brokenAxis) != null && m.hasBreaks) && ((f = i.ordinal) == null ? void 0 : f.slope) || e.pointRange || i.closestPointRange || i.tickInterval || 1), i.len), d = c * e.groupPadding, p = (c - 2 * d) / (l || 1), u = Math.min(e.maxPointWidth || i.len, Ti(e.pointWidth, p * (1 - 2 * e.pointPadding))), g = (t.columnIndex || 0) + +!!r; return t.columnMetrics = { width: u, offset: (p - u) / 2 + (d + g * p - c / 2) * (r ? -1 : 1), paddedWidth: p, columnCount: l }, t.columnMetrics } crispCol(t, e, i, s) { let o = this.borderWidth, r = this.chart.inverted; return s = Ps(e + s, o, r) - (e = Ps(e, o, r)), this.options.crisp && (i = Ps(t + i, o) - (t = Ps(t, o))), { x: t, y: e, width: i, height: s } } adjustForMissingColumns(t, e, i, s) { var o; if (!i.isNull && s.columnCount > 1) { let r = this.xAxis.series.filter(c => c.visible).map(c => c.index), a = 0, n = 0; Xu((o = this.xAxis.stacking) == null ? void 0 : o.stacks, c => { var g; let d = typeof i.x == "number" ? (g = c[i.x.toString()]) == null ? void 0 : g.points : void 0, p = d == null ? void 0 : d[this.index], u = {}; if (d && il(p)) { let m = this.index, f = Object.keys(d).filter(y => !y.match(",") && d[y] && d[y].length > 1).map(parseFloat).filter(y => r.indexOf(y) !== -1).filter(y => { let x = this.chart.series[y].options, b = x.stacking && x.stack; if (Qn(b)) { if (Ls(u[b])) return m === y && (m = u[b]), !1; u[b] = y } return !0 }).sort((y, x) => x - y); a = f.indexOf(m), n = f.length } }), a = this.xAxis.reversed ? n - 1 - a : a; let l = (n - 1) * s.paddedWidth + e; t = (i.plotX || 0) + l / 2 - e - a * s.paddedWidth } return t } translate() { let t = this, e = t.chart, i = t.options, s = t.dense = t.closestPointRange * t.xAxis.transA < 2, o = t.borderWidth = Ti(i.borderWidth, +!s), r = t.xAxis, a = t.yAxis, n = i.threshold, l = Ti(i.minPointLength, 5), c = t.getColumnMetrics(), d = c.width, p = t.pointXOffset = c.offset, u = t.dataMin, g = t.dataMax, m = t.translatedThreshold = a.getThreshold(n), f = t.barW = Math.max(d, 1 + 2 * o); i.pointPadding && i.crisp && (f = Math.ceil(f)), Tt.prototype.translate.apply(t), t.points.forEach(function (y) { let x = Ti(y.yBottom, m), b = 999 + Math.abs(x), w = y.plotX || 0, v = Ts(y.plotY, -b, a.len + b), S, A = Math.min(v, x), M = Math.max(v, x) - A, k = d, T = w + p, P = f; l && Math.abs(M) < l && (M = l, S = !a.reversed && !y.negative || a.reversed && y.negative, Ls(n) && Ls(g) && y.y === n && g <= n && (a.min || 0) < n && (u !== g || (a.max || 0) <= n) && (S = !S, y.negative = !y.negative), A = Math.abs(A - m) > l ? x - l : m - (S ? l : 0)), Qn(y.options.pointWidth) && (T -= Math.round(((k = P = Math.ceil(y.options.pointWidth)) - d) / 2)), i.centerInCategory && (T = t.adjustForMissingColumns(T, k, y, c)), y.barX = T, y.pointWidth = k, y.tooltipPos = e.inverted ? [Ts(a.len + a.pos - e.plotLeft - v, a.pos - e.plotLeft, a.len + a.pos - e.plotLeft), r.len + r.pos - e.plotTop - T - P / 2, M] : [r.left - e.plotLeft + T + P / 2, Ts(v + a.pos - e.plotTop, a.pos - e.plotTop, a.len + a.pos - e.plotTop), M], y.shapeType = t.pointClass.prototype.shapeType || "roundedRect", y.shapeArgs = t.crispCol(T, A, P, y.isNull ? 0 : M) }), el(this, "afterColumnTranslate") } drawGraph() { this.group[this.dense ? "addClass" : "removeClass"]("highcharts-dense-data") } pointAttribs(t, e) { let i = this.options, s = this.pointAttrToOptions || {}, o = s.stroke || "borderColor", r = s["stroke-width"] || "borderWidth", a, n, l, c = t && t.color || this.color, d = t && t[o] || i[o] || c, p = t && t.options.dashStyle || i.dashStyle, u = t && t[r] || i[r] || this[r] || 0, g = t != null && t.isNull && i.nullInteraction ? 0 : (t == null ? void 0 : t.opacity) ?? i.opacity ?? 1; t && this.zones.length && (n = t.getZone(), c = t.options.color || n && (n.color || t.nonZonedColor) || this.color, n && (d = n.borderColor || d, p = n.dashStyle || p, u = n.borderWidth || u)), e && t && (l = (a = Or(i.states[e], t.options.states && t.options.states[e] || {})).brightness, c = a.color || l !== void 0 && Wu(c).brighten(a.brightness).get() || c, d = a[o] || d, u = a[r] || u, p = a.dashStyle || p, g = Ti(a.opacity, g)); let m = { fill: c, stroke: d, "stroke-width": u, opacity: g }; return p && (m.dashstyle = p), m } drawPoints(t = this.points) { let e, i = this, s = this.chart, o = i.options, r = o.nullInteraction, a = s.renderer, n = o.animationLimit || 250; t.forEach(function (l) { let c = l.plotY, d = l.graphic, p = !!d, u = d && s.pointCount < n ? "animate" : "attr"; Ls(c) && (l.y !== null || r) ? (e = l.shapeArgs, d && l.hasNewShapeType() && (d = d.destroy()), i.enabledDataSorting && (l.startXPos = i.xAxis.reversed ? -(e && e.width || 0) : i.xAxis.width), !d && (l.graphic = d = a[l.shapeType](e).add(l.group || i.group), d && i.enabledDataSorting && s.hasRendered && s.pointCount < n && (d.attr({ x: l.startXPos }), p = !0, u = "animate")), d && p && d[u](Or(e)), s.styledMode || d[u](i.pointAttribs(l, l.selected && "select")).shadow(l.allowShadow !== !1 && o.shadow), d && (d.addClass(l.getClassName(), !0), d.attr({ visibility: l.visible ? "inherit" : "hidden" }))) : d && (l.graphic = d.destroy()) }) } drawTracker(t = this.points) { let e, i = this, s = i.chart, o = s.pointer, r = function (a) { o == null || o.normalize(a); let n = o == null ? void 0 : o.getPointFromEvent(a); o && n && i.options.enableMouseTracking && (s.isInsidePlot(a.chartX - s.plotLeft, a.chartY - s.plotTop, { visiblePlotOnly: !0 }) || o != null && o.inClass(a.target, "highcharts-data-label")) && (o.isDirectTouch = !0, n.onMouseOver(a)) }; t.forEach(function (a) { e = il(a.dataLabels) ? a.dataLabels : a.dataLabel ? [a.dataLabel] : [], a.graphic && (a.graphic.element.point = a), e.forEach(function (n) { (n.div || n.element).point = a }) }), i._hasTracking || (i.trackerGroups.forEach(function (a) { i[a] && (i[a].addClass("highcharts-tracker").on("mouseover", r).on("mouseout", function (n) { o == null || o.onTrackerMouseOut(n) }).on("touchstart", r), !s.styledMode && i.options.cursor && i[a].css({ cursor: i.options.cursor })) }), i._hasTracking = !0), el(this, "afterDrawTracker") } remove() { let t = this, e = t.chart; e.hasRendered && e.series.forEach(function (i) { i.type === t.type && (i.isDirty = !0) }), Tt.prototype.remove.apply(t, arguments) } } Os.defaultOptions = Or(Tt.defaultOptions, { borderRadius: 3, centerInCategory: !1, groupPadding: .2, marker: null, pointPadding: .1, minPointLength: 0, cropThreshold: 50, pointRange: null, states: { hover: { halo: !1, brightness: .1 }, select: { color: "#cccccc", borderColor: "#000000" } }, dataLabels: { align: void 0, verticalAlign: void 0, y: void 0 }, startFromThreshold: !0, stickyTracking: !1, tooltip: { distance: 6 }, threshold: 0, borderColor: "#ffffff" }), tl(Os.prototype, { directTouch: !0, getSymbol: Fu, negStacks: !0, trackerGroups: ["group", "dataLabelsGroup"] }), G.registerSeriesType("column", Os); let Es = Os, { getDeferredAnimation: Yu } = mt, { format: Hu } = At, { defined: Me, extend: sl, fireEvent: Er, getAlignFactor: ol, isArray: ne, isString: Pi, merge: Li, objectEach: Gu, pick: Oi, pInt: Vu, splat: rl } = I; (function (h) { function t() { return n(this).some(c => c == null ? void 0 : c.enabled) } function e(c, d, p, u, g) { var T; let { chart: m, enabledDataSorting: f } = this, y = this.isCartesian && m.inverted, x = c.plotX, b = c.plotY, w = p.rotation || 0, v = Me(x) && Me(b) && m.isInsidePlot(x, Math.round(b), { inverted: y, paneCoordinates: !0, series: this }), S = w === 0 && Oi(p.overflow, f ? "none" : "justify") === "justify", A = this.visible && c.visible !== !1 && Me(x) && (c.series.forceDL || f && !S || v || Oi(p.inside, !!this.options.stacking) && u && m.isInsidePlot(x, y ? u.x + 1 : u.y + u.height - 1, { inverted: y, paneCoordinates: !0, series: this })), M = c.pos(); if (A && M) { var k; let P = d.getBBox(), L = d.getBBox(void 0, 0); if (u = sl({ x: M[0], y: Math.round(M[1]), width: 0, height: 0 }, u || {}), p.alignTo === "plotEdges" && this.isCartesian && (u[y ? "x" : "y"] = 0, u[y ? "width" : "height"] = ((T = this.yAxis) == null ? void 0 : T.len) || 0), sl(p, { width: P.width, height: P.height }), k = u, f && this.xAxis && !S && this.setDataLabelStartPos(c, d, g, v, k), d.align(Li(p, { width: L.width, height: L.height }), !1, u, !1), d.alignAttr.x += ol(p.align) * (L.width - P.width), d.alignAttr.y += ol(p.verticalAlign) * (L.height - P.height), d[d.placed ? "animate" : "attr"]({ "text-align": d.alignAttr["text-align"] || "center", x: d.alignAttr.x + (P.width - L.width) / 2, y: d.alignAttr.y + (P.height - L.height) / 2, rotationOriginX: (d.width || 0) / 2, rotationOriginY: (d.height || 0) / 2 }), S && u.height >= 0) this.justifyDataLabel(d, p, d.alignAttr, P, u, g); else if (Oi(p.crop, !0)) { let { x: O, y: B } = d.alignAttr; A = m.isInsidePlot(O, B, { paneCoordinates: !0, series: this }) && m.isInsidePlot(O + P.width - 1, B + P.height - 1, { paneCoordinates: !0, series: this }) } p.shape && !w && d[g ? "attr" : "animate"]({ anchorX: M[0], anchorY: M[1] }) } g && f && (d.placed = !1), A || f && !S ? (d.show(), d.placed = !0) : (d.hide(), d.placed = !1) } function i() { return this.plotGroup("dataLabelsGroup", "data-labels", this.hasRendered ? "inherit" : "hidden", this.options.dataLabels.zIndex || 6, this.chart.dataLabelsGroup) } function s(c) { let d = this.hasRendered || 0, p = this.initDataLabelsGroup().attr({ opacity: +d }); return !d && p && (this.visible && p.show(), this.options.animation ? p.animate({ opacity: 1 }, c) : p.attr({ opacity: 1 })), p } function o(c) { var A; let d; c = c || this.points; let p = this, u = p.chart, g = p.options, m = u.renderer, { backgroundColor: f, plotBackgroundColor: y } = u.options.chart, x = m.getContrast(Pi(y) && y || Pi(f) && f || "#000000"), b = n(p), { animation: w, defer: v } = b[0], S = v ? Yu(u, w, p) : { defer: 0, duration: 0 }; Er(this, "drawDataLabels"), (A = p.hasDataLabels) != null && A.call(p) && (d = this.initDataLabels(S), c.forEach(M => { var L, O, B; let k = M.dataLabels || [], T = M.color || p.color; rl(a(b, M.dlOptions || ((L = M.options) == null ? void 0 : L.dataLabels))).forEach((D, z) => { var J; let E = D.enabled && (M.visible || M.dataLabelOnHidden) && (!M.isNull || M.dataLabelOnNull) && function (ut, _t) { let It = _t.filter; if (It) { let vt = It.operator, ft = ut[It.property], tt = It.value; return vt === ">" && ft > tt || vt === "<" && ft < tt || vt === ">=" && ft >= tt || vt === "<=" && ft <= tt || vt === "==" && ft == tt || vt === "===" && ft === tt || vt === "!=" && ft != tt || vt === "!==" && ft !== tt || !1 } return !0 }(M, D), { backgroundColor: N, borderColor: V, distance: W, style: F = {} } = D, lt, X, $, R = {}, j = k[z], rt = !j, K; E && (X = Me(lt = Oi(D[M.formatPrefix + "Format"], D.format)) ? Hu(lt, M, u) : (D[M.formatPrefix + "Formatter"] || D.formatter).call(M, D), $ = D.rotation, !u.styledMode && (F.color = Oi(D.color, F.color, Pi(p.color) ? p.color : void 0, "#000000"), F.color === "contrast" ? (N !== "none" && (K = N), M.contrastColor = m.getContrast(K !== "auto" && Pi(K) && K || (Pi(T) ? T : "")), F.color = K || !Me(W) && D.inside || 0 > Vu(W || 0) || g.stacking ? M.contrastColor : x) : delete M.contrastColor, g.cursor && (F.cursor = g.cursor)), R = { r: D.borderRadius || 0, rotation: $, padding: D.padding, zIndex: 1 }, u.styledMode || (R.fill = N === "auto" ? M.color : N, R.stroke = V === "auto" ? M.color : V, R["stroke-width"] = D.borderWidth), Gu(R, (ut, _t) => { ut === void 0 && delete R[_t] })), !j || E && Me(X) && !!(j.div || (J = j.text) != null && J.foreignObject) == !!D.useHTML && (j.rotation && D.rotation || j.rotation === D.rotation) || (j = void 0, rt = !0), E && Me(X) && X !== "" && (j ? R.text = X : (j = m.label(X, 0, 0, D.shape, void 0, void 0, D.useHTML, void 0, "data-label")).addClass(" highcharts-data-label-color-" + M.colorIndex + " " + (D.className || "") + (D.useHTML ? " highcharts-tracker" : "")), j && (j.options = D, j.attr(R), u.styledMode ? F.width && j.css({ width: F.width, textOverflow: F.textOverflow, whiteSpace: F.whiteSpace }) : j.css(F).shadow(D.shadow), Er(j, "beforeAddingDataLabel", { labelOptions: D, point: M }), j.added || j.add(d), p.alignDataLabel(M, j, D, void 0, rt), j.isActive = !0, k[z] && k[z] !== j && k[z].destroy(), k[z] = j)) }); let P = k.length; for (; P--;)(O = k[P]) != null && O.isActive ? k[P].isActive = !1 : ((B = k[P]) == null || B.destroy(), k.splice(P, 1)); M.dataLabel = k[0], M.dataLabels = k })), Er(this, "afterDrawDataLabels") } function r(c, d, p, u, g, m) { let f = this.chart, y = d.align, x = d.verticalAlign, b = c.box ? 0 : c.padding || 0, w = f.inverted ? this.yAxis : this.xAxis, v = w ? w.left - f.plotLeft : 0, S = f.inverted ? this.xAxis : this.yAxis, A = S ? S.top - f.plotTop : 0, { x: M = 0, y: k = 0 } = d, T, P; return (T = (p.x || 0) + b + v) < 0 && (y === "right" && M >= 0 ? (d.align = "left", d.inside = !0) : M -= T, P = !0), (T = (p.x || 0) + u.width - b + v) > f.plotWidth && (y === "left" && M <= 0 ? (d.align = "right", d.inside = !0) : M += f.plotWidth - T, P = !0), (T = p.y + b + A) < 0 && (x === "bottom" && k >= 0 ? (d.verticalAlign = "top", d.inside = !0) : k -= T, P = !0), (T = (p.y || 0) + u.height - b + A) > f.plotHeight && (x === "top" && k <= 0 ? (d.verticalAlign = "bottom", d.inside = !0) : k += f.plotHeight - T, P = !0), P && (d.x = M, d.y = k, c.placed = !m, c.align(d, void 0, g)), P } function a(c, d) { let p = [], u; if (ne(c) && !ne(d)) p = c.map(function (g) { return Li(g, d) }); else if (ne(d) && !ne(c)) p = d.map(function (g) { return Li(c, g) }); else if (ne(c) || ne(d)) { if (ne(c) && ne(d)) for (u = Math.max(c.length, d.length); u--;)p[u] = Li(c[u], d[u]) } else p = Li(c, d); return p } function n(c) { var p, u; let d = c.chart.options.plotOptions; return rl(a(a((p = d == null ? void 0 : d.series) == null ? void 0 : p.dataLabels, (u = d == null ? void 0 : d[c.type]) == null ? void 0 : u.dataLabels), c.options.dataLabels)) } function l(c, d, p, u, g) { let m = this.chart, f = m.inverted, y = this.xAxis, x = y.reversed, b = ((f ? d.height : d.width) || 0) / 2, w = c.pointWidth, v = w ? w / 2 : 0; d.startXPos = f ? g.x : x ? -b - v : y.width - b + v, d.startYPos = f ? x ? this.yAxis.height - b + v : -b - v : g.y, u ? d.visibility === "hidden" && (d.show(), d.attr({ opacity: 0 }).animate({ opacity: 1 })) : d.attr({ opacity: 1 }).animate({ opacity: 0 }, void 0, d.hide), m.hasRendered && (p && d.attr({ x: d.startXPos, y: d.startYPos }), d.placed = !0) } h.compose = function (c) { let d = c.prototype; d.initDataLabels || (d.initDataLabels = s, d.initDataLabelsGroup = i, d.alignDataLabel = e, d.drawDataLabels = o, d.justifyDataLabel = r, d.mergeArrays = a, d.setDataLabelStartPos = l, d.hasDataLabels = t) } })(ro || (ro = {})); let Is = ro, { composed: Zu } = C, { series: al } = G, { merge: $u, pushUnique: Ku } = I; (function (h) { function t(e, i, s, o, r) { var m, f; let { chart: a, options: n } = this, l = a.inverted, c = ((m = this.xAxis) == null ? void 0 : m.len) || a.plotSizeX || 0, d = ((f = this.yAxis) == null ? void 0 : f.len) || a.plotSizeY || 0, p = e.dlBox || e.shapeArgs, u = e.below ?? (e.plotY || 0) > (this.translatedThreshold ?? d), g = s.inside ?? !!n.stacking; if (p) { if (o = $u(p), s.overflow !== "allow" || s.crop !== !1 || n.clip !== !1) { o.y < 0 && (o.height += o.y, o.y = 0); let y = o.y + o.height - d; y > 0 && y < o.height - 1 && (o.height -= y) } l && (o = { x: d - o.y - o.height, y: c - o.x - o.width, width: o.height, height: o.width }), g || (l ? (o.x += u ? 0 : o.width, o.width = 0) : (o.y += u ? o.height : 0, o.height = 0)) } s.align ?? (s.align = !l || g ? "center" : u ? "right" : "left"), s.verticalAlign ?? (s.verticalAlign = l || g ? "middle" : u ? "top" : "bottom"), al.prototype.alignDataLabel.call(this, e, i, s, o, r), s.inside && e.contrastColor && i.css({ color: e.contrastColor }) } h.compose = function (e) { Is.compose(al), Ku(Zu, "ColumnDataLabel") && (e.prototype.alignDataLabel = t) } })(ao || (ao = {})); let qu = ao, { extend: _u, merge: Ju } = I; class Ir extends Es { } Ir.defaultOptions = Ju(Es.defaultOptions, {}), _u(Ir.prototype, { inverted: !0 }), G.registerSeriesType("bar", Ir); let { column: Qu, line: nl } = G.seriesTypes, { addEvent: t0, extend: e0, merge: i0 } = I; class Ds extends nl { applyJitter() { let t = this, e = this.options.jitter, i = this.points.length; e && this.points.forEach(function (s, o) { ["x", "y"].forEach(function (r, a) { if (e[r] && !s.isNull) { let n = `plot${r.toUpperCase()}`, l = t[`${r}Axis`], c = e[r] * l.transA; if (l && !l.logarithmic) { let d = Math.max(0, (s[n] || 0) - c), p = Math.min(l.len, (s[n] || 0) + c); s[n] = d + (p - d) * function (u) { let g = 1e4 * Math.sin(u); return g - Math.floor(g) }(o + a * i), r === "x" && (s.clientX = s.plotX) } } }) }) } drawGraph() { this.options.lineWidth ? super.drawGraph() : this.graph && (this.graph = this.graph.destroy()) } } Ds.defaultOptions = i0(nl.defaultOptions, { lineWidth: 0, findNearestPointBy: "xy", jitter: { x: 0, y: 0 }, marker: { enabled: !0 }, tooltip: { headerFormat: '<span style="color:{point.color}">●</span> <span style="font-size: 0.8em"> {series.name}</span><br/>', pointFormat: "x: <b>{point.x}</b><br/>y: <b>{point.y}</b><br/>" } }), e0(Ds.prototype, { drawTracker: Qu.prototype.drawTracker, sorted: !1, requireSorting: !1, noSharedTooltip: !0, trackerGroups: ["group", "markerGroup", "dataLabelsGroup"] }), t0(Ds, "afterTranslate", function () { this.applyJitter() }), G.registerSeriesType("scatter", Ds); let { deg2rad: ll } = C, { fireEvent: s0, isNumber: Dr, pick: Bs, relativeLength: o0 } = I; (function (h) { h.getCenter = function () { let t = this.options, e = this.chart, i = 2 * (t.slicedOffset || 0), s = e.plotWidth - 2 * i, o = e.plotHeight - 2 * i, r = t.center, a = Math.min(s, o), n = t.thickness, l, c = t.size, d = t.innerSize || 0, p, u; typeof c == "string" && (c = parseFloat(c)), typeof d == "string" && (d = parseFloat(d)); let g = [Bs(r == null ? void 0 : r[0], "50%"), Bs(r == null ? void 0 : r[1], "50%"), Bs(c && c < 0 ? void 0 : t.size, "100%"), Bs(d && d < 0 ? void 0 : t.innerSize || 0, "0%")]; for (!e.angular || this instanceof Tt || (g[3] = 0), p = 0; p < 4; ++p)u = g[p], l = p < 2 || p === 2 && /%$/.test(u), g[p] = o0(u, [s, o, a, g[2]][p]) + (l ? i : 0); return g[3] > g[2] && (g[3] = g[2]), Dr(n) && 2 * n < g[2] && n > 0 && (g[3] = g[2] - 2 * n), s0(this, "afterGetCenter", { positions: g }), g }, h.getStartAndEndRadians = function (t, e) { let i = Dr(t) ? t : 0, s = Dr(e) && e > i && e - i < 360 ? e : i + 360; return { start: ll * (i + -90), end: ll * (s + -90) } } })(no || (no = {})); let Br = no, { setAnimation: r0 } = mt, { addEvent: hl, defined: a0, extend: n0, isNumber: l0, pick: h0, relativeLength: d0 } = I; class dl extends $t { getConnectorPath(t) { let e = t.dataLabelPosition, i = t.options || {}, s = i.connectorShape, o = this.connectorShapes[s] || s; return e && o.call(this, { ...e.computed, alignment: e.alignment }, e.connectorPosition, i) || [] } getTranslate() { return this.sliced && this.slicedTranslation || { translateX: 0, translateY: 0 } } haloPath(t) { let e = this.shapeArgs; return this.sliced || !this.visible ? [] : this.series.chart.renderer.symbols.arc(e.x, e.y, e.r + t, e.r + t, { innerR: e.r - 1, start: e.start, end: e.end, borderRadius: e.borderRadius }) } constructor(t, e, i) { super(t, e, i), this.half = 0, this.name ?? (this.name = t.chart.options.lang.pieSliceName); let s = o => { this.slice(o.type === "select") }; hl(this, "select", s), hl(this, "unselect", s) } isValid() { return l0(this.y) && this.y >= 0 } setVisible(t, e = !0) { t !== this.visible && this.update({ visible: t ?? !this.visible }, e, void 0, !1) } slice(t, e, i) { let s = this.series; r0(i, s.chart), e = h0(e, !0), this.sliced = this.options.sliced = t = a0(t) ? t : !this.sliced, s.options.data[s.data.indexOf(this)] = this.options, this.graphic && this.graphic.animate(this.getTranslate()) } } n0(dl.prototype, { connectorShapes: { fixedOffset: function (h, t, e) { let i = t.breakAt, s = t.touchingSliceAt, o = e.softConnector ? ["C", h.x + (h.alignment === "left" ? -5 : 5), h.y, 2 * i.x - s.x, 2 * i.y - s.y, i.x, i.y] : ["L", i.x, i.y]; return [["M", h.x, h.y], o, ["L", s.x, s.y]] }, straight: function (h, t) { let e = t.touchingSliceAt; return [["M", h.x, h.y], ["L", e.x, e.y]] }, crookedLine: function (h, t, e) { let { angle: i = this.angle || 0, breakAt: s, touchingSliceAt: o } = t, { series: r } = this, [a, n, l] = r.center, c = l / 2, { plotLeft: d, plotWidth: p } = r.chart, u = h.alignment === "left", { x: g, y: m } = h, f = s.x; if (e.crookDistance) { let x = d0(e.crookDistance, 1); f = u ? a + c + (p + d - a - c) * (1 - x) : d + (a - c) * x } else f = a + (n - m) * Math.tan(i - Math.PI / 2); let y = [["M", g, m]]; return (u ? f <= g && f >= s.x : f >= g && f <= s.x) && y.push(["L", f, m]), y.push(["L", s.x, s.y], ["L", o.x, o.y]), y } } }); let { getStartAndEndRadians: c0 } = Br, { noop: cl } = C, { clamp: p0, extend: u0, fireEvent: pl, merge: zr, pick: g0 } = I; class Nr extends Tt { animate(t) { let e = this, i = e.points, s = e.startAngleRad; t || i.forEach(function (o) { let r = o.graphic, a = o.shapeArgs; r && a && (r.attr({ r: g0(o.startR, e.center && e.center[3] / 2), start: s, end: s }), r.animate({ r: a.r, start: a.start, end: a.end }, e.options.animation)) }) } drawEmpty() { let t, e, i = this.startAngleRad, s = this.endAngleRad, o = this.options; this.total === 0 && this.center ? (t = this.center[0], e = this.center[1], this.graph || (this.graph = this.chart.renderer.arc(t, e, this.center[1] / 2, 0, i, s).addClass("highcharts-empty-series").add(this.group)), this.graph.attr({ d: Fa.arc(t, e, this.center[2] / 2, 0, { start: i, end: s, innerR: this.center[3] / 2 }) }), this.chart.styledMode || this.graph.attr({ "stroke-width": o.borderWidth, fill: o.fillColor || "none", stroke: o.color || "#cccccc" })) : this.graph && (this.graph = this.graph.destroy()) } drawPoints() { let t = this.chart.renderer; this.points.forEach(function (e) { e.graphic && e.hasNewShapeType() && (e.graphic = e.graphic.destroy()), e.graphic || (e.graphic = t[e.shapeType](e.shapeArgs).add(e.series.group), e.delayedRendering = !0) }) } generatePoints() { super.generatePoints(), this.updateTotals() } getX(t, e, i, s) { let o = this.center, r = this.radii ? this.radii[i.index] || 0 : o[2] / 2, a = s.dataLabelPosition, n = (a == null ? void 0 : a.distance) || 0, l = Math.asin(p0((t - o[1]) / (r + n), -1, 1)); return o[0] + Math.cos(l) * (r + n) * (e ? -1 : 1) + (n > 0 ? (e ? -1 : 1) * (s.padding || 0) : 0) } hasData() { return !!this.dataTable.rowCount } redrawPoints() { let t, e, i, s, o = this, r = o.chart; this.drawEmpty(), o.group && !r.styledMode && o.group.shadow(o.options.shadow), o.points.forEach(function (a) { let n = {}; e = a.graphic, !a.isNull && e ? (s = a.shapeArgs, t = a.getTranslate(), r.styledMode || (i = o.pointAttribs(a, a.selected && "select")), a.delayedRendering ? (e.setRadialReference(o.center).attr(s).attr(t), r.styledMode || e.attr(i).attr({ "stroke-linejoin": "round" }), a.delayedRendering = !1) : (e.setRadialReference(o.center), r.styledMode || zr(!0, n, i), zr(!0, n, s, t), e.animate(n)), e.attr({ visibility: a.visible ? "inherit" : "hidden" }), e.addClass(a.getClassName(), !0)) : e && (a.graphic = e.destroy()) }) } sortByAngle(t, e) { t.sort(function (i, s) { return i.angle !== void 0 && (s.angle - i.angle) * e }) } translate(t) { pl(this, "translate"), this.generatePoints(); let e = this.options, i = e.slicedOffset, s = c0(e.startAngle, e.endAngle), o = this.startAngleRad = s.start, r = (this.endAngleRad = s.end) - o, a = this.points, n = e.ignoreHiddenPoint, l = a.length, c, d, p, u, g, m, f, y = 0; for (t || (this.center = t = this.getCenter()), m = 0; m < l; m++) { f = a[m], c = o + y * r, f.isValid() && (!n || f.visible) && (y += f.percentage / 100), d = o + y * r; let x = { x: t[0], y: t[1], r: t[2] / 2, innerR: t[3] / 2, start: Math.round(1e3 * c) / 1e3, end: Math.round(1e3 * d) / 1e3 }; f.shapeType = "arc", f.shapeArgs = x, (p = (d + c) / 2) > 1.5 * Math.PI ? p -= 2 * Math.PI : p < -Math.PI / 2 && (p += 2 * Math.PI), f.slicedTranslation = { translateX: Math.round(Math.cos(p) * i), translateY: Math.round(Math.sin(p) * i) }, u = Math.cos(p) * t[2] / 2, g = Math.sin(p) * t[2] / 2, f.tooltipPos = [t[0] + .7 * u, t[1] + .7 * g], f.half = +(p < -Math.PI / 2 || p > Math.PI / 2), f.angle = p } pl(this, "afterTranslate") } updateTotals() { let t = this.points, e = t.length, i = this.options.ignoreHiddenPoint, s, o, r = 0; for (s = 0; s < e; s++)(o = t[s]).isValid() && (!i || o.visible) && (r += o.y); for (s = 0, this.total = r; s < e; s++)(o = t[s]).percentage = r > 0 && (o.visible || !i) ? o.y / r * 100 : 0, o.total = r } } Nr.defaultOptions = zr(Tt.defaultOptions, { borderRadius: 3, center: [null, null], clip: !1, colorByPoint: !0, dataLabels: { connectorPadding: 5, connectorShape: "crookedLine", crookDistance: void 0, distance: 30, enabled: !0, formatter: function () { return this.isNull ? void 0 : this.name }, softConnector: !0, x: 0 }, fillColor: void 0, ignoreHiddenPoint: !0, inactiveOtherPoints: !0, legendType: "point", marker: null, size: null, showInLegend: !1, slicedOffset: 10, stickyTracking: !1, tooltip: { followPointer: !0 }, borderColor: "#ffffff", borderWidth: 1, lineWidth: void 0, states: { hover: { brightness: .1 } } }), u0(Nr.prototype, { axisTypes: [], directTouch: !0, drawGraph: void 0, drawTracker: Es.prototype.drawTracker, getCenter: Br.getCenter, getSymbol: cl, invertible: !1, isCartesian: !1, noSharedTooltip: !0, pointAttribs: Es.prototype.pointAttribs, pointClass: dl, requireSorting: !1, searchPoint: cl, trackerGroups: ["group", "dataLabelsGroup"] }), G.registerSeriesType("pie", Nr); let { composed: m0, noop: f0 } = C, { distribute: y0 } = Ki, { series: ul } = G, { arrayMax: x0, clamp: gl, defined: ml, pick: b0, pushUnique: v0, relativeLength: fl } = I; (function (h) { let t = { radialDistributionY: function (r, a) { var n; return (((n = a.dataLabelPosition) == null ? void 0 : n.top) || 0) + r.distributeBox.pos }, radialDistributionX: function (r, a, n, l, c) { let d = c.dataLabelPosition; return r.getX(n < ((d == null ? void 0 : d.top) || 0) + 2 || n > ((d == null ? void 0 : d.bottom) || 0) - 2 ? l : n, a.half, a, c) }, justify: function (r, a, n, l) { var c; return l[0] + (r.half ? -1 : 1) * (n + (((c = a.dataLabelPosition) == null ? void 0 : c.distance) || 0)) }, alignToPlotEdges: function (r, a, n, l) { let c = r.getBBox().width; return a ? c + l : n - c - l }, alignToConnectors: function (r, a, n, l) { let c = 0, d; return r.forEach(function (p) { (d = p.dataLabel.getBBox().width) > c && (c = d) }), a ? c + l : n - c - l } }; function e(r, a) { let n = Math.PI / 2, { start: l = 0, end: c = 0 } = r.shapeArgs || {}, d = r.angle || 0; a > 0 && l < n && c > n && d > n / 2 && d < 1.5 * n && (d = d <= n ? Math.max(n / 2, (l + n) / 2) : Math.min(1.5 * n, (n + c) / 2)); let { center: p, options: u } = this, g = p[2] / 2, m = Math.cos(d), f = Math.sin(d), y = p[0] + m * g, x = p[1] + f * g, b = Math.min((u.slicedOffset || 0) + (u.borderWidth || 0), a / 5); return { natural: { x: y + m * a, y: x + f * a }, computed: {}, alignment: a < 0 ? "center" : r.half ? "right" : "left", connectorPosition: { angle: d, breakAt: { x: y + m * b, y: x + f * b }, touchingSliceAt: { x: y, y: x } }, distance: a } } function i() { var A; let r = this, a = r.points, n = r.chart, l = n.plotWidth, c = n.plotHeight, d = n.plotLeft, p = Math.round(n.chartWidth / 3), u = r.center, g = u[2] / 2, m = u[1], f = [[], []], y = [0, 0, 0, 0], x = r.dataLabelPositioners, b, w, v, S = 0; r.visible && ((A = r.hasDataLabels) != null && A.call(r)) && (a.forEach(M => { (M.dataLabels || []).forEach(k => { k.shortened && (k.attr({ width: "auto" }).css({ width: "auto", textOverflow: "clip" }), k.shortened = !1) }) }), ul.prototype.drawDataLabels.apply(r), a.forEach(M => { (M.dataLabels || []).forEach((k, T) => { var B; let P = u[2] / 2, L = k.options, O = fl((L == null ? void 0 : L.distance) || 0, P); T === 0 && f[M.half].push(M), !ml((B = L == null ? void 0 : L.style) == null ? void 0 : B.width) && k.getBBox().width > p && (k.css({ width: Math.round(.7 * p) + "px" }), k.shortened = !0), k.dataLabelPosition = this.getDataLabelPosition(M, O), S = Math.max(S, O) }) }), f.forEach((M, k) => { let T = M.length, P = [], L, O, B = 0, D; T && (r.sortByAngle(M, k - .5), S > 0 && (L = Math.max(0, m - g - S), O = Math.min(m + g + S, n.plotHeight), M.forEach(z => { (z.dataLabels || []).forEach(E => { var V; let N = E.dataLabelPosition; N && N.distance > 0 && (N.top = Math.max(0, m - g - N.distance), N.bottom = Math.min(m + g + N.distance, n.plotHeight), B = E.getBBox().height || 21, E.lineHeight = n.renderer.fontMetrics(E.text || E).h + 2 * E.padding, z.distributeBox = { target: (((V = E.dataLabelPosition) == null ? void 0 : V.natural.y) || 0) - N.top + E.lineHeight / 2, size: B, rank: z.y }, P.push(z.distributeBox)) }) }), y0(P, D = O + B - L, D / 5)), M.forEach(z => { (z.dataLabels || []).forEach(E => { let N = E.options || {}, V = z.distributeBox, W = E.dataLabelPosition, F = (W == null ? void 0 : W.natural.y) || 0, lt = N.connectorPadding || 0, X = E.lineHeight || 21, $ = (X - E.getBBox().height) / 2, R = 0, j = F, rt = "inherit"; if (W) { if (P && ml(V) && W.distance > 0 && (V.pos === void 0 ? rt = "hidden" : (v = V.size, j = x.radialDistributionY(z, E))), N.justify) R = x.justify(z, E, g, u); else switch (N.alignTo) { case "connectors": R = x.alignToConnectors(M, k, l, d); break; case "plotEdges": R = x.alignToPlotEdges(E, k, l, d); break; default: R = x.radialDistributionX(r, z, j - $, F, E) }if (W.attribs = { visibility: rt, align: W.alignment }, W.posAttribs = { x: R + (N.x || 0) + ({ left: lt, right: -lt }[W.alignment] || 0), y: j + (N.y || 0) - X / 2 }, W.computed.x = R, W.computed.y = j - $, b0(N.crop, !0)) { let K; R - (w = E.getBBox().width) < lt && k === 1 ? (K = Math.round(w - R + lt), y[3] = Math.max(K, y[3])) : R + w > l - lt && k === 0 && (K = Math.round(R + w - l + lt), y[1] = Math.max(K, y[1])), j - v / 2 < 0 ? y[0] = Math.max(Math.round(-j + v / 2), y[0]) : j + v / 2 > c && (y[2] = Math.max(Math.round(j + v / 2 - c), y[2])), W.sideOverflow = K } } }) })) }), (x0(y) === 0 || this.verifyDataLabelOverflow(y)) && (this.placeDataLabels(), this.points.forEach(M => { (M.dataLabels || []).forEach(k => { var O; let { connectorColor: T, connectorWidth: P = 1 } = k.options || {}, L = k.dataLabelPosition; if (P) { let B; b = k.connector, L && L.distance > 0 ? (B = !b, b || (k.connector = b = n.renderer.path().addClass("highcharts-data-label-connector  highcharts-color-" + M.colorIndex + (M.className ? " " + M.className : "")).add(r.dataLabelsGroup)), n.styledMode || b.attr({ "stroke-width": P, stroke: T || M.color || "#666666" }), b[B ? "attr" : "animate"]({ d: M.getConnectorPath(k) }), b.attr({ visibility: (O = L.attribs) == null ? void 0 : O.visibility })) : b && (k.connector = b.destroy()) } }) }))) } function s() { this.points.forEach(r => { (r.dataLabels || []).forEach(a => { var l, c; let n = a.dataLabelPosition; n ? (n.sideOverflow && (a.css({ width: Math.max(a.getBBox().width - n.sideOverflow, 0) + "px", textOverflow: ((c = (l = a.options) == null ? void 0 : l.style) == null ? void 0 : c.textOverflow) || "ellipsis" }), a.shortened = !0), a.attr(n.attribs), a[a.moved ? "animate" : "attr"](n.posAttribs), a.moved = !0) : a && a.attr({ y: -9999 }) }), delete r.distributeBox }, this) } function o(r) { let a = this.center, n = this.options, l = n.center, c = n.minSize || 80, d = c, p = n.size !== null; return !p && (l[0] !== null ? d = Math.max(a[2] - Math.max(r[1], r[3]), c) : (d = Math.max(a[2] - r[1] - r[3], c), a[0] += (r[3] - r[1]) / 2), l[1] !== null ? d = gl(d, c, a[2] - Math.max(r[0], r[2])) : (d = gl(d, c, a[2] - r[0] - r[2]), a[1] += (r[0] - r[2]) / 2), d < a[2] ? (a[2] = d, a[3] = Math.min(n.thickness ? Math.max(0, d - 2 * n.thickness) : Math.max(0, fl(n.innerSize || 0, d)), d), this.translate(a), this.drawDataLabels && this.drawDataLabels()) : p = !0), p } h.compose = function (r) { if (Is.compose(ul), v0(m0, "PieDataLabel")) { let a = r.prototype; a.dataLabelPositioners = t, a.alignDataLabel = f0, a.drawDataLabels = i, a.getDataLabelPosition = e, a.placeDataLabels = s, a.verifyDataLabelOverflow = o } } })(lo || (lo = {})); let w0 = lo; (function (h) { h.getCenterOfPoints = function (t) { let e = t.reduce((i, s) => (i.x += s.x, i.y += s.y, i), { x: 0, y: 0 }); return { x: e.x / t.length, y: e.y / t.length } }, h.getDistanceBetweenPoints = function (t, e) { return Math.sqrt(Math.pow(e.x - t.x, 2) + Math.pow(e.y - t.y, 2)) }, h.getAngleBetweenPoints = function (t, e) { return Math.atan2(e.x - t.x, e.y - t.y) }, h.pointInPolygon = function ({ x: t, y: e }, i) { let s = i.length, o, r, a = !1; for (o = 0, r = s - 1; o < s; r = o++) { let [n, l] = i[o], [c, d] = i[r]; l > e != d > e && t < (c - n) * (e - l) / (d - l) + n && (a = !a) } return a } })(ho || (ho = {})); let yl = ho, { pointInPolygon: S0 } = yl, { addEvent: M0, getAlignFactor: k0, fireEvent: xl, objectEach: bl, pick: A0 } = I; function C0(h) { let t = h.length, e = (c, d) => !(d.x >= c.x + c.width || d.x + d.width <= c.x || d.y >= c.y + c.height || d.y + d.height <= c.y), i = (c, d) => { for (let p of c) if (S0({ x: p[0], y: p[1] }, d)) return !0; return !1 }, s, o, r, a, n, l = !1; for (let c = 0; c < t; c++)(s = h[c]) && (s.oldOpacity = s.opacity, s.newOpacity = 1, s.absoluteBox = function (d) { var p, u; if (d && (!d.alignAttr || d.placed)) { let g = d.box ? 0 : d.padding || 0, m = d.alignAttr || { x: d.attr("x"), y: d.attr("y") }, { height: f, polygon: y, width: x } = d.getBBox(), b = k0(d.alignValue) * x; return d.width = x, d.height = f, { x: m.x + (((p = d.parentGroup) == null ? void 0 : p.translateX) || 0) + g - b, y: m.y + (((u = d.parentGroup) == null ? void 0 : u.translateY) || 0) + g, width: x - 2 * g, height: f - 2 * g, polygon: y } } }(s)); h.sort((c, d) => (d.labelrank || 0) - (c.labelrank || 0)); for (let c = 0; c < t; ++c) { a = (o = h[c]) && o.absoluteBox; let d = a == null ? void 0 : a.polygon; for (let p = c + 1; p < t; ++p) { n = (r = h[p]) && r.absoluteBox; let u = !1; if (a && n && o !== r && o.newOpacity !== 0 && r.newOpacity !== 0 && o.visibility !== "hidden" && r.visibility !== "hidden") { let g = n.polygon; if (d && g && d !== g ? i(d, g) && (u = !0) : e(a, n) && (u = !0), u) { let m = o.labelrank < r.labelrank ? o : r, f = m.text; m.newOpacity = 0, f != null && f.element.querySelector("textPath") && f.hide() } } } } for (let c of h) vl(c, this) && (l = !0); l && xl(this, "afterHideAllOverlappingLabels") } function vl(h, t) { let e, i = !1; return h && (e = h.newOpacity, h.oldOpacity !== e && (h.hasClass("highcharts-data-label") ? (h[e ? "removeClass" : "addClass"]("highcharts-data-label-hidden"), i = !0, h[h.isOld ? "animate" : "attr"]({ opacity: e }, void 0, function () { t.styledMode || h.css({ pointerEvents: e ? "auto" : "none" }) }), xl(t, "afterHideOverlappingLabel")) : h.attr({ opacity: e })), h.isOld = !0), i } function T0() { var e; let h = this, t = []; for (let i of h.labelCollectors || []) t = t.concat(i()); for (let i of h.yAxis || []) i.stacking && i.options.stackLabels && !i.options.stackLabels.allowOverlap && bl(i.stacking.stacks, s => { bl(s, o => { o.label && t.push(o.label) }) }); for (let i of h.series || []) if (i.visible && ((e = i.hasDataLabels) != null && e.call(i))) { let s = o => { for (let r of o) r.visible && (r.dataLabels || []).forEach(a => { var l; let n = a.options || {}; a.labelrank = A0(n.labelrank, r.labelrank, (l = r.shapeArgs) == null ? void 0 : l.height), n.allowOverlap ?? Number(n.distance) > 0 ? (a.oldOpacity = a.opacity, a.newOpacity = 1, vl(a, h)) : t.push(a) }) }; s(i.nodes || []), s(i.points) } this.hideOverlappingLabels(t) } let wl = { compose: function (h) { let t = h.prototype; t.hideOverlappingLabels || (t.hideOverlappingLabels = C0, M0(h, "render", T0)) } }, { defaultOptions: P0 } = wt, { noop: Sl } = C, { addEvent: Ml, extend: L0, isObject: kl, merge: O0, relativeLength: Ur } = I, E0 = { radius: 0, scope: "stack", where: void 0 }, Al = Sl, Cl = Sl; function I0(h, t, e, i, s = {}) { let o = Al(h, t, e, i, s), { innerR: r = 0, r: a = e, start: n = 0, end: l = 0 } = s; if (s.open || !s.borderRadius) return o; let c = l - n, d = Math.sin(c / 2), p = Math.max(Math.min(Ur(s.borderRadius || 0, a - r), (a - r) / 2, a * d / (1 + d)), 0), u = Math.min(p, c / Math.PI * 2 * r), g = o.length - 1; for (; g--;)(function (m, f, y) { let x, b, w, v = m[f], S = m[f + 1]; if (S[0] === "Z" && (S = m[0]), (v[0] === "M" || v[0] === "L") && S[0] === "A" ? (x = v, b = S, w = !0) : v[0] === "A" && (S[0] === "M" || S[0] === "L") && (x = S, b = v), x && b && b.params) { let A = b[1], M = b[5], k = b.params, { start: T, end: P, cx: L, cy: O } = k, B = M ? A - y : A + y, D = B ? Math.asin(y / B) : 0, z = M ? D : -D, E = Math.cos(D) * B; w ? (k.start = T + z, x[1] = L + E * Math.cos(T), x[2] = O + E * Math.sin(T), m.splice(f + 1, 0, ["A", y, y, 0, 0, 1, L + A * Math.cos(k.start), O + A * Math.sin(k.start)])) : (k.end = P - z, b[6] = L + A * Math.cos(k.end), b[7] = O + A * Math.sin(k.end), m.splice(f + 1, 0, ["A", y, y, 0, 0, 1, L + E * Math.cos(P), O + E * Math.sin(P)])), b[4] = Math.abs(k.end - k.start) < Math.PI ? 0 : 1 } })(o, g, g > 1 ? u : p); return o } function D0() { var h, t; if (this.options.borderRadius && !(this.chart.is3d && this.chart.is3d())) { let { options: e, yAxis: i } = this, s = e.stacking === "percent", o = (t = (h = P0.plotOptions) == null ? void 0 : h[this.type]) == null ? void 0 : t.borderRadius, r = jr(e.borderRadius, kl(o) ? o : {}), a = i.options.reversed; for (let n of this.points) { let { shapeArgs: l } = n; if (n.shapeType === "roundedRect" && l) { let { width: c = 0, height: d = 0, y: p = 0 } = l, u = p, g = d; if (r.scope === "stack" && n.stackTotal) { let x = i.translate(s ? 100 : n.stackTotal, !1, !0, !1, !0), b = i.translate(e.threshold || 0, !1, !0, !1, !0), w = this.crispCol(0, Math.min(x, b), 0, Math.abs(x - b)); u = w.y, g = w.height } let m = (n.negative ? -1 : 1) * (a ? -1 : 1) == -1, f = r.where; !f && this.is("waterfall") && Math.abs((n.yBottom || 0) - (this.translatedThreshold || 0)) > this.borderWidth && (f = "all"), f || (f = "end"); let y = Math.min(Ur(r.radius, c), c / 2, f === "all" ? d / 2 : 1 / 0) || 0; f === "end" && (m && (u -= y), g += y), L0(l, { brBoxHeight: g, brBoxY: u, r: y }) } } } } function jr(h, t) { return kl(h) || (h = { radius: h || 0 }), O0(E0, t, h) } function B0() { let h = jr(this.options.borderRadius); for (let t of this.points) { let e = t.shapeArgs; e && (e.borderRadius = Ur(h.radius, (e.r || 0) - (e.innerR || 0))) } } function z0(h, t, e, i, s = {}) { let o = Cl(h, t, e, i, s), { r = 0, brBoxHeight: a = i, brBoxY: n = t } = s, l = t - n, c = n + a - (t + i), d = l - r > -.1 ? 0 : r, p = c - r > -.1 ? 0 : r, u = Math.max(d && l, 0), g = Math.max(p && c, 0), m = [h + d, t], f = [h + e - d, t], y = [h + e, t + d], x = [h + e, t + i - p], b = [h + e - p, t + i], w = [h + p, t + i], v = [h, t + i - p], S = [h, t + d], A = (M, k) => Math.sqrt(Math.pow(M, 2) - Math.pow(k, 2)); if (u) { let M = A(d, d - u); m[0] -= M, f[0] += M, y[1] = S[1] = t + d - u } if (i < d - u) { let M = A(d, d - u - i); y[0] = x[0] = h + e - d + M, b[0] = Math.min(y[0], b[0]), w[0] = Math.max(x[0], w[0]), v[0] = S[0] = h + d - M, y[1] = S[1] = t + i } if (g) { let M = A(p, p - g); b[0] += M, w[0] -= M, x[1] = v[1] = t + i - p + g } if (i < p - g) { let M = A(p, p - g - i); y[0] = x[0] = h + e - p + M, f[0] = Math.min(y[0], f[0]), m[0] = Math.max(x[0], m[0]), v[0] = S[0] = h + p - M, x[1] = v[1] = t } return o.length = 0, o.push(["M", ...m], ["L", ...f], ["A", d, d, 0, 0, 1, ...y], ["L", ...x], ["A", p, p, 0, 0, 1, ...b], ["L", ...w], ["A", p, p, 0, 0, 1, ...v], ["L", ...S], ["A", d, d, 0, 0, 1, ...m], ["Z"]), o } let { diffObjects: N0, extend: U0, find: j0, merge: R0, pick: zs, uniqueKey: W0 } = I; (function (h) { function t(i, s) { let o = i.condition; (o.callback || function () { return this.chartWidth <= zs(o.maxWidth, Number.MAX_VALUE) && this.chartHeight <= zs(o.maxHeight, Number.MAX_VALUE) && this.chartWidth >= zs(o.minWidth, 0) && this.chartHeight >= zs(o.minHeight, 0) }).call(this) && s.push(i._id) } function e(i, s) { let o = this.options.responsive, r = this.currentResponsive, a = [], n; !s && o && o.rules && o.rules.forEach(d => { d._id === void 0 && (d._id = W0()), this.matchResponsiveRule(d, a) }, this); let l = R0(...a.map(d => j0((o == null ? void 0 : o.rules) || [], p => p._id === d)).map(d => d == null ? void 0 : d.chartOptions)); l.isResponsiveOptions = !0, a = a.toString() || void 0; let c = r == null ? void 0 : r.ruleIds; a !== c && (r && (this.currentResponsive = void 0, this.updatingResponsive = !0, this.update(r.undoOptions, i, !0), this.updatingResponsive = !1), a ? ((n = N0(l, this.options, !0, this.collectionsWithUpdate)).isResponsiveOptions = !0, this.currentResponsive = { ruleIds: a, mergedOptions: l, undoOptions: n }, this.updatingResponsive || this.update(l, i, !0)) : this.currentResponsive = void 0) } h.compose = function (i) { let s = i.prototype; return s.matchResponsiveRule || U0(s, { matchResponsiveRule: t, setResponsive: e }), i } })(co || (co = {})); let F0 = co; C.AST = et, C.Axis = xi, C.Chart = xr, C.Color = _, C.DataLabel = Is, C.DataTableCore = xs, C.Fx = kt, C.HTMLElement = We, C.Legend = Bn, C.LegendSymbol = sr, C.OverlappingDataLabels = C.OverlappingDataLabels || wl, C.PlotLineOrBand = us, C.Point = $t, C.Pointer = xn, C.RendererRegistry = pi, C.Series = Tt, C.SeriesRegistry = G, C.StackItem = Vn, C.SVGElement = Dt, C.SVGRenderer = ye, C.Templating = At, C.Tick = Fe, C.Time = Mo, C.Tooltip = un, C.animate = mt.animate, C.animObject = mt.animObject, C.chart = xr.chart, C.color = _.parse, C.dateFormat = At.dateFormat, C.defaultOptions = wt.defaultOptions, C.distribute = Ki.distribute, C.format = At.format, C.getDeferredAnimation = mt.getDeferredAnimation, C.getOptions = wt.getOptions, C.numberFormat = At.numberFormat, C.seriesType = G.seriesType, C.setAnimation = mt.setAnimation, C.setOptions = wt.setOptions, C.stop = mt.stop, C.time = wt.defaultTime, C.timers = kt.timers, { compose: function (h, t, e) { let i = h.types.pie; if (!t.symbolCustomAttribs.includes("borderRadius")) { let s = e.prototype.symbols; Ml(h, "afterColumnTranslate", D0, { order: 9 }), Ml(i, "afterTranslate", B0), t.symbolCustomAttribs.push("borderRadius", "brBoxHeight", "brBoxY"), Al = s.arc, Cl = s.roundedRect, s.arc = I0, s.roundedRect = z0 } }, optionsToObject: jr }.compose(C.Series, C.SVGElement, C.SVGRenderer), qu.compose(C.Series.types.column), Is.compose(C.Series), Oc.compose(C.Axis), We.compose(C.SVGRenderer), Bn.compose(C.Chart), Dc.compose(C.Axis), wl.compose(C.Chart), w0.compose(C.Series.types.pie), us.compose(C.Chart, C.Axis), xn.compose(C.Chart), F0.compose(C.Chart), ki.compose(C.Axis, C.Chart, C.Series), Lu.compose(C.Axis, C.Chart, C.Series), un.compose(C.Pointer), I.extend(C, I); let { parse: Ns } = _, { addEvent: Ze, extend: Tl, merge: X0, pick: Y0, splat: H0 } = I; (function (h) { let t; function e() { let { userOptions: p } = this; this.colorAxis = [], p.colorAxis && (p.colorAxis = H0(p.colorAxis), p.colorAxis.map(u => new t(this, u))) } function i(p) { let u = this.chart.colorAxis || [], g = x => { let b = p.allItems.indexOf(x); b !== -1 && (this.destroyItem(p.allItems[b]), p.allItems.splice(b, 1)) }, m = [], f, y; for (u.forEach(function (x) { f = x.options, f != null && f.showInLegend && (f.dataClasses && f.visible ? m = m.concat(x.getDataClassLegendSymbols()) : f.visible && m.push(x), x.series.forEach(function (b) { (!b.options.showInLegend || f.dataClasses) && (b.options.legendType === "point" ? b.points.forEach(function (w) { g(w) }) : g(b)) })) }), y = m.length; y--;)p.allItems.unshift(m[y]) } function s(p) { p.visible && p.item.legendColor && p.item.legendItem.symbol.attr({ fill: p.item.legendColor }) } function o(p) { var u; (u = this.chart.colorAxis) == null || u.forEach(g => { g.update({}, p.redraw) }) } function r() { var p; ((p = this.chart.colorAxis) != null && p.length || this.colorAttribs) && this.translateColors() } function a() { let p = this.axisTypes; p ? p.indexOf("colorAxis") === -1 && p.push("colorAxis") : this.axisTypes = ["colorAxis"] } function n(p) { let u = this, g = p ? "show" : "hide"; u.visible = u.options.visible = !!p, ["graphic", "dataLabel"].forEach(function (m) { u[m] && u[m][g]() }), this.series.buildKDTree() } function l() { let p = this, u = this.getPointsCollection(), g = this.options.nullColor, m = this.colorAxis, f = this.colorKey; u.forEach(y => { let x = y.getNestedProperty(f), b = y.options.color || (y.isNull || y.value === null ? g : m && x !== void 0 ? m.toColor(x, y) : y.color || p.color); b && y.color !== b && (y.color = b, p.options.legendType === "point" && y.legendItem && y.legendItem.label && p.chart.legend.colorizeItem(y, y.visible)) }) } function c() { this.elem.attr("fill", Ns(this.start).tweenTo(Ns(this.end), this.pos), void 0, !0) } function d() { this.elem.attr("stroke", Ns(this.start).tweenTo(Ns(this.end), this.pos), void 0, !0) } h.compose = function (p, u, g, m, f) { let y = u.prototype, x = g.prototype, b = f.prototype; y.collectionsWithUpdate.includes("colorAxis") || (t = p, y.collectionsWithUpdate.push("colorAxis"), y.collectionsWithInit.colorAxis = [y.addColorAxis], Ze(u, "afterCreateAxes", e), function (w) { let v = w.prototype.createAxis; w.prototype.createAxis = function (S, A) { if (S !== "colorAxis") return v.apply(this, arguments); let M = new t(this, X0(A.axis, { index: this[S].length, isX: !1 })); return this.isDirtyLegend = !0, this.axes.forEach(k => { k.series = [] }), this.series.forEach(k => { k.bindAxes(), k.isDirtyData = !0 }), Y0(A.redraw, !0) && this.redraw(A.animation), M } }(u), x.fillSetter = c, x.strokeSetter = d, Ze(m, "afterGetAllItems", i), Ze(m, "afterColorizeItem", s), Ze(m, "afterUpdate", o), Tl(b, { optionalAxis: "colorAxis", translateColors: l }), Tl(b.pointClass.prototype, { setVisible: n }), Ze(f, "afterTranslate", r, { order: 1 }), Ze(f, "bindAxes", a)) }, h.pointSetVisible = n })(po || (po = {})); let G0 = po, { parse: Rr } = _, { merge: V0 } = I; (function (h) { h.initDataClasses = function (t) { let e = this.chart, i = this.legendItem = this.legendItem || {}, s = this.options, o = t.dataClasses || [], r, a, n = e.options.chart.colorCount, l = 0, c; this.dataClasses = a = [], i.labels = []; for (let d = 0, p = o.length; d < p; ++d)r = V0(r = o[d]), a.push(r), (e.styledMode || !r.color) && (s.dataClassColor === "category" ? (e.styledMode || (n = (c = e.options.colors || []).length, r.color = c[l]), r.colorIndex = l, ++l === n && (l = 0)) : r.color = Rr(s.minColor).tweenTo(Rr(s.maxColor), p < 2 ? .5 : d / (p - 1))) }, h.initStops = function () { let t = this.options, e = this.stops = t.stops || [[0, t.minColor || ""], [1, t.maxColor || ""]]; for (let i = 0, s = e.length; i < s; ++i)e[i].color = Rr(e[i][1]) }, h.normalizedValue = function (t) { let e = this.max || 0, i = this.min || 0; return this.logarithmic && (t = this.logarithmic.log2lin(t)), 1 - (e - t) / (e - i || 1) }, h.toColor = function (t, e) { let i, s, o, r, a, n, l = this.dataClasses, c = this.stops; if (l) { for (n = l.length; n--;)if (s = (a = l[n]).from, o = a.to, (s === void 0 || t >= s) && (o === void 0 || t <= o)) { r = a.color, e && (e.dataClass = n, e.colorIndex = a.colorIndex); break } } else { for (i = this.normalizedValue(t), n = c.length; n-- && !(i > c[n][0]);); s = c[n] || c[n + 1], i = 1 - ((o = c[n + 1] || s)[0] - i) / (o[0] - s[0] || 1), r = s.color.tweenTo(o.color, i) } return r } })(uo || (uo = {})); let Z0 = uo, { defaultOptions: Wr } = wt, { series: Pl } = G, { defined: Us, extend: Ll, fireEvent: $0, isArray: K0, isNumber: q0, merge: Ol, pick: le, relativeLength: El } = I; Wr.colorAxis = Ol(Wr.xAxis, { lineWidth: 0, minPadding: 0, maxPadding: 0, gridLineColor: "#ffffff", gridLineWidth: 1, tickPixelInterval: 72, startOnTick: !0, endOnTick: !0, offset: 0, marker: { animation: { duration: 50 }, width: .01, color: "#999999" }, labels: { distance: 8, overflow: "justify", rotation: 0 }, minColor: "#e6e9ff", maxColor: "#0022ff", tickLength: 5, showInLegend: !0 }); class Nt extends xi { static compose(t, e, i, s) { G0.compose(Nt, t, e, i, s) } constructor(t, e) { super(t, e), this.coll = "colorAxis", this.visible = !0, this.init(t, e) } init(t, e) { let i = t.options.legend || {}, s = e.layout ? e.layout !== "vertical" : i.layout !== "vertical"; this.side = e.side || s ? 2 : 1, this.reversed = e.reversed || !s, this.opposite = !s, super.init(t, e, "colorAxis"), this.userOptions = e, K0(t.userOptions.colorAxis) && (t.userOptions.colorAxis[this.index] = e), e.dataClasses && this.initDataClasses(e), this.initStops(), this.horiz = s, this.zoomEnabled = !1 } hasData() { return !!(this.tickPositions || []).length } setTickPositions() { if (!this.dataClasses) return super.setTickPositions() } setOptions(t) { let e = Ol(Wr.colorAxis, t, { showEmpty: !1, title: null, visible: this.chart.options.legend.enabled && t.visible !== !1 }); super.setOptions(e), this.options.crosshair = this.options.marker } setAxisSize() { var o; let t = this.chart, e = (o = this.legendItem) == null ? void 0 : o.symbol, { width: i, height: s } = this.getSize(); e && (this.left = +e.attr("x"), this.top = +e.attr("y"), this.width = i = +e.attr("width"), this.height = s = +e.attr("height"), this.right = t.chartWidth - this.left - i, this.bottom = t.chartHeight - this.top - s, this.pos = this.horiz ? this.left : this.top), this.len = (this.horiz ? i : s) || Nt.defaultLegendLength } getOffset() { var i; let t = (i = this.legendItem) == null ? void 0 : i.group, e = this.chart.axisOffset[this.side]; if (t) { this.axisParent = t, super.getOffset(); let s = this.chart.legend; s.allItems.forEach(function (o) { o instanceof Nt && o.drawLegendSymbol(s, o) }), s.render(), this.chart.getMargins(!0), this.chart.series.some(o => o.isDrilling) || (this.isDirty = !0), this.added || (this.added = !0, this.labelLeft = 0, this.labelRight = this.width), this.chart.axisOffset[this.side] = e } } setLegendColor() { let t = this.horiz, e = this.reversed, i = +!!e, s = +!e, o = t ? [i, 0, s, 0] : [0, s, 0, i]; this.legendColor = { linearGradient: { x1: o[0], y1: o[1], x2: o[2], y2: o[3] }, stops: this.stops } } drawLegendSymbol(t, e) { let i = e.legendItem || {}, s = t.padding, o = t.options, r = this.options.labels, a = le(o.itemDistance, 10), n = this.horiz, { width: l, height: c } = this.getSize(), d = le(o.labelPadding, n ? 16 : 30); this.setLegendColor(), i.symbol || (i.symbol = this.chart.renderer.symbol("roundedRect").attr({ r: o.symbolRadius ?? 3, zIndex: 1 }).add(i.group)), i.symbol.attr({ x: 0, y: (t.baseline || 0) - 11, width: l, height: c }), i.labelWidth = l + s + (n ? a : le(r.x, r.distance) + (this.maxLabelLength || 0)), i.labelHeight = c + s + (n ? d : 0) } setState(t) { this.series.forEach(function (e) { e.setState(t) }) } setVisible() { } getSeriesExtremes() { let t = this.series, e, i, s, o, r = t.length; for (this.dataMin = 1 / 0, this.dataMax = -1 / 0; r--;) { for (let a of (i = (o = t[r]).colorKey = le(o.options.colorKey, o.colorKey, o.pointValKey, o.zoneAxis, "y"), s = o[i + "Min"] && o[i + "Max"], [i, "value", "y"])) if ((e = o.getColumn(a)).length) break; if (s) o.minColorValue = o[i + "Min"], o.maxColorValue = o[i + "Max"]; else { let a = Pl.prototype.getExtremes.call(o, e); o.minColorValue = a.dataMin, o.maxColorValue = a.dataMax } Us(o.minColorValue) && Us(o.maxColorValue) && (this.dataMin = Math.min(this.dataMin, o.minColorValue), this.dataMax = Math.max(this.dataMax, o.maxColorValue)), s || Pl.prototype.applyExtremes.call(o) } } drawCrosshair(t, e) { let i, s = this.legendItem || {}, o = e == null ? void 0 : e.plotX, r = e == null ? void 0 : e.plotY, a = this.pos, n = this.len; e && ((i = this.toPixels(e.getNestedProperty(e.series.colorKey))) < a ? i = a - 2 : i > a + n && (i = a + n + 2), e.plotX = i, e.plotY = this.len - i, super.drawCrosshair(t, e), e.plotX = o, e.plotY = r, this.cross && !this.cross.addedToColorAxis && s.group && (this.cross.addClass("highcharts-coloraxis-marker").add(s.group), this.cross.addedToColorAxis = !0, this.chart.styledMode || typeof this.crosshair != "object" || this.cross.attr({ fill: this.crosshair.color }))) } getPlotLinePath(t) { let e = this.left, i = t.translatedValue, s = this.top; return q0(i) ? this.horiz ? [["M", i - 4, s - 6], ["L", i + 4, s - 6], ["L", i, s], ["Z"]] : [["M", e, i], ["L", e - 6, i + 6], ["L", e - 6, i - 6], ["Z"]] : super.getPlotLinePath(t) } update(t, e) { var s; let i = this.chart.legend; this.series.forEach(o => { o.isDirtyData = !0 }), (t.dataClasses && i.allItems || this.dataClasses) && this.destroyItems(), super.update(t, e), (s = this.legendItem) != null && s.label && (this.setLegendColor(), i.colorizeItem(this, !0)) } destroyItems() { let t = this.chart, e = this.legendItem || {}; if (e.label) t.legend.destroyItem(this); else if (e.labels) for (let i of e.labels) t.legend.destroyItem(i); t.isDirtyLegend = !0 } destroy() { this.chart.isDirtyLegend = !0, this.destroyItems(), super.destroy(...[].slice.call(arguments)) } remove(t) { this.destroyItems(), super.remove(t) } getDataClassLegendSymbols() { let t, e = this, i = e.chart, s = e.legendItem && e.legendItem.labels || [], o = i.options.legend, r = le(o.valueDecimals, -1), a = le(o.valueSuffix, ""), n = l => e.series.reduce((c, d) => (c.push(...d.points.filter(p => p.dataClass === l)), c), []); return s.length || e.dataClasses.forEach((l, c) => { let d = l.from, p = l.to, { numberFormatter: u } = i, g = !0; t = "", d === void 0 ? t = "< " : p === void 0 && (t = "> "), d !== void 0 && (t += u(d, r) + a), d !== void 0 && p !== void 0 && (t += " - "), p !== void 0 && (t += u(p, r) + a), s.push(Ll({ chart: i, name: t, options: {}, drawLegendSymbol: sr.rectangle, visible: !0, isDataClass: !0, setState: m => { for (let f of n(c)) f.setState(m) }, setVisible: function () { this.visible = g = e.visible = !g; let m = []; for (let f of n(c)) f.setVisible(g), f.hiddenInDataClass = !g, m.indexOf(f.series) === -1 && m.push(f.series); i.legend.colorizeItem(this, g), m.forEach(f => { $0(f, "afterDataClassLegendClick") }) } }, l)) }), s } getSize() { let { chart: t, horiz: e } = this, { height: i, width: s } = this.options, { legend: o } = t.options; return { width: le(Us(s) ? El(s, t.chartWidth) : void 0, o == null ? void 0 : o.symbolWidth, e ? Nt.defaultLegendLength : 12), height: le(Us(i) ? El(i, t.chartHeight) : void 0, o == null ? void 0 : o.symbolHeight, e ? 12 : Nt.defaultLegendLength) } } } Nt.defaultLegendLength = 200, Nt.keepProps = ["legendItem"], Ll(Nt.prototype, Z0), Array.prototype.push.apply(xi.keepProps, Nt.keepProps), C.ColorAxis = C.ColorAxis || Nt, C.ColorAxis.compose(C.Chart, C.Fx, C.Legend, C.Series); let _0 = { lang: { zoomIn: "Zoom in", zoomOut: "Zoom out" }, mapNavigation: { buttonOptions: { alignTo: "plotBox", align: "left", verticalAlign: "top", x: 0, width: 18, height: 18, padding: 5, style: { color: "#666666", fontSize: "1em", fontWeight: "bold" }, theme: { fill: "#ffffff", stroke: "#e6e6e6", "stroke-width": 1, "text-align": "center" } }, buttons: { zoomIn: { onclick: function () { this.mapZoom(.5) }, text: "+", y: 0 }, zoomOut: { onclick: function () { this.mapZoom(2) }, text: "-", y: 28 } }, mouseWheelSensitivity: 1.1 } }, { defined: J0, extend: Il, pick: Q0, wrap: Dl } = I; (function (h) { let t, e = 0; function i(a) { let n = this.chart; a = this.normalize(a), n.options.mapNavigation.enableDoubleClickZoomTo ? n.pointer.inClass(a.target, "highcharts-tracker") && n.hoverPoint && n.hoverPoint.zoomTo() : n.isInsidePlot(a.chartX - n.plotLeft, a.chartY - n.plotTop) && n.mapZoom(.5, void 0, void 0, a.chartX, a.chartY) } function s(a) { let n = this.chart, l = J0((a = this.normalize(a)).wheelDelta) && -a.wheelDelta / 120 || a.deltaY || a.detail; Math.abs(l) >= 1 && (e += Math.abs(l), t && clearTimeout(t), t = setTimeout(() => { e = 0 }, 50)), e < 10 && n.isInsidePlot(a.chartX - n.plotLeft, a.chartY - n.plotTop) && n.mapView && n.mapView.zoomBy(-((n.options.mapNavigation.mouseWheelSensitivity - 1) * l), void 0, [a.chartX, a.chartY], !(1 > Math.abs(l)) && void 0) } function o(a, n, l) { let c = this.chart; if (n = a.call(this, n, l), c && c.mapView) { let d = c.mapView.pixelsToLonLat({ x: n.chartX - c.plotLeft, y: n.chartY - c.plotTop }); d && Il(n, d) } return n } function r(a) { let n = this.chart.options.mapNavigation; n && Q0(n.enableTouchZoom, n.enabled) && (this.chart.zooming.pinchType = "xy"), a.apply(this, [].slice.call(arguments, 1)) } h.compose = function (a) { let n = a.prototype; n.onContainerDblClick || (Il(n, { onContainerDblClick: i, onContainerMouseWheel: s }), Dl(n, "normalize", o), Dl(n, "zoomOption", r)) } })(go || (go = {})); let tg = go; function eg(h, t, e, i, s) { if (s) { let o = (s == null ? void 0 : s.r) || 0; s.brBoxY = t - o, s.brBoxHeight = i + o } return Le.roundedRect(h, t, e, i, s) } function ig(h, t, e, i, s) { if (s) { let o = (s == null ? void 0 : s.r) || 0; s.brBoxHeight = i + o } return Le.roundedRect(h, t, e, i, s) } let sg = { compose: function (h) { (Le = h.prototype.symbols).bottombutton = eg, Le.topbutton = ig } }, { setOptions: og } = wt, { composed: rg } = C, { addEvent: $e, extend: Bl, merge: Fr, objectEach: ag, pick: Xr, pushUnique: ng } = I; function Yr(h) { var t, e; h && ((t = h.preventDefault) == null || t.call(h), (e = h.stopPropagation) == null || e.call(h), h.cancelBubble = !0) } class js { static compose(t, e, i) { tg.compose(e), sg.compose(i), ng(rg, "Map.Navigation") && ($e(t, "beforeRender", function () { this.mapNavigation = new js(this), this.mapNavigation.update() }), og(_0)) } constructor(t) { this.chart = t, this.navButtons = [] } update(t) { var a; let e = this, i = e.chart, s = e.navButtons, o = function (n) { this.handler.call(i, n), Yr(n) }, r = i.options.mapNavigation; for (t && (r = i.options.mapNavigation = Fr(i.options.mapNavigation, t)); s.length;)(a = s.pop()) == null || a.destroy(); if (!i.renderer.forExport && Xr(r.enableButtons, r.enabled)) { e.navButtonsGroup || (e.navButtonsGroup = i.renderer.g().attr({ zIndex: 7 }).add()), ag(r.buttons, (l, c) => { var y; let d = { padding: (l = Fr(r.buttonOptions, l)).padding }; !i.styledMode && l.theme && (Bl(d, l.theme), d.style = Fr(l.theme.style, l.style)); let { text: p, width: u = 0, height: g = 0, padding: m = 0 } = l, f = i.renderer.button(p !== "+" && p !== "-" && p || "", 0, 0, o, d, void 0, void 0, void 0, c === "zoomIn" ? "topbutton" : "bottombutton").addClass("highcharts-map-navigation highcharts-" + { zoomIn: "zoom-in", zoomOut: "zoom-out" }[c]).attr({ width: u, height: g, title: i.options.lang[c], zIndex: 5 }).add(e.navButtonsGroup); if (p === "+" || p === "-") { let x = u + 1, b = [["M", m + 3, m + g / 2], ["L", m + x - 3, m + g / 2]]; p === "+" && b.push(["M", m + x / 2, m + 3], ["L", m + x / 2, m + g - 3]), i.renderer.path(b).addClass("highcharts-button-symbol").attr(i.styledMode ? {} : { stroke: (y = l.style) == null ? void 0 : y.color, "stroke-width": 3, "stroke-linecap": "round" }).add(f) } if (f.handler = l.onclick, $e(f.element, "dblclick", Yr), s.push(f), Bl(l, { width: f.width, height: 2 * (f.height || 0) }), i.hasLoaded) f.align(l, !1, l.alignTo); else { let x = $e(i, "load", () => { f.element && f.align(l, !1, l.alignTo), x() }) } }); let n = (l, c) => !(c.x >= l.x + l.width || c.x + c.width <= l.x || c.y >= l.y + l.height || c.y + c.height <= l.y); i.hasLoaded || $e(i, "render", function () { var c, d; let l = (d = (c = i.exporting) == null ? void 0 : c.group) == null ? void 0 : d.getBBox(); if (l) { let p = e.navButtonsGroup.getBBox(); if (n(l, p)) { let u = -p.y - p.height + l.y - 5, g = l.y + l.height - p.y + 5, m = r.buttonOptions && r.buttonOptions.verticalAlign; e.navButtonsGroup.attr({ translateY: m === "bottom" ? u : g }) } } }) } this.updateEvents(r) } updateEvents(t) { let e = this.chart; Xr(t.enableDoubleClickZoom, t.enabled) || t.enableDoubleClickZoomTo ? this.unbindDblClick = this.unbindDblClick || $e(e.container, "dblclick", function (i) { e.pointer.onContainerDblClick(i) }) : this.unbindDblClick && (this.unbindDblClick = this.unbindDblClick()), Xr(t.enableMouseWheelZoom, t.enabled) ? this.unbindMouseWheel = this.unbindMouseWheel || $e(e.container, "wheel", function (i) { var s, o; if (!e.pointer.inClass(i.target, "highcharts-no-mousewheel")) { let r = (s = e.mapView) == null ? void 0 : s.zoom; e.pointer.onContainerMouseWheel(i), r !== ((o = e.mapView) == null ? void 0 : o.zoom) && Yr(i) } return !1 }) : this.unbindMouseWheel && (this.unbindMouseWheel = this.unbindMouseWheel()) } } let { column: { prototype: lg } } = G.seriesTypes, { addEvent: hg, defined: dg } = I; (function (h) { function t(e) { let i = this.series, s = i.chart.renderer; this.moveToTopOnHover && this.graphic && (i.stateMarkerGraphic || (i.stateMarkerGraphic = new Dt(s, "use").css({ pointerEvents: "none" }).add(this.graphic.parentGroup)), (e == null ? void 0 : e.state) === "hover" ? (this.graphic.attr({ id: this.id }), i.stateMarkerGraphic.attr({ href: `${s.url}#${this.id}`, visibility: "visible" })) : i.stateMarkerGraphic.attr({ href: "" })) } h.pointMembers = { dataLabelOnNull: !0, moveToTopOnHover: !0, isValid: function () { return this.value !== null && this.value !== 1 / 0 && this.value !== -1 / 0 && (this.value === void 0 || !isNaN(this.value)) } }, h.seriesMembers = { colorKey: "value", axisTypes: ["xAxis", "yAxis", "colorAxis"], parallelArrays: ["x", "y", "value"], pointArrayMap: ["value"], trackerGroups: ["group", "markerGroup", "dataLabelsGroup"], colorAttribs: function (e) { let i = {}; return dg(e.color) && (!e.state || e.state === "normal") && (i[this.colorProp || "fill"] = e.color), i }, pointAttribs: lg.pointAttribs }, h.compose = function (e) { return hg(e.prototype.pointClass, "afterSetState", t), e } })(mo || (mo = {})); let xt = mo, { getOptions: cg } = wt, { isNumber: Ei, merge: pg, pick: zl } = I; class Hr extends xr { init(t, e) { let i = cg().credits, s = pg({ chart: { panning: { enabled: !0, type: "xy" }, type: "map" }, credits: { mapText: zl(i.mapText, ' © <Link to="{geojson.copyrightUrl}">{geojson.copyrightShort}</a>'), mapTextFull: zl(i.mapTextFull, "{geojson.copyright}") }, mapView: {}, tooltip: { followTouchMove: !1 } }, t); super.init(s, e) } mapZoom(t, e, i, s, o) { this.mapView && (Ei(t) && (t = Math.log(t) / Math.log(.5)), this.mapView.zoomBy(t, Ei(e) && Ei(i) ? this.mapView.projection.inverse([e, i]) : void 0, Ei(s) && Ei(o) ? [s, o] : void 0)) } update(t) { var e; t.chart && "map" in t.chart && ((e = this.mapView) == null || e.recommendMapView(this, [t.chart.map, ...(this.options.series || []).map(i => i.mapData)], !0)), super.update.apply(this, arguments) } } (function (h) { h.maps = {}, h.mapChart = function (t, e, i) { return new h(t, e, i) }, h.splitPath = function (t) { let e; return e = typeof t == "string" ? (t = t.replace(/([A-Z])/gi, " $1 ").replace(/^\s*/, "").replace(/\s*$/, "")).split(/[ ,;]+/).map(i => /[A-Z]/i.test(i) ? i : parseFloat(i)) : t, ye.prototype.pathToSegments(e) } })(Hr || (Hr = {})); let Rs = Hr, Nl = { boundsFromPath: function (h) { let t = -Number.MAX_VALUE, e = Number.MAX_VALUE, i = -Number.MAX_VALUE, s = Number.MAX_VALUE, o; if (h.forEach(r => { let a = r[r.length - 2], n = r[r.length - 1]; typeof a == "number" && typeof n == "number" && (e = Math.min(e, a), t = Math.max(t, a), s = Math.min(s, n), i = Math.max(i, n), o = !0) }), o) return { x1: e, y1: s, x2: t, y2: i } } }, { boundsFromPath: ug } = Nl, gg = G.seriesTypes.scatter.prototype.pointClass, { extend: Ul, isNumber: Ii, pick: jl } = I; class Ke extends gg { static getProjectedPath(t, e) { return t.projectedPath || (e && t.geometry ? (e.hasCoordinates = !0, t.projectedPath = e.path(t.geometry)) : t.projectedPath = t.path), t.projectedPath || [] } applyOptions(t, e) { let i = this.series, s = super.applyOptions(t, e), o = i.joinBy; if (i.mapData && i.mapMap) { let r = o[1], a = super.getNestedProperty(r), n = a !== void 0 && i.mapMap[a]; n ? Ul(s, { ...n, name: s.name ?? n.name }) : i.pointArrayMap.indexOf("value") !== -1 && (s.value = s.value || null) } return s } getProjectedBounds(t) { let e = ug(Ke.getProjectedPath(this, t)), i = this.properties, s = this.series.chart.mapView; if (e) { let o = i == null ? void 0 : i["hc-middle-lon"], r = i == null ? void 0 : i["hc-middle-lat"]; if (s && Ii(o) && Ii(r)) { let a = t.forward([o, r]); e.midX = a[0], e.midY = a[1] } else { let a = i == null ? void 0 : i["hc-middle-x"], n = i == null ? void 0 : i["hc-middle-y"]; e.midX = e.x1 + (e.x2 - e.x1) * jl(this.middleX, Ii(a) ? a : .5); let l = jl(this.middleY, Ii(n) ? n : .5); this.geometry || (l = 1 - l), e.midY = e.y2 - (e.y2 - e.y1) * l } return e } } onMouseOver(t) { I.clearTimeout(this.colorInterval), !this.isNull && this.visible || this.series.options.nullInteraction ? super.onMouseOver.call(this, t) : this.series.onMouseOut() } setVisible(t) { this.visible = this.options.visible = !!t, this.dataLabel && this.dataLabel[t ? "show" : "hide"](), this.graphic && this.graphic.attr(this.series.pointAttribs(this)) } zoomTo(t) { let e = this.series.chart, i = e.mapView, s = this.bounds; if (i && s) { let o = Ii(this.insetIndex) && i.insets[this.insetIndex]; if (o) { let r = o.projectedUnitsToPixels({ x: s.x1, y: s.y1 }), a = o.projectedUnitsToPixels({ x: s.x2, y: s.y2 }), n = i.pixelsToProjectedUnits({ x: r.x, y: r.y }), l = i.pixelsToProjectedUnits({ x: a.x, y: a.y }); s = { x1: n.x, y1: n.y, x2: l.x, y2: l.y } } i.fitToBounds(s, void 0, !1), this.series.isDirty = !0, e.redraw(t) } } } Ul(Ke.prototype, { dataLabelOnNull: xt.pointMembers.dataLabelOnNull, moveToTopOnHover: xt.pointMembers.moveToTopOnHover, isValid: xt.pointMembers.isValid }); let { isNumber: mg } = I, fg = { center: [0, 0], fitToGeometry: void 0, maxZoom: void 0, padding: 0, projection: { name: void 0, parallels: void 0, rotation: void 0 }, zoom: void 0, insetOptions: { borderColor: "#cccccc", borderWidth: 1, padding: "10%", relativeTo: "mapBoundingBox", units: "percent" } }, { win: Rl } = C, { format: Wl } = At, { error: Fl, extend: yg, merge: xg, wrap: bg } = I; (function (h) { function t(a) { return this.mapView && this.mapView.lonLatToProjectedUnits(a) } function e(a) { return this.mapView && this.mapView.projectedUnitsToLonLat(a) } function i(a, n) { let l = this.options.chart.proj4 || Rl.proj4; if (!l) return void Fl(21, !1, this); let { jsonmarginX: c = 0, jsonmarginY: d = 0, jsonres: p = 1, scale: u = 1, xoffset: g = 0, xpan: m = 0, yoffset: f = 0, ypan: y = 0 } = n, x = l(n.crs, [a.lon, a.lat]), b = n.cosAngle || n.rotation && Math.cos(n.rotation), w = n.sinAngle || n.rotation && Math.sin(n.rotation), v = n.rotation ? [x[0] * b + x[1] * w, -x[0] * w + x[1] * b] : x; return { x: ((v[0] - g) * u + m) * p + c, y: -(((f - v[1]) * u + y) * p - d) } } function s(a, n) { let l = this.options.chart.proj4 || Rl.proj4; if (!l) return void Fl(21, !1, this); if (a.y === null) return; let { jsonmarginX: c = 0, jsonmarginY: d = 0, jsonres: p = 1, scale: u = 1, xoffset: g = 0, xpan: m = 0, yoffset: f = 0, ypan: y = 0 } = n, x = { x: ((a.x - c) / p - m) / u + g, y: ((a.y - d) / p + y) / u + f }, b = n.cosAngle || n.rotation && Math.cos(n.rotation), w = n.sinAngle || n.rotation && Math.sin(n.rotation), v = l(n.crs, "WGS84", n.rotation ? { x: x.x * b + -(x.y * w), y: x.x * w + x.y * b } : x); return { lat: v.y, lon: v.x } } function o(a, n) { n || (n = Object.keys(a.objects)[0]); let l = a.objects[n]; if (l["hc-decoded-geojson"] && l["hc-decoded-geojson"].title === a.title) return l["hc-decoded-geojson"]; let c = a.arcs; if (a.transform) { let m, f, y, x = a.arcs, { scale: b, translate: w } = a.transform; c = []; for (let v = 0, S = x.length; v < S; ++v) { let A = x[v]; c.push(m = []), f = 0, y = 0; for (let M = 0, k = A.length; M < k; ++M)m.push([(f += A[M][0]) * b[0] + w[0], (y += A[M][1]) * b[1] + w[1]]) } } let d = m => typeof m[0] == "number" ? m.reduce((f, y, x) => { let b = y < 0 ? c[~y] : c[y]; return y < 0 ? (b = b.slice(0, x === 0 ? b.length : b.length - 1)).reverse() : x && (b = b.slice(1)), f.concat(b) }, []) : m.map(d), p = l.geometries, u = []; for (let m = 0, f = p.length; m < f; ++m)u.push({ type: "Feature", properties: p[m].properties, geometry: { type: p[m].type, coordinates: p[m].coordinates || d(p[m].arcs) } }); let g = { type: "FeatureCollection", copyright: a.copyright, copyrightShort: a.copyrightShort, copyrightUrl: a.copyrightUrl, features: u, "hc-recommended-mapview": l["hc-recommended-mapview"], bbox: a.bbox, title: a.title }; return l["hc-decoded-geojson"] = g, g } function r(a, n) { n = xg(!0, this.options.credits, n), a.call(this, n), this.credits && this.mapCreditsFull && this.credits.attr({ title: this.mapCreditsFull }) } h.compose = function (a) { let n = a.prototype; n.transformFromLatLon || (n.fromLatLonToPoint = t, n.fromPointToLatLon = e, n.transformFromLatLon = i, n.transformToLatLon = s, bg(n, "addCredits", r)) }, h.geojson = function (a, n = "map", l) { var u, g; let c = [], d = a.type === "Topology" ? o(a) : a, p = d.features; for (let m = 0, f = p.length; m < f; ++m) { let y, x = p[m], b = x.geometry || {}, w = b.type, v = b.coordinates, S = x.properties; if ((n === "map" || n === "mapbubble") && (w === "Polygon" || w === "MultiPolygon") || n === "mapline" && (w === "LineString" || w === "MultiLineString") ? v.length && (y = { geometry: { coordinates: v, type: w } }) : n === "mappoint" && w === "Point" && v.length && (y = { geometry: { coordinates: v, type: w } }), y) { let A = S && (S.name || S.NAME), M = S && S.lon, k = S && S.lat; c.push(yg(y, { lat: typeof k == "number" ? k : void 0, lon: typeof M == "number" ? M : void 0, name: typeof A == "string" ? A : void 0, properties: S })) } } return l && d.copyrightShort && (l.chart.mapCredits = Wl((u = l.chart.options.credits) == null ? void 0 : u.mapText, { geojson: d }), l.chart.mapCreditsFull = Wl((g = l.chart.options.credits) == null ? void 0 : g.mapTextFull, { geojson: d })), c }, h.topo2geo = o })(fo || (fo = {})); let Ws = fo; function Xl(h, t, e = !0) { let i = t[t.length - 1], s, o, r, a = h; for (let n = 0; n < t.length; n++) { let l = a; s = t[n], a = [], o = e ? l[l.length - 1] : l[0]; for (let c = 0; c < l.length; c++)Gr(i, s, r = l[c]) ? (Gr(i, s, o) || a.push(Yl(i, s, o, r)), a.push(r)) : Gr(i, s, o) && a.push(Yl(i, s, o, r)), o = r; i = s } return a } function Gr(h, t, e) { return (t[0] - h[0]) * (e[1] - h[1]) > (t[1] - h[1]) * (e[0] - h[0]) } function Yl(h, t, e, i) { let s = [h[0] - t[0], h[1] - t[1]], o = [e[0] - i[0], e[1] - i[1]], r = h[0] * t[1] - h[1] * t[0], a = e[0] * i[1] - e[1] * i[0], n = 1 / (s[0] * o[1] - s[1] * o[0]), l = [(r * o[0] - a * s[0]) * n, (r * o[1] - a * s[1]) * n]; return l.isIntersection = !0, l } let Di = Math.sign || (h => h === 0 ? 0 : h > 0 ? 1 : -1), Bi = Math.PI / 180, qe = Math.PI / 2, Fs = h => Math.tan((qe + h) / 2), vg = class { constructor(h) { let t = (h.parallels || []).map(r => r * Bi), e = t[0] || 0, i = t[1] ?? e, s = Math.cos(e); typeof h.projectedBounds == "object" && (this.projectedBounds = h.projectedBounds); let o = e === i ? Math.sin(e) : Math.log(s / Math.cos(i)) / Math.log(Fs(i) / Fs(e)); 1e-10 > Math.abs(o) && (o = 1e-10 * (Di(o) || 1)), this.n = o, this.c = s * Math.pow(Fs(e), o) / o } forward(h) { let { c: t, n: e, projectedBounds: i } = this, s = h[0] * Bi, o = h[1] * Bi; t > 0 ? o < -qe + 1e-6 && (o = -qe + 1e-6) : o > qe - 1e-6 && (o = qe - 1e-6); let r = t / Math.pow(Fs(o), e), a = r * Math.sin(e * s) * 63.78137, n = (t - r * Math.cos(e * s)) * 63.78137, l = [a, n]; return i && (a < i.x1 || a > i.x2 || n < i.y1 || n > i.y2) && (l.outside = !0), l } inverse(h) { let { c: t, n: e } = this, i = h[0] / 63.78137, s = t - h[1] / 63.78137, o = Di(e) * Math.sqrt(i * i + s * s), r = Math.atan2(i, Math.abs(s)) * Di(s); return s * e < 0 && (r -= Math.PI * Di(i) * Di(s)), [r / e / Bi, (2 * Math.atan(Math.pow(t / o, 1 / e)) - qe) / Bi] } }, Xs = Math.sqrt(3) / 2, wg = class { constructor() { this.bounds = { x1: -200.37508342789243, x2: 200.37508342789243, y1: -97.52595454902263, y2: 97.52595454902263 } } forward(h) { let t = Math.PI / 180, e = Math.asin(Xs * Math.sin(h[1] * t)), i = e * e, s = i * i * i; return [h[0] * t * Math.cos(e) * 74.03120656864502 / (Xs * (1.340264 + -.24331799999999998 * i + s * (.0062510000000000005 + .034164 * i))), 74.03120656864502 * e * (1.340264 + -.081106 * i + s * (893e-6 + .003796 * i))] } inverse(h) { let t = h[0] / 74.03120656864502, e = h[1] / 74.03120656864502, i = 180 / Math.PI, s = e, o, r, a, n; for (let d = 0; d < 12 && (r = (o = s * s) * o * o, a = s * (1.340264 + -.081106 * o + r * (893e-6 + .003796 * o)) - e, s -= n = a / (1.340264 + -.24331799999999998 * o + r * (.0062510000000000005 + .034164 * o)), !(1e-9 > Math.abs(n))); ++d); r = (o = s * s) * o * o; let l = i * Xs * t * (1.340264 + -.24331799999999998 * o + r * (.0062510000000000005 + .034164 * o)) / Math.cos(s), c = i * Math.asin(Math.sin(s) / Xs); return Math.abs(l) > 180 ? [NaN, NaN] : [l, c] } }, Hl = Math.PI / 4, Ys = Math.PI / 180, Sg = class { constructor() { this.bounds = { x1: -200.37508342789243, x2: 200.37508342789243, y1: -146.91480769173063, y2: 146.91480769173063 } } forward(h) { return [h[0] * Ys * 63.78137, 79.7267125 * Math.log(Math.tan(Hl + .4 * h[1] * Ys))] } inverse(h) { return [h[0] / 63.78137 / Ys, 2.5 * (Math.atan(Math.exp(.8 * (h[1] / 63.78137))) - Hl) / Ys] } }, Hs = Math.PI / 180, Mg = class { constructor() { this.antimeridianCutting = !1, this.bounds = { x1: -63.78460826781007, x2: 63.78460826781007, y1: -63.78460826781007, y2: 63.78460826781007 } } forward(h) { let t = h[0], e = h[1] * Hs, i = [Math.cos(e) * Math.sin(t * Hs) * 63.78460826781007, 63.78460826781007 * Math.sin(e)]; return (t < -90 || t > 90) && (i.outside = !0), i } inverse(h) { let t = h[0] / 63.78460826781007, e = h[1] / 63.78460826781007, i = Math.sqrt(t * t + e * e), s = Math.asin(i), o = Math.sin(s); return [Math.atan2(t * o, i * Math.cos(s)) / Hs, Math.asin(i && e * o / i) / Hs] } }, Gs = Math.PI / 180, kg = class { constructor() { this.bounds = { x1: -200.37508342789243, x2: 200.37508342789243, y1: -200.3750834278071, y2: 200.3750834278071 }, this.maxLatitude = 85.0511287798 } forward(h) { let t = Math.sin(h[1] * Gs), e = [63.78137 * h[0] * Gs, 63.78137 * Math.log((1 + t) / (1 - t)) / 2]; return Math.abs(h[1]) > this.maxLatitude && (e.outside = !0), e } inverse(h) { return [h[0] / (63.78137 * Gs), (2 * Math.atan(Math.exp(h[1] / 63.78137)) - Math.PI / 2) / Gs] } }, { clipLineString: Ag, clipPolygon: Cg } = { clipLineString: function (h, t) { let e = [], i = Xl(h, t, !1); for (let s = 1; s < i.length; s++)i[s].isIntersection && i[s - 1].isIntersection && (e.push(i.splice(0, s)), s = 0), s === i.length - 1 && e.push(i); return e }, clipPolygon: Xl }, { clamp: Tg, erase: Pg } = I, nt = 2 * Math.PI / 360, _e = h => (h < -180 && (h += 360), h > 180 && (h -= 360), h), Gl = h => (1 - Math.cos(h)) / 2, Lg = (h, t) => { let e = Math.cos, i = h[1] * nt, s = h[0] * nt, o = t[1] * nt, r = t[0] * nt; return Gl(o - i) + e(i) * e(o) * Gl(r - s) }; class bt { static add(t, e) { bt.registry[t] = e } static distance(t, e) { let { atan2: i, sqrt: s } = Math, o = Lg(t, e); return 6371e3 * (2 * i(s(o), s(1 - o))) } static geodesic(t, e, i, s = 5e5) { let { atan2: o, cos: r, sin: a, sqrt: n } = Math, l = bt.distance, c = t[1] * nt, d = t[0] * nt, p = e[1] * nt, u = e[0] * nt, g = r(c) * r(d), m = r(p) * r(u), f = r(c) * a(d), y = r(p) * a(u), x = a(c), b = a(p), w = l(t, e), v = w / 6371e3, S = a(v), A = Math.round(w / s), M = []; if (i && M.push(t), A > 1) { let k = 1 / A; for (let T = k; T < .999; T += k) { let P = a((1 - T) * v) / S, L = a(T * v) / S, O = P * g + L * m, B = P * f + L * y, D = o(P * x + L * b, n(O * O + B * B)), z = o(B, O); M.push([z / nt, D / nt]) } } return i && M.push(e), M } static insertGeodesics(t) { let e = t.length - 1; for (; e--;)if (Math.max(Math.abs(t[e][0] - t[e + 1][0]), Math.abs(t[e][1] - t[e + 1][1])) > 10) { let i = bt.geodesic(t[e], t[e + 1]); i.length && t.splice(e + 1, 0, ...i) } } static toString(t) { let { name: e, rotation: i } = t || {}; return [e, i && i.join(",")].join(";") } constructor(t = {}) { this.hasCoordinates = !1, this.hasGeoProjection = !1, this.maxLatitude = 90, this.options = t; let { name: e, projectedBounds: i, rotation: s } = t; this.rotator = s ? this.getRotator(s) : void 0; let o = e ? bt.registry[e] : void 0; o && (this.def = new o(t)); let { def: r, rotator: a } = this; r && (this.maxLatitude = r.maxLatitude || 90, this.hasGeoProjection = !0), a && r ? (this.forward = n => r.forward(a.forward(n)), this.inverse = n => a.inverse(r.inverse(n))) : r ? (this.forward = n => r.forward(n), this.inverse = n => r.inverse(n)) : a && (this.forward = a.forward, this.inverse = a.inverse), this.bounds = i === "world" ? r && r.bounds : i } lineIntersectsBounds(t) { let { x1: e, x2: i, y1: s, y2: o } = this.bounds || {}, r = (l, c, d) => { let [p, u] = l, g = +!c; if (typeof d == "number" && p[c] >= d != u[c] >= d) { let m = (d - p[c]) / (u[c] - p[c]), f = p[g] + m * (u[g] - p[g]); return c ? [f, d] : [d, f] } }, a, n = t[0]; return ((a = r(t, 0, e)) || (a = r(t, 0, i))) && (n = a, t[1] = a), ((a = r(t, 1, s)) || (a = r(t, 1, o))) && (n = a), n } getRotator(t) { let e = t[0] * nt, i = (t[1] || 0) * nt, s = (t[2] || 0) * nt, o = Math.cos(i), r = Math.sin(i), a = Math.cos(s), n = Math.sin(s); if (e !== 0 || i !== 0 || s !== 0) return { forward: l => { let c = l[0] * nt + e, d = l[1] * nt, p = Math.cos(d), u = Math.cos(c) * p, g = Math.sin(c) * p, m = Math.sin(d), f = m * o + u * r; return [Math.atan2(g * a - f * n, u * o - m * r) / nt, Math.asin(f * a + g * n) / nt] }, inverse: l => { let c = l[0] * nt, d = l[1] * nt, p = Math.cos(d), u = Math.cos(c) * p, g = Math.sin(c) * p, m = Math.sin(d), f = m * a - g * n; return [(Math.atan2(g * a + m * n, u * o + f * r) - e) / nt, Math.asin(f * o - u * r) / nt] } } } forward(t) { return t } inverse(t) { return t } cutOnAntimeridian(t, e) { let i, s = [], o = [t]; for (let r = 0, a = t.length; r < a; ++r) { let n = t[r], l = t[r - 1]; if (!r) { if (!e) continue; l = t[t.length - 1] } let c = l[0], d = n[0]; if ((c < -90 || c > 90) && (d < -90 || d > 90) && c > 0 != d > 0) { let p = Tg((180 - (c + 360) % 360) / ((d + 360) % 360 - (c + 360) % 360), 0, 1), u = l[1] + p * (n[1] - l[1]); s.push({ i: r, lat: u, direction: c < 0 ? 1 : -1, previousLonLat: l, lonLat: n }) } } if (s.length) if (e) { s.length % 2 == 1 && (i = s.slice().sort((a, n) => Math.abs(n.lat) - Math.abs(a.lat))[0], Pg(s, i)); let r = s.length - 2; for (; r >= 0;) { let a = s[r].i, n = _e(180 + 1e-6 * s[r].direction), l = _e(180 - 1e-6 * s[r].direction), c = t.splice(a, s[r + 1].i - a, ...bt.geodesic([n, s[r].lat], [n, s[r + 1].lat], !0)); c.push(...bt.geodesic([l, s[r + 1].lat], [l, s[r].lat], !0)), o.push(c), r -= 2 } if (i) for (let a = 0; a < o.length; a++) { let { direction: n, lat: l } = i, c = o[a], d = c.indexOf(i.lonLat); if (d > -1) { let p = (l < 0 ? -1 : 1) * this.maxLatitude, u = _e(180 + 1e-6 * n), g = _e(180 - 1e-6 * n), m = bt.geodesic([u, l], [u, p], !0); for (let f = u + 120 * n; f > -180 && f < 180; f += 120 * n)m.push([f, p]); m.push(...bt.geodesic([g, p], [g, i.lat], !0)), c.splice(d, 0, ...m); break } } } else { let r = s.length; for (; r--;) { let a = s[r].i, n = t.splice(a, t.length, [_e(180 + 1e-6 * s[r].direction), s[r].lat]); n.unshift([_e(180 - 1e-6 * s[r].direction), s[r].lat]), o.push(n) } } return o } path(t) { let e, { bounds: i, def: s, rotator: o } = this, r = [], a = t.type === "Polygon" || t.type === "MultiPolygon", n = this.hasGeoProjection, l = !s || s.antimeridianCutting !== !1, c = l ? o : void 0, d = l && s || this; i && (e = [[i.x1, i.y1], [i.x2, i.y1], [i.x2, i.y2], [i.x1, i.y2]]); let p = u => { let g = u.map(f => { if (l) { c && (f = c.forward(f)); let y = f[0]; 1e-6 > Math.abs(y - 180) && (y = y < 180 ? 179.999999 : 180.000001), f = [y, f[1]] } return f }), m = [g]; n && (bt.insertGeodesics(g), l && (m = this.cutOnAntimeridian(g, a))), m.forEach(f => { let y, x; if (f.length < 2) return; let b = !1, w = !1, v = k => { b ? r.push(["L", k[0], k[1]]) : (r.push(["M", k[0], k[1]]), b = !0) }, S = !1, A = !1, M = f.map(k => { let T = d.forward(k); return T.outside ? S = !0 : A = !0, T[1] === 1 / 0 ? T[1] = 1e10 : T[1] === -1 / 0 && (T[1] = -1e10), T }); if (l) { if (a && M.push(M[0]), S) { if (!A) return; if (e) { if (a) M = Cg(M, e); else if (i) return void Ag(M, e).forEach(k => { b = !1, k.forEach(v) }) } } M.forEach(v) } else for (let k = 0; k < M.length; k++) { let T = f[k], P = M[k]; P.outside ? w = !0 : (a && !y && (y = T, f.push(T), M.push(P)), w && x && (a && n ? bt.geodesic(x, T).forEach(L => v(d.forward(L))) : b = !1), v(P), x = T, w = !1) } }) }; return t.type === "LineString" ? p(t.coordinates) : t.type === "MultiLineString" ? t.coordinates.forEach(u => p(u)) : t.type === "Polygon" ? (t.coordinates.forEach(u => p(u)), r.length && r.push(["Z"])) : t.type === "MultiPolygon" && (t.coordinates.forEach(u => { u.forEach(g => p(g)) }), r.length && r.push(["Z"])), r } } bt.registry = { EqualEarth: wg, LambertConformalConic: vg, Miller: Sg, Orthographic: Mg, WebMercator: kg }; let { composed: Og } = C, { pointInPolygon: zi } = yl, { topo2geo: Vl } = Ws, { boundsFromPath: Zl } = Nl, { addEvent: ke, clamp: Eg, crisp: $l, fireEvent: Kl, isArray: Ig, isNumber: Yt, isObject: Dg, isString: Bg, merge: qt, pick: zg, pushUnique: Ng, relativeLength: he } = I, Ni = {}; function ql(h, t) { let { width: e, height: i } = t; return Math.log(400.979322 / Math.max((h.x2 - h.x1) / (e / 256), (h.y2 - h.y1) / (i / 256))) / Math.log(2) } function _l(h) { var t, e; h.seriesOptions.mapData && ((e = this.mapView) == null || e.recommendMapView(this, [this.options.chart.map, h.seriesOptions.mapData], (t = this.options.drilldown) == null ? void 0 : t.mapZooming)) } class Ht { static compose(t) { Ng(Og, "MapView") && (Ni = t.maps, ke(t, "afterInit", function () { this.mapView = new Ht(this, this.options.mapView) }, { order: 0 }), ke(t, "addSeriesAsDrilldown", _l), ke(t, "afterDrillUp", _l)) } static compositeBounds(t) { if (t.length) return t.slice(1).reduce((e, i) => (e.x1 = Math.min(e.x1, i.x1), e.y1 = Math.min(e.y1, i.y1), e.x2 = Math.max(e.x2, i.x2), e.y2 = Math.max(e.y2, i.y2), e), qt(t[0])) } static mergeInsets(t, e) { let i = o => { let r = {}; return o.forEach((a, n) => { r[a && a.id || `i${n}`] = a }), r }, s = qt(i(t), i(e)); return Object.keys(s).map(o => s[o]) } constructor(t, e) { var r; this.allowTransformAnimation = !0, this.eventsToUnbind = [], this.insets = [], this.padding = [0, 0, 0, 0], this.recommendedMapView = {}, this instanceof Jl || this.recommendMapView(t, [t.options.chart.map, ...(t.options.series || []).map(a => a.mapData)]), this.userOptions = e || {}; let i = qt(fg, this.recommendedMapView, e), s = (r = this.recommendedMapView) == null ? void 0 : r.insets, o = e && e.insets; s && o && (i.insets = Ht.mergeInsets(s, o)), this.chart = t, this.center = i.center, this.options = i, this.projection = new bt(i.projection), this.playingField = t.plotBox, this.zoom = i.zoom || 0, this.minZoom = i.minZoom, this.createInsets(), this.eventsToUnbind.push(ke(t, "afterSetChartSize", () => { this.playingField = this.getField(), (this.minZoom === void 0 || this.minZoom === this.zoom) && (this.fitToBounds(void 0, void 0, !1), !this.chart.hasRendered && Yt(this.userOptions.zoom) && (this.zoom = this.userOptions.zoom), this.userOptions.center && qt(!0, this.center, this.userOptions.center)) })), this.setUpEvents() } createInsets() { let t = this.options, e = t.insets; e && e.forEach(i => { let s = new Jl(this, qt(t.insetOptions, i)); this.insets.push(s) }) } fitToBounds(t, e, i = !0, s) { let o = t || this.getProjectedBounds(); if (o) { let r = zg(e, t ? 0 : this.options.padding), a = this.getField(!1), n = Ig(r) ? r : [r, r, r, r]; this.padding = [he(n[0], a.height), he(n[1], a.width), he(n[2], a.height), he(n[3], a.width)], this.playingField = this.getField(); let l = ql(o, this.playingField); t || (this.minZoom = l); let c = this.projection.inverse([(o.x2 + o.x1) / 2, (o.y2 + o.y1) / 2]); this.setView(c, l, i, s) } } getField(t = !0) { let e = t ? this.padding : [0, 0, 0, 0]; return { x: e[3], y: e[0], width: this.chart.plotWidth - e[1] - e[3], height: this.chart.plotHeight - e[0] - e[2] } } getGeoMap(t) { if (Bg(t)) return Ni[t] && Ni[t].type === "Topology" ? Vl(Ni[t]) : Ni[t]; if (Dg(t, !0)) { if (t.type === "FeatureCollection") return t; if (t.type === "Topology") return Vl(t) } } getMapBBox() { let t = this.getProjectedBounds(), e = this.getScale(); if (t) { let i = this.padding, s = this.projectedUnitsToPixels({ x: t.x1, y: t.y2 }); return { width: (t.x2 - t.x1) * e + i[1] + i[3], height: (t.y2 - t.y1) * e + i[0] + i[2], x: s.x - i[3], y: s.y - i[0] } } } getProjectedBounds() { let t = this.projection, e = this.chart.series.reduce((s, o) => { let r = o.getProjectedBounds && o.getProjectedBounds(); return r && o.options.affectsMapView !== !1 && s.push(r), s }, []), i = this.options.fitToGeometry; if (i) { if (!this.fitToGeometryCache) if (i.type === "MultiPoint") { let s = i.coordinates.map(a => t.forward(a)), o = s.map(a => a[0]), r = s.map(a => a[1]); this.fitToGeometryCache = { x1: Math.min.apply(0, o), x2: Math.max.apply(0, o), y1: Math.min.apply(0, r), y2: Math.max.apply(0, r) } } else this.fitToGeometryCache = Zl(t.path(i)); return this.fitToGeometryCache } return this.projection.bounds || Ht.compositeBounds(e) } getScale() { return 256 / 400.979322 * Math.pow(2, this.zoom) } getSVGTransform() { let { x: t, y: e, width: i, height: s } = this.playingField, o = this.projection.forward(this.center), r = this.projection.hasCoordinates ? -1 : 1, a = this.getScale(), n = a * r, l = t + i / 2 - o[0] * a, c = e + s / 2 - o[1] * n; return { scaleX: a, scaleY: n, translateX: l, translateY: c } } lonLatToPixels(t) { let e = this.lonLatToProjectedUnits(t); if (e) return this.projectedUnitsToPixels(e) } lonLatToProjectedUnits(t) { let e = this.chart, i = e.mapTransforms; if (i) { for (let o in i) if (Object.hasOwnProperty.call(i, o) && i[o].hitZone) { let r = e.transformFromLatLon(t, i[o]); if (r && zi(r, i[o].hitZone.coordinates[0])) return r } return e.transformFromLatLon(t, i.default) } for (let o of this.insets) if (o.options.geoBounds && zi({ x: t.lon, y: t.lat }, o.options.geoBounds.coordinates[0])) { let r = o.projection.forward([t.lon, t.lat]), a = o.projectedUnitsToPixels({ x: r[0], y: r[1] }); return this.pixelsToProjectedUnits(a) } let s = this.projection.forward([t.lon, t.lat]); if (!s.outside) return { x: s[0], y: s[1] } } projectedUnitsToLonLat(t) { let e = this.chart, i = e.mapTransforms; if (i) { for (let r in i) if (Object.hasOwnProperty.call(i, r) && i[r].hitZone && zi(t, i[r].hitZone.coordinates[0])) return e.transformToLatLon(t, i[r]); return e.transformToLatLon(t, i.default) } let s = this.projectedUnitsToPixels(t); for (let r of this.insets) if (r.hitZone && zi(s, r.hitZone.coordinates[0])) { let a = r.pixelsToProjectedUnits(s), n = r.projection.inverse([a.x, a.y]); return { lon: n[0], lat: n[1] } } let o = this.projection.inverse([t.x, t.y]); return { lon: o[0], lat: o[1] } } recommendMapView(t, e, i = !1) { var a; this.recommendedMapView = {}; let s = e.map(n => this.getGeoMap(n)), o = []; s.forEach(n => { if (n && (Object.keys(this.recommendedMapView).length || (this.recommendedMapView = n["hc-recommended-mapview"] || {}), n.bbox)) { let [l, c, d, p] = n.bbox; o.push({ x1: l, y1: c, x2: d, y2: p }) } }); let r = o.length && Ht.compositeBounds(o); Kl(this, "onRecommendMapView", { geoBounds: r, chart: t }, function () { if (r && this.recommendedMapView) { if (!this.recommendedMapView.projection) { let { x1: n, y1: l, x2: c, y2: d } = r; this.recommendedMapView.projection = c - n > 180 && d - l > 90 ? { name: "EqualEarth", parallels: [0, 0], rotation: [0] } : { name: "LambertConformalConic", parallels: [l, d], rotation: [-(n + c) / 2] } } this.recommendedMapView.insets || (this.recommendedMapView.insets = void 0) } }), this.geoMap = s[0], i && t.hasRendered && !((a = t.userOptions.mapView) != null && a.projection) && this.recommendedMapView && this.update(this.recommendedMapView) } redraw(t) { this.chart.series.forEach(e => { e.useMapGeometry && (e.isDirty = !0) }), this.chart.redraw(t) } setView(t, e, i = !0, s) { t && (this.center = t), typeof e == "number" && (typeof this.minZoom == "number" && (e = Math.max(e, this.minZoom)), typeof this.options.maxZoom == "number" && (e = Math.min(e, this.options.maxZoom)), Yt(e) && (this.zoom = e)); let o = this.getProjectedBounds(); if (o) { let r = this.projection.forward(this.center), { x: a, y: n, width: l, height: c } = this.playingField, d = this.getScale(), p = this.projectedUnitsToPixels({ x: o.x1, y: o.y1 }), u = this.projectedUnitsToPixels({ x: o.x2, y: o.y2 }), g = [(o.x1 + o.x2) / 2, (o.y1 + o.y2) / 2]; if (!this.chart.series.some(m => m.isDrilling)) { let m = p.x, f = u.y, y = u.x, x = p.y; y - m < l ? r[0] = g[0] : m < a && y < a + l ? r[0] += Math.max(m - a, y - l - a) / d : y > a + l && m > a && (r[0] += Math.min(y - l - a, m - a) / d), x - f < c ? r[1] = g[1] : f < n && x < n + c ? r[1] -= Math.max(f - n, x - c - n) / d : x > n + c && f > n && (r[1] -= Math.min(x - c - n, f - n) / d), this.center = this.projection.inverse(r) } this.insets.forEach(m => { m.options.field && (m.hitZone = m.getHitZone(), m.playingField = m.getField()) }), this.render() } Kl(this, "afterSetView"), i && this.redraw(s) } projectedUnitsToPixels(t) { let e = this.getScale(), i = this.projection.forward(this.center), s = this.playingField, o = s.x + s.width / 2, r = s.y + s.height / 2; return { x: o - e * (i[0] - t.x), y: r + e * (i[1] - t.y) } } pixelsToLonLat(t) { return this.projectedUnitsToLonLat(this.pixelsToProjectedUnits(t)) } pixelsToProjectedUnits(t) { let { x: e, y: i } = t, s = this.getScale(), o = this.projection.forward(this.center), r = this.playingField, a = r.x + r.width / 2, n = r.y + r.height / 2; return { x: o[0] + (e - a) / s, y: o[1] - (i - n) / s } } setUpEvents() { let t, e, i, { chart: s } = this, o = r => { let { lastTouches: a, pinchDown: n } = s.pointer, l = this.projection, c = r.touches, { mouseDownX: d, mouseDownY: p } = s, u = 0; if ((n == null ? void 0 : n.length) === 1 ? (d = n[0].chartX, p = n[0].chartY) : (n == null ? void 0 : n.length) === 2 && (d = (n[0].chartX + n[1].chartX) / 2, p = (n[0].chartY + n[1].chartY) / 2), (c == null ? void 0 : c.length) === 2 && a && (u = Math.log(Math.sqrt(Math.pow(a[0].chartX - a[1].chartX, 2) + Math.pow(a[0].chartY - a[1].chartY, 2)) / Math.sqrt(Math.pow(c[0].chartX - c[1].chartX, 2) + Math.pow(c[0].chartY - c[1].chartY, 2))) / Math.log(.5)), Yt(d) && Yt(p)) { let g = `${d},${p}`, { chartX: m, chartY: f } = r.originalEvent; (c == null ? void 0 : c.length) === 2 && (m = (c[0].chartX + c[1].chartX) / 2, f = (c[0].chartY + c[1].chartY) / 2), g !== e && (e = g, t = this.projection.forward(this.center), i = (this.projection.options.rotation || [0, 0]).slice()); let y = l.def && l.def.bounds, x = y && ql(y, this.playingField) || -1 / 0; if (l.options.name === "Orthographic" && 2 > ((c == null ? void 0 : c.length) || 0) && (this.minZoom || 1 / 0) < 1.3 * x) { let b = 440 / (this.getScale() * Math.min(s.plotWidth, s.plotHeight)); if (i) { let w = (d - m) * b - i[0], v = Eg(-i[1] - (p - f) * b, -80, 80), S = this.zoom; this.update({ projection: { rotation: [-w, -v] } }, !1), this.fitToBounds(void 0, void 0, !1), this.zoom = S, s.redraw(!1) } } else if (Yt(m) && Yt(f)) { let b = this.getScale(), w = this.projection.hasCoordinates ? 1 : -1, v = this.projection.inverse([t[0] + (d - m) / b, t[1] - (p - f) / b * w]); isNaN(v[0] + v[1]) || this.zoomBy(u, v, void 0, !1) } r.preventDefault() } }; ke(s, "pan", o), ke(s, "touchpan", o), ke(s, "selection", r => { if (r.resetSelection) this.zoomBy(); else { let a = r.x - s.plotLeft, n = r.y - s.plotTop, { y: l, x: c } = this.pixelsToProjectedUnits({ x: a, y: n }), { y: d, x: p } = this.pixelsToProjectedUnits({ x: a + r.width, y: n + r.height }); this.fitToBounds({ x1: c, y1: l, x2: p, y2: d }, void 0, !0, !r.originalEvent.touches && void 0), /^touch/.test(r.originalEvent.type) || s.showResetZoom(), r.preventDefault() } }) } render() { this.group || (this.group = this.chart.renderer.g("map-view").attr({ zIndex: 4 }).add()) } update(t, e = !0, i) { let s = t.projection, o = s && bt.toString(s) !== bt.toString(this.options.projection), r = !1; qt(!0, this.userOptions, t), qt(!0, this.options, t), "insets" in t && (this.insets.forEach(a => a.destroy()), this.insets.length = 0, r = !0), (o || "fitToGeometry" in t) && delete this.fitToGeometryCache, (o || r) && (this.chart.series.forEach(a => { let n = a.transformGroups; if (a.clearBounds && a.clearBounds(), a.isDirty = !0, a.isDirtyData = !0, r && n) for (; n.length > 1;) { let l = n.pop(); l && l.destroy() } }), o && (this.projection = new bt(this.options.projection)), r && this.createInsets(), !t.center && Object.hasOwnProperty.call(t, "zoom") && !Yt(t.zoom) && this.fitToBounds(void 0, void 0, !1)), t.center || Yt(t.zoom) ? this.setView(this.options.center, t.zoom, !1) : "fitToGeometry" in t && this.fitToBounds(void 0, void 0, !1), e && this.chart.redraw(i) } zoomBy(t, e, i, s) { let o = this.chart, r = this.projection.forward(this.center); if (typeof t == "number") { let a, n, l, c = this.zoom + t; if (i) { let [d, p] = i, u = this.getScale(), g = d - o.plotLeft - o.plotWidth / 2, m = p - o.plotTop - o.plotHeight / 2; n = r[0] + g / u, l = r[1] + m / u } if (typeof n == "number" && typeof l == "number") { let d = 1 - Math.pow(2, this.zoom) / Math.pow(2, c), p = r[0] - n, u = r[1] - l; r[0] -= p * d, r[1] += u * d, a = this.projection.inverse(r) } this.setView(e || a, c, void 0, s) } else this.fitToBounds(void 0, void 0, void 0, s) } } class Jl extends Ht { constructor(t, e) { if (super(t.chart, e), this.id = e.id, this.mapView = t, this.options = qt({ center: [0, 0] }, t.options.insetOptions, e), this.allBounds = [], this.options.geoBounds) { let i = t.projection.path(this.options.geoBounds); this.geoBoundsProjectedBox = Zl(i), this.geoBoundsProjectedPolygon = i.map(s => [s[1] || 0, s[2] || 0]) } } getField(t = !0) { let e = this.hitZone; if (e) { let i = t ? this.padding : [0, 0, 0, 0], s = e.coordinates[0], o = s.map(d => d[0]), r = s.map(d => d[1]), a = Math.min.apply(0, o) + i[3], n = Math.max.apply(0, o) - i[1], l = Math.min.apply(0, r) + i[0], c = Math.max.apply(0, r) - i[2]; if (Yt(a) && Yt(l)) return { x: a, y: l, width: n - a, height: c - l } } return super.getField.call(this, t) } getHitZone() { let { chart: t, mapView: e, options: i } = this, { coordinates: s } = i.field || {}; if (s) { let o = s[0]; if (i.units === "percent") { let r = i.relativeTo === "mapBoundingBox" && e.getMapBBox() || qt(t.plotBox, { x: 0, y: 0 }); o = o.map(a => [he(`${a[0]}%`, r.width, r.x), he(`${a[1]}%`, r.height, r.y)]) } return { type: "Polygon", coordinates: [o] } } } getProjectedBounds() { return Ht.compositeBounds(this.allBounds) } isInside(t) { let { geoBoundsProjectedBox: e, geoBoundsProjectedPolygon: i } = this; return !!(e && t.x >= e.x1 && t.x <= e.x2 && t.y >= e.y1 && t.y <= e.y2 && i && zi(t, i)) } render() { let { chart: t, mapView: e, options: i } = this, s = i.borderPath || i.field; if (s && e.group) { let o = !0; this.border || (this.border = t.renderer.path().addClass("highcharts-mapview-inset-border").add(e.group), o = !1), t.styledMode || this.border.attr({ stroke: i.borderColor, "stroke-width": i.borderWidth }); let r = this.border.strokeWidth(), a = i.relativeTo === "mapBoundingBox" && e.getMapBBox() || e.playingField, n = (s.coordinates || []).reduce((l, c) => c.reduce((d, p, u) => { let [g, m] = p; return i.units === "percent" && (g = t.plotLeft + he(`${g}%`, a.width, a.x), m = t.plotTop + he(`${m}%`, a.height, a.y)), g = $l(g, r), m = $l(m, r), d.push(u === 0 ? ["M", g, m] : ["L", g, m]), d }, l), []); this.border[o ? "animate" : "attr"]({ d: n }) } } destroy() { this.border && (this.border = this.border.destroy()), this.eventsToUnbind.forEach(t => t()) } setUpEvents() { } } let { animObject: Ql, stop: Ug } = mt, { noop: Vs } = C, { splitPath: jg } = Rs, { column: th, scatter: eh } = G.seriesTypes, { extend: Rg, find: Wg, fireEvent: ih, getNestedProperty: sh, isArray: Vr, defined: oh, isNumber: Et, isObject: Fg, merge: Ui, objectEach: Xg, pick: Zr, splat: Yg } = I; class ji extends eh { constructor() { super(...arguments), this.processedData = [] } animate(t) { let { chart: e, group: i } = this, s = Ql(this.options.animation); t ? i.attr({ translateX: e.plotLeft + e.plotWidth / 2, translateY: e.plotTop + e.plotHeight / 2, scaleX: .001, scaleY: .001 }) : i.animate({ translateX: e.plotLeft, translateY: e.plotTop, scaleX: 1, scaleY: 1 }, s) } clearBounds() { this.points.forEach(t => { delete t.bounds, delete t.insetIndex, delete t.projectedPath }), delete this.bounds } doFullTranslate() { return !!(this.isDirtyData || this.chart.isResizing || !this.hasRendered) } drawMapDataLabels() { super.drawDataLabels(), this.dataLabelsGroup && this.dataLabelsGroup.clip(this.chart.clipRect) } drawPoints() { let t = this, { chart: e, group: i, transformGroups: s = [] } = this, { mapView: o, renderer: r } = e; if (o) { this.transformGroups = s, s[0] || (s[0] = r.g().add(i)); for (let a = 0, n = o.insets.length; a < n; ++a)s[a + 1] || s.push(r.g().add(i)); this.doFullTranslate() && (this.points.forEach(a => { let { graphic: n } = a; a.group = s[typeof a.insetIndex == "number" ? a.insetIndex + 1 : 0], n && n.parentGroup !== a.group && n.add(a.group) }), th.prototype.drawPoints.apply(this), this.points.forEach(a => { var l; let n = a.graphic; if (n) { let c = n.animate, d = ""; a.name && (d += "highcharts-name-" + a.name.replace(/ /g, "-").toLowerCase()), (l = a.properties) != null && l["hc-key"] && (d += " highcharts-key-" + a.properties["hc-key"].toString().toLowerCase()), d && n.addClass(d), e.styledMode && n.css(this.pointAttribs(a, a.selected && "select" || void 0)), n.attr({ visibility: !a.visible && (a.visible || a.isNull) ? "hidden" : "inherit" }), n.animate = function (p, u, g) { var y; let m = Et(p["stroke-width"]) && !Et(n["stroke-width"]), f = Et(n["stroke-width"]) && !Et(p["stroke-width"]); if (m || f) { let x = Zr(t.getStrokeWidth(t.options), 1) / (((y = e.mapView) == null ? void 0 : y.getScale()) || 1); m && (n["stroke-width"] = x), f && (p["stroke-width"] = x) } return c.call(n, p, u, f ? function () { n.element.removeAttribute("stroke-width"), delete n["stroke-width"], g && g.apply(this, arguments) } : g) } } })), s.forEach((a, n) => { let l = (n === 0 ? o : o.insets[n - 1]).getSVGTransform(), c = Zr(this.getStrokeWidth(this.options), 1), d = l.scaleX, p = l.scaleY > 0 ? 1 : -1, u = g => { (t.points || []).forEach(m => { let f, y = m.graphic; y != null && y["stroke-width"] && (f = this.getStrokeWidth(m.options)) && y.attr({ "stroke-width": f / g }) }) }; if (r.globalAnimation && e.hasRendered && o.allowTransformAnimation) { let g = Number(a.attr("translateX")), m = Number(a.attr("translateY")), f = Number(a.attr("scaleX")), y = (w, v) => { let S = f + (d - f) * v.pos; a.attr({ translateX: g + (l.translateX - g) * v.pos, translateY: m + (l.translateY - m) * v.pos, scaleX: S, scaleY: S * p, "stroke-width": c / S }), u(S) }, x = Ui(Ql(r.globalAnimation)), b = x.step; x.step = function () { b && b.apply(this, arguments), y.apply(this, arguments) }, a.attr({ animator: 0 }).animate({ animator: 1 }, x, (function () { typeof r.globalAnimation != "boolean" && r.globalAnimation.complete && r.globalAnimation.complete({ applyDrilldown: !0 }), ih(this, "mapZoomComplete") }).bind(this)) } else Ug(a), a.attr(Ui(l, { "stroke-width": c / d })), u(d) }), this.isDrilling || this.drawMapDataLabels() } } getProjectedBounds() { if (!this.bounds && this.chart.mapView) { let { insets: t, projection: e } = this.chart.mapView, i = []; (this.points || []).forEach(s => { if (s.path || s.geometry) { if (typeof s.path == "string" ? s.path = jg(s.path) : Vr(s.path) && s.path[0] === "M" && (s.path = this.chart.renderer.pathToSegments(s.path)), !s.bounds) { let o = s.getProjectedBounds(e); if (o) { s.labelrank = Zr(s.labelrank, (o.x2 - o.x1) * (o.y2 - o.y1)); let { midX: r, midY: a } = o; if (t && Et(r) && Et(a)) { let n = Wg(t, l => l.isInside({ x: r, y: a })); n && (delete s.projectedPath, (o = s.getProjectedBounds(n.projection)) && n.allBounds.push(o), s.insetIndex = t.indexOf(n)) } s.bounds = o } } s.bounds && s.insetIndex === void 0 && i.push(s.bounds) } }), this.bounds = Ht.compositeBounds(i) } return this.bounds } getStrokeWidth(t) { let e = this.pointAttrToOptions; return t[(e == null ? void 0 : e["stroke-width"]) || "borderWidth"] } hasData() { return !!this.dataTable.rowCount } pointAttribs(t, e) { let { mapView: i, styledMode: s } = t.series.chart, o = s ? this.colorAttribs(t) : th.prototype.pointAttribs.call(this, t, e), r = this.getStrokeWidth(t.options); if (e) { let n = Ui(this.options.states && this.options.states[e], t.options.states && t.options.states[e] || {}), l = this.getStrokeWidth(n); oh(l) && (r = l), o.stroke = n.borderColor ?? t.color } r && i && (r /= i.getScale()); let a = this.getStrokeWidth(this.options); return o.dashstyle && i && Et(a) && (r = a / i.getScale()), t.visible || (o.fill = this.options.nullColor), oh(r) ? o["stroke-width"] = r : delete o["stroke-width"], o["stroke-linecap"] = o["stroke-linejoin"] = this.options.linecap, o } updateData() { return !this.processedData && super.updateData.apply(this, arguments) } setData(t, e = !0, i, s) { delete this.bounds, super.setData(t, !1, void 0, s), this.processData(), this.generatePoints(), e && this.chart.redraw(i) } dataColumnKeys() { return this.pointArrayMap } processData() { let t, e, i, s = this.options, o = s.data, r = this.chart, a = r.options.chart, n = this.joinBy, l = s.keys || this.pointArrayMap, c = [], d = {}, p = this.chart.mapView, u = p && (Fg(s.mapData, !0) ? p.getGeoMap(s.mapData) : p.geoMap), g = r.mapTransforms = a.mapTransforms || (u == null ? void 0 : u["hc-transform"]) || r.mapTransforms; g && Xg(g, f => { f.rotation && (f.cosAngle = Math.cos(f.rotation), f.sinAngle = Math.sin(f.rotation)) }), Vr(s.mapData) ? i = s.mapData : u && u.type === "FeatureCollection" && (this.mapTitle = u.title, i = C.geojson(u, this.type, this)), this.processedData = []; let m = this.processedData; if (o) { let f; for (let y = 0, x = o.length; y < x; ++y) { if (Et(f = o[y])) m[y] = { value: f }; else if (Vr(f)) { let b = 0; m[y] = {}, !s.keys && f.length > l.length && typeof f[0] == "string" && (m[y]["hc-key"] = f[0], ++b); for (let w = 0; w < l.length; ++w, ++b)l[w] && f[b] !== void 0 && (l[w].indexOf(".") > 0 ? Ke.prototype.setNestedProperty(m[y], f[b], l[w]) : m[y][l[w]] = f[b]) } else m[y] = o[y]; n && n[0] === "_i" && (m[y]._i = y) } } if (i) { this.mapData = i, this.mapMap = {}; for (let f = 0; f < i.length; f++)e = (t = i[f]).properties, t._i = f, n[0] && e && e[n[0]] && (t[n[0]] = e[n[0]]), d[t[n[0]]] = t; if (this.mapMap = d, n[1]) { let f = n[1]; m.forEach(y => { let x = sh(f, y); d[x] && c.push(d[x]) }) } if (s.allAreas) { if (n[1]) { let y = n[1]; m.forEach(x => { c.push(sh(y, x)) }) } let f = "|" + c.map(function (y) { return y && y[n[0]] }).join("|") + "|"; i.forEach(y => { n[0] && f.indexOf("|" + y[n[0]] + "|") !== -1 || m.push(Ui(y, { value: null })) }) } } this.dataTable.rowCount = m.length } setOptions(t) { let e = super.setOptions(t), i = e.joinBy; return e.joinBy === null && (i = "_i"), i && (this.joinBy = Yg(i), this.joinBy[1] || (this.joinBy[1] = this.joinBy[0])), e } translate() { let t = this.doFullTranslate(), e = this.chart.mapView, i = e == null ? void 0 : e.projection; if (this.chart.hasRendered && (this.isDirtyData || !this.hasRendered) && (this.processData(), this.generatePoints(), delete this.bounds, !e || e.userOptions.center || Et(e.userOptions.zoom) || e.zoom !== e.minZoom ? this.getProjectedBounds() : e.fitToBounds(void 0, void 0, !1)), e) { let s = e.getSVGTransform(); this.points.forEach(o => { let r = Et(o.insetIndex) && e.insets[o.insetIndex].getSVGTransform() || s; r && o.bounds && Et(o.bounds.midX) && Et(o.bounds.midY) && (o.plotX = o.bounds.midX * r.scaleX + r.translateX, o.plotY = o.bounds.midY * r.scaleY + r.translateY), t && (o.shapeType = "path", o.shapeArgs = { d: Ke.getProjectedPath(o, i) }), !o.hiddenInDataClass && (o.projectedPath && !o.projectedPath.length ? o.setVisible(!1) : o.visible || o.setVisible(!0)) }) } ih(this, "afterTranslate") } update(t) { var e; t.mapData && ((e = this.chart.mapView) == null || e.recommendMapView(this.chart, [this.chart.options.chart.map, ...(this.chart.options.series || []).map((i, s) => s === this._i ? t.mapData : i.mapData)], !0)), super.update.apply(this, arguments) } } ji.defaultOptions = Ui(eh.defaultOptions, { affectsMapView: !0, animation: !1, dataLabels: { crop: !1, formatter: function () { let { numberFormatter: h } = this.series.chart, { value: t } = this.point; return mg(t) ? h(t, -1) : this.point.name || "" }, inside: !0, overflow: !1, padding: 0, verticalAlign: "middle" }, linecap: "round", marker: null, nullColor: "#f7f7f7", stickyTracking: !1, tooltip: { followPointer: !0, pointFormat: "{point.name}: {point.value}<br/>" }, turboThreshold: 0, allAreas: !0, borderColor: "#e6e6e6", borderWidth: 1, joinBy: "hc-key", states: { hover: { halo: void 0, borderColor: "#666666", borderWidth: 2 }, normal: { animation: !0 }, select: { color: "#cccccc" } }, legendSymbol: "rectangle" }), Rg(ji.prototype, { type: "map", axisTypes: xt.seriesMembers.axisTypes, colorAttribs: xt.seriesMembers.colorAttribs, colorKey: xt.seriesMembers.colorKey, directTouch: !0, drawDataLabels: Vs, drawGraph: Vs, forceDL: !0, getCenter: Br.getCenter, getExtremesFromAll: !0, getSymbol: Vs, isCartesian: !1, parallelArrays: xt.seriesMembers.parallelArrays, pointArrayMap: xt.seriesMembers.pointArrayMap, pointClass: Ke, preserveAspectRatio: !0, searchPoint: Vs, trackerGroups: xt.seriesMembers.trackerGroups, useMapGeometry: !0 }), xt.compose(ji), G.registerSeriesType("map", ji); let rh = ji, { extend: Hg, merge: Gg } = I; class $r extends rh { pointAttribs(t, e) { let i = super.pointAttribs(t, e); return i.fill = this.options.fillColor, i } } $r.defaultOptions = Gg(rh.defaultOptions, { lineWidth: 1, fillColor: "none", legendSymbol: "lineMarker" }), Hg($r.prototype, { type: "mapline", colorProp: "stroke", pointAttrToOptions: { stroke: "color", "stroke-width": "lineWidth" } }), G.registerSeriesType("mapline", $r); let { scatter: Vg } = G.seriesTypes, { isNumber: Zs } = I; class Zg extends Vg.prototype.pointClass { isValid() { return !!(this.options.geometry || Zs(this.x) && Zs(this.y) || Zs(this.options.lon) && Zs(this.options.lat)) } } let { noop: $g } = C, { map: Kg, scatter: ah } = G.seriesTypes, { extend: qg, fireEvent: _g, isNumber: Ae, merge: Jg } = I; class Kr extends ah { constructor() { super(...arguments), this.clearBounds = Kg.prototype.clearBounds } drawDataLabels() { super.drawDataLabels(), this.dataLabelsGroup && this.dataLabelsGroup.clip(this.chart.clipRect) } projectPoint(t) { let e = this.chart.mapView; if (e) { let { geometry: i, lon: s, lat: o } = t, r = i && i.type === "Point" && i.coordinates; if (Ae(s) && Ae(o) && (r = [s, o]), r) return e.lonLatToProjectedUnits({ lon: r[0], lat: r[1] }) } } translate() { let t = this.chart.mapView; if (this.generatePoints(), this.getProjectedBounds && this.isDirtyData && (delete this.bounds, this.getProjectedBounds()), t) { let e = t.getSVGTransform(), { hasCoordinates: i } = t.projection; this.points.forEach(s => { let o, { x: r, y: a } = s, n = Ae(s.insetIndex) && t.insets[s.insetIndex].getSVGTransform() || e, l = this.projectPoint(s.options) || s.properties && this.projectPoint(s.properties); if (l ? (r = l.x, a = l.y) : s.bounds && (r = s.bounds.midX, a = s.bounds.midY, n && Ae(r) && Ae(a) && (s.plotX = r * n.scaleX + n.translateX, s.plotY = a * n.scaleY + n.translateY, o = !0)), Ae(r) && Ae(a)) { if (!o) { let c = t.projectedUnitsToPixels({ x: r, y: a }); s.plotX = c.x, s.plotY = i ? c.y : this.chart.plotHeight - c.y } } else s.y = s.plotX = s.plotY = void 0; s.isInside = this.isPointInside(s), s.zone = this.zones.length ? s.getZone() : void 0 }) } _g(this, "afterTranslate") } } Kr.defaultOptions = Jg(ah.defaultOptions, { dataLabels: { crop: !1, defer: !1, enabled: !0, formatter: function () { return this.point.name }, overflow: !1, style: { color: "#000000" } }, legendSymbol: "lineMarker" }), ye.prototype.symbols.mapmarker = (h, t, e, i, s) => { let o, r, a = s && s.context === "legend"; a ? (o = h + e / 2, r = t + i) : s && typeof s.anchorX == "number" && typeof s.anchorY == "number" ? (o = s.anchorX, r = s.anchorY) : (o = h + e / 2, r = t + i / 2, t -= i); let n = a ? i / 3 : i / 2; return [["M", o, r], ["C", o, r, o - n, t + 1.5 * n, o - n, t + n], ["A", n, n, 1, 1, 1, o + n, t + n], ["C", o + n, t + 1.5 * n, o, r, o, r], ["Z"]] }, qg(Kr.prototype, { type: "mappoint", axisTypes: ["colorAxis"], forceDL: !0, isCartesian: !1, pointClass: Zg, searchPoint: $g, useMapGeometry: !0 }), G.registerSeriesType("mappoint", Kr); let Qg = { borderColor: void 0, borderWidth: 2, className: void 0, color: void 0, connectorClassName: void 0, connectorColor: void 0, connectorDistance: 60, connectorWidth: 1, enabled: !1, labels: { className: void 0, allowOverlap: !1, format: "", formatter: void 0, align: "right", style: { fontSize: "0.9em", color: "#000000" }, x: 0, y: 0 }, maxSize: 60, minSize: 10, legendIndex: 0, ranges: { value: void 0, borderColor: void 0, color: void 0, connectorColor: void 0 }, sizeBy: "area", sizeByAbsoluteValue: !1, zIndex: 1, zThreshold: 0 }, { noop: tm } = C, { arrayMax: em, arrayMin: im, isNumber: nh, merge: Ri, pick: Wi, stableSort: sm } = I, om = class { constructor(h, t) { this.setState = tm, this.init(h, t) } init(h, t) { this.options = h, this.visible = !0, this.chart = t.chart, this.legend = t } addToLegend(h) { h.splice(this.options.legendIndex, 0, this) } drawLegendSymbol(h) { let t, e = Wi(h.options.itemDistance, 20), i = this.legendItem || {}, s = this.options, o = s.ranges, r = s.connectorDistance; if (!o || !o.length || !nh(o[0].value)) { h.options.bubbleLegend.autoRanges = !0; return } sm(o, function (c, d) { return d.value - c.value }), this.ranges = o, this.setOptions(), this.render(); let a = this.getMaxLabelSize(), n = this.ranges[0].radius, l = 2 * n; t = (t = r - n + a.width) > 0 ? t : 0, this.maxLabel = a, this.movementX = s.labels.align === "left" ? t : 0, i.labelWidth = l + t + e, i.labelHeight = l + a.height / 2 } setOptions() { let h = this.ranges, t = this.options, e = this.chart.series[t.seriesIndex], i = this.legend.baseline, s = { zIndex: t.zIndex, "stroke-width": t.borderWidth }, o = { zIndex: t.zIndex, "stroke-width": t.connectorWidth }, r = { align: this.legend.options.rtl || t.labels.align === "left" ? "right" : "left", zIndex: t.zIndex }, a = e.options.marker.fillOpacity, n = this.chart.styledMode; h.forEach(function (l, c) { n || (s.stroke = Wi(l.borderColor, t.borderColor, e.color), s.fill = l.color || t.color, s.fill || (s.fill = e.color, s["fill-opacity"] = a ?? 1), o.stroke = Wi(l.connectorColor, t.connectorColor, e.color)), h[c].radius = this.getRangeRadius(l.value), h[c] = Ri(h[c], { center: h[0].radius - h[c].radius + i }), n || Ri(!0, h[c], { bubbleAttribs: Ri(s), connectorAttribs: Ri(o), labelAttribs: r }) }, this) } getRangeRadius(h) { let t = this.options, e = this.options.seriesIndex, i = this.chart.series[e], s = t.ranges[0].value, o = t.ranges[t.ranges.length - 1].value, r = t.minSize, a = t.maxSize; return i.getRadius.call(this, o, s, r, a, h) } render() { let h = this.legendItem || {}, t = this.chart.renderer, e = this.options.zThreshold; for (let i of (this.symbols || (this.symbols = { connectors: [], bubbleItems: [], labels: [] }), h.symbol = t.g("bubble-legend"), h.label = t.g("bubble-legend-item").css(this.legend.itemStyle || {}), h.symbol.translateX = 0, h.symbol.translateY = 0, h.symbol.add(h.label), h.label.add(h.group), this.ranges)) i.value >= e && this.renderRange(i); this.hideOverlappingLabels() } renderRange(h) { let t = this.ranges[0], e = this.legend, i = this.options, s = i.labels, o = this.chart, r = o.series[i.seriesIndex], a = o.renderer, n = this.symbols, l = n.labels, c = h.center, d = Math.abs(h.radius), p = i.connectorDistance || 0, u = s.align, g = e.options.rtl, m = i.borderWidth, f = i.connectorWidth, y = t.radius || 0, x = c - d - m / 2 + f / 2, b = (x % 1 ? 1 : .5) - (f % 2 ? 0 : .5), w = a.styledMode, v = g || u === "left" ? -p : p; u === "center" && (v = 0, i.connectorDistance = 0, h.labelAttribs.align = "center"), n.bubbleItems.push(a.circle(y, c + b, d).attr(w ? {} : h.bubbleAttribs).addClass((w ? "highcharts-color-" + r.colorIndex + " " : "") + "highcharts-bubble-legend-symbol " + (i.className || "")).add(this.legendItem.symbol)), n.connectors.push(a.path(a.crispLine([["M", y, x], ["L", y + v, x]], i.connectorWidth)).attr(w ? {} : h.connectorAttribs).addClass((w ? "highcharts-color-" + this.options.seriesIndex + " " : "") + "highcharts-bubble-legend-connectors " + (i.connectorClassName || "")).add(this.legendItem.symbol)); let S = a.text(this.formatLabel(h)).attr(w ? {} : h.labelAttribs).css(w ? {} : s.style).addClass("highcharts-bubble-legend-labels " + (i.labels.className || "")).add(this.legendItem.symbol), A = { x: y + v + i.labels.x, y: x + i.labels.y + .4 * S.getBBox().height }; S.attr(A), l.push(S), S.placed = !0, S.alignAttr = A } getMaxLabelSize() { let h, t; return this.symbols.labels.forEach(function (e) { t = e.getBBox(!0), h = h ? t.width > h.width ? t : h : t }), h || {} } formatLabel(h) { let t = this.options, e = t.labels.formatter, i = t.labels.format, { numberFormatter: s } = this.chart; return i ? At.format(i, h, this.chart) : e ? e.call(h) : s(h.value, 1) } hideOverlappingLabels() { let h = this.chart, t = this.options.labels.allowOverlap, e = this.symbols; !t && e && (h.hideOverlappingLabels(e.labels), e.labels.forEach(function (i, s) { i.newOpacity ? i.newOpacity !== i.oldOpacity && e.connectors[s].show() : e.connectors[s].hide() })) } getRanges() { let h = this.legend.bubbleLegend, t = h.chart.series, e = h.options.ranges, i, s, o = Number.MAX_VALUE, r = -Number.MAX_VALUE; return t.forEach(function (a) { a.isBubble && !a.ignoreSeries && (s = a.getColumn("z").filter(nh)).length && (o = Wi(a.options.zMin, Math.min(o, Math.max(im(s), a.options.displayNegative === !1 ? a.options.zThreshold : -Number.MAX_VALUE))), r = Wi(a.options.zMax, Math.max(r, em(s)))) }), i = o === r ? [{ value: r }] : [{ value: o }, { value: (o + r) / 2 }, { value: r, autoRanges: !0 }], e.length && e[0].radius && i.reverse(), i.forEach(function (a, n) { e && e[n] && (i[n] = Ri(e[n], a)) }), i } predictBubbleSizes() { let h = this.chart, t = h.legend.options, e = t.floating, i = t.layout === "horizontal", s = i ? h.legend.lastLineHeight : 0, o = h.plotSizeX, r = h.plotSizeY, a = h.series[this.options.seriesIndex], n = a.getPxExtremes(), l = Math.ceil(n.minPxSize), c = Math.ceil(n.maxPxSize), d = Math.min(r, o), p, u = a.options.maxSize; return e || !/%$/.test(u) ? p = c : (p = (d + s) * (u = parseFloat(u)) / 100 / (u / 100 + 1), (i && r - p >= o || !i && o - p >= r) && (p = c)), [l, Math.ceil(p)] } updateRanges(h, t) { let e = this.legend.options.bubbleLegend; e.minSize = h, e.maxSize = t, e.ranges = this.getRanges() } correctSizes() { let h = this.legend, t = this.chart.series[this.options.seriesIndex].getPxExtremes(); Math.abs(Math.ceil(t.maxPxSize) - this.options.maxSize) > 1 && (this.updateRanges(this.options.minSize, t.maxPxSize), h.render()) } }, { setOptions: rm } = wt, { composed: am } = C, { addEvent: lh, objectEach: nm, pushUnique: lm, wrap: hm } = I; function dm(h, t, e) { let i, s, o, r = this.legend, a = qr(this) >= 0; r && r.options.enabled && r.bubbleLegend && r.options.bubbleLegend.autoRanges && a ? (i = r.bubbleLegend.options, s = r.bubbleLegend.predictBubbleSizes(), r.bubbleLegend.updateRanges(s[0], s[1]), i.placed || (r.group.placed = !1, r.allItems.forEach(n => { (o = n.legendItem || {}).group && (o.group.translateY = void 0) })), r.render(), i.placed || (this.getMargins(), this.axes.forEach(n => { n.setScale(), n.updateNames(), nm(n.ticks, function (l) { l.isNew = !0, l.isNewLabel = !0 }) }), this.getMargins()), i.placed = !0, h.call(this, t, e), r.bubbleLegend.correctSizes(), dh(r, hh(r))) : (h.call(this, t, e), r && r.options.enabled && r.bubbleLegend && (r.render(), dh(r, hh(r)))) } function qr(h) { let t = h.series, e = 0; for (; e < t.length;) { if (t[e] && t[e].isBubble && t[e].visible && t[e].dataTable.rowCount) return e; e++ } return -1 } function hh(h) { let t = h.allItems, e = [], i = t.length, s, o, r, a = 0, n = 0; for (a = 0; a < i; a++)if (o = t[a].legendItem || {}, r = (t[a + 1] || {}).legendItem || {}, o.labelHeight && (t[a].itemHeight = o.labelHeight), t[a] === t[i - 1] || o.y !== r.y) { for (e.push({ height: 0 }), s = e[e.length - 1]; n <= a; n++)t[n].itemHeight > s.height && (s.height = t[n].itemHeight); s.step = a } return e } function cm(h) { let t = this.bubbleLegend, e = this.options, i = e.bubbleLegend, s = qr(this.chart); t && t.ranges && t.ranges.length && (i.ranges.length && (i.autoRanges = !!i.ranges[0].autoRanges), this.destroyItem(t)), s >= 0 && e.enabled && i.enabled && (i.seriesIndex = s, this.bubbleLegend = new om(i, this), this.bubbleLegend.addToLegend(h.allItems)) } function pm(h) { let t; if (h.defaultPrevented) return !1; let e = h.legendItem, i = this.chart, s = e.visible; this && this.bubbleLegend && (e.visible = !s, e.ignoreSeries = s, t = qr(i) >= 0, this.bubbleLegend.visible !== t && (this.update({ bubbleLegend: { enabled: t } }), this.bubbleLegend.visible = t), e.visible = s) } function dh(h, t) { let e = h.allItems, i = h.options.rtl, s, o, r, a, n = 0; e.forEach((l, c) => { (a = l.legendItem || {}).group && (s = a.group.translateX || 0, o = a.y || 0, ((r = l.movementX) || i && l.ranges) && (r = i ? s - l.options.maxSize / 2 : s + r, a.group.attr({ translateX: r })), c > t[n].step && n++, a.group.attr({ translateY: Math.round(o + t[n].height / 2) }), a.y = o + t[n].height / 2) }) } let um = { compose: function (h, t) { lm(am, "Series.BubbleLegend") && (rm({ legend: { bubbleLegend: Qg } }), hm(h.prototype, "drawChartBox", dm), lh(t, "afterGetAllItems", cm), lh(t, "itemClick", pm)) } }, { seriesTypes: { scatter: { prototype: { pointClass: gm } } } } = G, { extend: mm } = I; class ch extends gm { haloPath(t) { let e = (t && this.marker && this.marker.radius || 0) + t; if (this.series.chart.inverted) { let i = this.pos() || [0, 0], { xAxis: s, yAxis: o, chart: r } = this.series, a = 2 * e; return r.renderer.symbols.circle(((s == null ? void 0 : s.len) || 0) - i[1] - e, ((o == null ? void 0 : o.len) || 0) - i[0] - e, a, a) } return $t.prototype.haloPath.call(this, e) } } mm(ch.prototype, { ttBelow: !1 }); let ph = ch, { composed: fm, noop: _r } = C, { series: ym, seriesTypes: { column: { prototype: xm }, scatter: uh } } = G, { addEvent: $s, arrayMax: bm, arrayMin: vm, clamp: wm, extend: Jr, isNumber: Ce, merge: Sm, pick: Te, pushUnique: Mm } = I; function km() { let h = this.len, { coll: t, isXAxis: e, min: i } = this, s = (this.max || 0) - (i || 0), o = 0, r = h, a = h / s, n; (t === "xAxis" || t === "yAxis") && (this.series.forEach(l => { if (l.bubblePadding && l.reserveSpace()) { this.allowZoomOutside = !0, n = !0; let c = l.getColumn(e ? "x" : "y"); if (e && ((l.onPoint || l).getRadii(0, 0, l), l.onPoint && (l.radii = l.onPoint.radii)), s > 0) { let d = c.length; for (; d--;)if (Ce(c[d]) && this.dataMin <= c[d] && c[d] <= this.max) { let p = l.radii && l.radii[d] || 0; o = Math.min((c[d] - i) * a - p, o), r = Math.max((c[d] - i) * a + p, r) } } } }), n && s > 0 && !this.logarithmic && (r -= h, a *= (h + Math.max(0, o) - Math.min(r, h)) / h, [["min", "userMin", o], ["max", "userMax", r]].forEach(l => { Te(this.options[l[0]], this[l[1]]) === void 0 && (this[l[0]] += l[2] / a) }))) } function Am() { var r; let { ticks: h, tickPositions: t, dataMin: e = 0, dataMax: i = 0, categories: s } = this, o = this.options.type; if ((s != null && s.length || o === "category") && this.series.find(a => a.bubblePadding)) { let a = t.length; for (; a--;) { let n = h[t[a]], l = n.pos || 0; (l > i || l < e) && ((r = n.label) == null || r.hide()) } } } class Je extends uh { static compose(t, e, i) { um.compose(e, i), Mm(fm, "Series.Bubble") && ($s(t, "foundExtremes", km), $s(t, "afterRender", Am)) } animate(t) { !t && this.points.length < this.options.animationLimit && this.points.forEach(function (e) { let { graphic: i, plotX: s = 0, plotY: o = 0 } = e; i && i.width && (this.hasRendered || i.attr({ x: s, y: o, width: 1, height: 1 }), i.animate(this.markerAttribs(e), this.options.animation)) }, this) } getRadii() { let t = this.getColumn("z"), e = this.getColumn("y"), i = [], s, o, r, a = this.chart.bubbleZExtremes, { minPxSize: n, maxPxSize: l } = this.getPxExtremes(); if (!a) { let c, d = Number.MAX_VALUE, p = -Number.MAX_VALUE; this.chart.series.forEach(u => { if (u.bubblePadding && u.reserveSpace()) { let g = (u.onPoint || u).getZExtremes(); g && (d = Math.min(Te(d, g.zMin), g.zMin), p = Math.max(Te(p, g.zMax), g.zMax), c = !0) } }), c ? (a = { zMin: d, zMax: p }, this.chart.bubbleZExtremes = a) : a = { zMin: 0, zMax: 0 } } for (o = 0, s = t.length; o < s; o++)r = t[o], i.push(this.getRadius(a.zMin, a.zMax, n, l, r, e && e[o])); this.radii = i } getRadius(t, e, i, s, o, r) { let a = this.options, n = a.sizeBy !== "width", l = a.zThreshold, c = e - t, d = .5; if (r === null || o === null) return null; if (Ce(o)) { if (a.sizeByAbsoluteValue && (o = Math.abs(o - l), e = c = Math.max(e - l, Math.abs(t - l)), t = 0), o < t) return i / 2 - 1; c > 0 && (d = (o - t) / c) } return n && d >= 0 && (d = Math.sqrt(d)), Math.ceil(i + d * (s - i)) / 2 } hasData() { return !!this.dataTable.rowCount } markerAttribs(t, e) { let i = super.markerAttribs(t, e), { height: s = 0, width: o = 0 } = i; return this.chart.inverted ? Jr(i, { x: (t.plotX || 0) - o / 2, y: (t.plotY || 0) - s / 2 }) : i } pointAttribs(t, e) { let i = this.options.marker, s = i == null ? void 0 : i.fillOpacity, o = ym.prototype.pointAttribs.call(this, t, e); return o["fill-opacity"] = s ?? 1, o } translate() { super.translate.call(this), this.getRadii(), this.translateBubble() } translateBubble() { let { data: t, options: e, radii: i } = this, { minPxSize: s } = this.getPxExtremes(), o = t.length; for (; o--;) { let r = t[o], a = i ? i[o] : 0; this.zoneAxis === "z" && (r.negative = (r.z || 0) < (e.zThreshold || 0)), Ce(a) && a >= s / 2 ? (r.marker = Jr(r.marker, { radius: a, width: 2 * a, height: 2 * a }), r.dlBox = { x: r.plotX - a, y: r.plotY - a, width: 2 * a, height: 2 * a }) : (r.shapeArgs = r.plotY = r.dlBox = void 0, r.isInside = !1) } } getPxExtremes() { let t = Math.min(this.chart.plotWidth, this.chart.plotHeight), e = o => { let r; return typeof o == "string" && (r = /%$/.test(o), o = parseInt(o, 10)), r ? t * o / 100 : o }, i = e(Te(this.options.minSize, 8)), s = Math.max(e(Te(this.options.maxSize, "20%")), i); return { minPxSize: i, maxPxSize: s } } getZExtremes() { let t = this.options, e = this.getColumn("z").filter(Ce); if (e.length) { let i = Te(t.zMin, wm(vm(e), t.displayNegative === !1 ? t.zThreshold || 0 : -Number.MAX_VALUE, Number.MAX_VALUE)), s = Te(t.zMax, bm(e)); if (Ce(i) && Ce(s)) return { zMin: i, zMax: s } } } searchKDTree(t, e, i, s = _r, o = _r) { return s = (r, a, n) => { var u, g; let l = r[n] || 0, c = a[n] || 0, d, p = !1; return l === c ? d = r.index > a.index ? r : a : l < 0 && c < 0 ? (d = l - (((u = r.marker) == null ? void 0 : u.radius) || 0) >= c - (((g = a.marker) == null ? void 0 : g.radius) || 0) ? r : a, p = !0) : d = l < c ? r : a, [d, p] }, o = (r, a, n) => !n && r > a || r < a, super.searchKDTree(t, e, i, s, o) } } Je.defaultOptions = Sm(uh.defaultOptions, { dataLabels: { formatter: function () { let { numberFormatter: h } = this.series.chart, { z: t } = this.point; return Ce(t) ? h(t, -1) : "" }, inside: !0, verticalAlign: "middle" }, animationLimit: 250, marker: { lineColor: null, lineWidth: 1, fillOpacity: .5, radius: null, states: { hover: { radiusPlus: 0 } }, symbol: "circle" }, minSize: 8, maxSize: "20%", softThreshold: !1, states: { hover: { halo: { size: 5 } } }, tooltip: { pointFormat: "({point.x}, {point.y}), Size: {point.z}" }, turboThreshold: 0, zThreshold: 0, zoneAxis: "z" }), Jr(Je.prototype, { alignDataLabel: xm.alignDataLabel, applyZones: _r, bubblePadding: !0, isBubble: !0, keysAffectYAxis: ["y"], pointArrayMap: ["y", "z"], pointClass: ph, parallelArrays: ["x", "y", "z"], trackerGroups: ["group", "dataLabelsGroup"], specialGroup: "group", zoneAxis: "z" }), $s(Je, "updatedData", h => { delete h.target.chart.bubbleZExtremes }), $s(Je, "remove", h => { delete h.target.chart.bubbleZExtremes }), G.registerSeriesType("bubble", Je); let gh = Je, { seriesTypes: { map: { prototype: { pointClass: { prototype: mh } } } } } = G, { extend: Cm } = I; class fh extends ph { isValid() { return typeof this.z == "number" } } Cm(fh.prototype, { applyOptions: mh.applyOptions, getProjectedBounds: mh.getProjectedBounds }); let { seriesTypes: { map: { prototype: Qe }, mappoint: { prototype: yh } } } = G, { extend: Tm, merge: Pm } = I; class Ks extends gh { constructor() { super(...arguments), this.clearBounds = Qe.clearBounds } searchPoint(t, e) { return this.searchKDTree({ plotX: t.chartX - this.chart.plotLeft, plotY: t.chartY - this.chart.plotTop }, e, t) } translate() { yh.translate.call(this), this.getRadii(), this.translateBubble() } } Ks.defaultOptions = Pm(gh.defaultOptions, { lineWidth: 0, animationLimit: 500, joinBy: "hc-key", tooltip: { pointFormat: "{point.name}: {point.z}" } }), Tm(Ks.prototype, { type: "mapbubble", axisTypes: ["colorAxis"], getProjectedBounds: Qe.getProjectedBounds, isCartesian: !1, pointArrayMap: ["z"], pointClass: fh, processData: Qe.processData, projectPoint: yh.projectPoint, kdAxisArray: ["plotX", "plotY"], setData: Qe.setData, setOptions: Qe.setOptions, updateData: Qe.updateData, useMapGeometry: !0, xyFromShape: !0 }), G.registerSeriesType("mapbubble", Ks); let { scatter: { prototype: { pointClass: Lm } } } = G.seriesTypes, { clamp: qs, defined: Om, extend: Em, pick: Im } = I; class xh extends Lm { applyOptions(t, e) { return (this.isNull || this.value === null) && delete this.color, super.applyOptions(t, e), this.formatPrefix = this.isNull || this.value === null ? "null" : "point", this } getCellAttributes() { let t = this.series, e = t.options, i = (e.colsize || 1) / 2, s = (e.rowsize || 1) / 2, o = t.xAxis, r = t.yAxis, a = this.options.marker || t.options.marker, n = t.pointPlacementToXValue(), l = Im(this.pointPadding, e.pointPadding, 0), c = { x1: qs(Math.round(o.len - o.translate(this.x - i, !1, !0, !1, !0, -n)), -o.len, 2 * o.len), x2: qs(Math.round(o.len - o.translate(this.x + i, !1, !0, !1, !0, -n)), -o.len, 2 * o.len), y1: qs(Math.round(r.translate(this.y - s, !1, !0, !1, !0)), -r.len, 2 * r.len), y2: qs(Math.round(r.translate(this.y + s, !1, !0, !1, !0)), -r.len, 2 * r.len) }; for (let d of [["width", "x"], ["height", "y"]]) { let p = d[0], u = d[1], g = u + "1", m = u + "2", f = Math.abs(c[g] - c[m]), y = a && a.lineWidth || 0, x = Math.abs(c[g] + c[m]) / 2, b = a && a[p]; if (Om(b) && b < f) { let w = b / 2 + y / 2; c[g] = x - w, c[m] = x + w } l && ((u === "x" && o.reversed || u === "y" && !r.reversed) && (g = m, m = u + "1"), c[g] += l, c[m] -= l) } return c } haloPath(t) { if (!t) return []; let { x: e = 0, y: i = 0, width: s = 0, height: o = 0 } = this.shapeArgs || {}; return [["M", e - t, i - t], ["L", e - t, i + o + t], ["L", e + s + t, i + o + t], ["L", e + s + t, i - t], ["Z"]] } isValid() { return this.value !== 1 / 0 && this.value !== -1 / 0 } } Em(xh.prototype, { dataLabelOnNull: !0, moveToTopOnHover: !0, ttBelow: !1 }); let { isNumber: Dm } = I, { doc: Bm } = C, { defined: zm, pick: bh } = I, { series: ti, seriesTypes: { column: Nm, scatter: vh } } = G, { prototype: { symbols: _s } } = ye, { addEvent: Um, extend: jm, fireEvent: Rm, isNumber: Js, merge: Qr, pick: Wm } = I, { colorFromPoint: Fm, getContext: Xm } = { colorFromPoint: function (h, t) { let e = t.series.colorAxis; if (e) { let i = e.toColor(h || 0, t).split(")")[0].split("(")[1].split(",").map(s => bh(parseFloat(s), parseInt(s, 10))); return i[3] = 255 * bh(i[3], 1), zm(h) && t.visible || (i[3] = 0), i } return [0, 0, 0, 0] }, getContext: function (h) { let { canvas: t, context: e } = h; return t && e ? (e.clearRect(0, 0, t.width, t.height), e) : (h.canvas = Bm.createElement("canvas"), h.context = h.canvas.getContext("2d", { willReadFrequently: !0 }) || void 0, h.context) } }; class Fi extends vh { constructor() { super(...arguments), this.valueMax = NaN, this.valueMin = NaN, this.isDirtyCanvas = !0 } drawPoints() { let t = this, e = t.options, i = e.interpolation, s = e.marker || {}; if (i) { let { image: o, chart: r, xAxis: a, yAxis: n } = t, { reversed: l = !1, len: c } = a, { reversed: d = !1, len: p } = n, u = { width: c, height: p }; if (!o || t.isDirtyData || t.isDirtyCanvas) { let g = Xm(t), { canvas: m, options: { colsize: f = 1, rowsize: y = 1 }, points: x, points: { length: b } } = t, w = r.colorAxis && r.colorAxis[0]; if (m && g && w) { let { min: v, max: S } = a.getExtremes(), { min: A, max: M } = n.getExtremes(), k = S - v, T = M - A, P = Math.round(k / f / 8 * 8), L = Math.round(T / y / 8 * 8), [O, B] = [[P, P / k, l, "ceil"], [L, L / T, !d, "floor"]].map(([W, F, lt, X]) => lt ? $ => Math[X](W - F * $) : $ => Math[X](F * $)), D = m.width = P + 1, z = D * (m.height = L + 1), E = (b - 1) / z, N = new Uint8ClampedArray(4 * z), V = (W, F) => 4 * Math.ceil(D * B(F - A) + O(W - v)); t.buildKDTree(); for (let W = 0; W < z; W++) { let F = x[Math.ceil(E * W)], { x: lt, y: X } = F; N.set(Fm(F.value, F), V(lt, X)) } g.putImageData(new ImageData(N, D), 0, 0), o ? o.attr({ ...u, href: m.toDataURL("image/png", 1) }) : (t.directTouch = !1, t.image = r.renderer.image(m.toDataURL("image/png", 1)).attr(u).add(t.group)) } t.isDirtyCanvas = !1 } else (o.width !== c || o.height !== p) && o.attr(u) } else (s.enabled || t._hasPointMarkers) && (ti.prototype.drawPoints.call(t), t.points.forEach(o => { o.graphic && (o.graphic[t.chart.styledMode ? "css" : "animate"](t.colorAttribs(o)), o.value === null && o.graphic.addClass("highcharts-null-point")) })) } getExtremes() { let { dataMin: t, dataMax: e } = ti.prototype.getExtremes.call(this, this.getColumn("value")); return Js(t) && (this.valueMin = t), Js(e) && (this.valueMax = e), ti.prototype.getExtremes.call(this) } getValidPoints(t, e) { return ti.prototype.getValidPoints.call(this, t, e, !0) } hasData() { return !!this.dataTable.rowCount } init() { super.init.apply(this, arguments); let t = this.options; t.pointRange = Wm(t.pointRange, t.colsize || 1), this.yAxis.axisPointRange = t.rowsize || 1, _s.ellipse = _s.circle, t.marker && Js(t.borderRadius) && (t.marker.r = t.borderRadius) } markerAttribs(t, e) { var s, o; let i = t.shapeArgs || {}; if (t.hasImage) return { x: t.plotX, y: t.plotY }; if (e && e !== "normal") { let r = t.options.marker || {}, a = this.options.marker || {}, n = ((s = a.states) == null ? void 0 : s[e]) || {}, l = ((o = r.states) == null ? void 0 : o[e]) || {}, c = (l.width || n.width || i.width || 0) + (l.widthPlus || n.widthPlus || 0), d = (l.height || n.height || i.height || 0) + (l.heightPlus || n.heightPlus || 0); return { x: (i.x || 0) + ((i.width || 0) - c) / 2, y: (i.y || 0) + ((i.height || 0) - d) / 2, width: c, height: d } } return i } pointAttribs(t, e) { var c, d, p, u, g, m; let i = ti.prototype.pointAttribs.call(this, t, e), s = this.options || {}, o = this.chart.options.plotOptions || {}, r = o.series || {}, a = o.heatmap || {}, n = (t == null ? void 0 : t.options.borderColor) || s.borderColor || a.borderColor || r.borderColor, l = (t == null ? void 0 : t.options.borderWidth) || s.borderWidth || a.borderWidth || r.borderWidth || i["stroke-width"]; if (i.stroke = ((c = t == null ? void 0 : t.marker) == null ? void 0 : c.lineColor) || ((d = s.marker) == null ? void 0 : d.lineColor) || n || this.color, i["stroke-width"] = l, e && e !== "normal") { let f = Qr((p = s.states) == null ? void 0 : p[e], (g = (u = s.marker) == null ? void 0 : u.states) == null ? void 0 : g[e], ((m = t == null ? void 0 : t.options.states) == null ? void 0 : m[e]) || {}); i.fill = f.color || _.parse(i.fill).brighten(f.brightness || 0).get(), i.stroke = f.lineColor || i.stroke } return i } translate() { var r; let { borderRadius: t, marker: e } = this.options, i = (e == null ? void 0 : e.symbol) || "rect", s = _s[i] ? i : "rect", o = ["circle", "square"].indexOf(s) !== -1; for (let a of (this.generatePoints(), this.points)) { let n = a.getCellAttributes(), l = Math.min(n.x1, n.x2), c = Math.min(n.y1, n.y2), d = Math.max(Math.abs(n.x2 - n.x1), 0), p = Math.max(Math.abs(n.y2 - n.y1), 0); if (a.hasImage = (((r = a.marker) == null ? void 0 : r.symbol) || i).indexOf("url") === 0, o) { let u = Math.abs(d - p); l = Math.min(n.x1, n.x2) + (d < p ? 0 : u / 2), c = Math.min(n.y1, n.y2) + (d < p ? u / 2 : 0), d = p = Math.min(d, p) } a.hasImage && (a.marker = { width: d, height: p }), a.plotX = a.clientX = (n.x1 + n.x2) / 2, a.plotY = (n.y1 + n.y2) / 2, a.shapeType = "path", a.shapeArgs = Qr(!0, { x: l, y: c, width: d, height: p }, { d: _s[s](l, c, d, p, { r: Js(t) ? t : 0 }) }) } Rm(this, "afterTranslate") } } Fi.defaultOptions = Qr(vh.defaultOptions, { animation: !1, borderRadius: 0, borderWidth: 0, interpolation: !1, nullColor: "#f7f7f7", dataLabels: { formatter: function () { let { numberFormatter: h } = this.series.chart, { value: t } = this.point; return Dm(t) ? h(t, -1) : "" }, inside: !0, verticalAlign: "middle", crop: !1, overflow: "allow", padding: 0 }, marker: { symbol: "rect", radius: 0, lineColor: void 0, states: { hover: { lineWidthPlus: 0 }, select: {} } }, clip: !0, pointRange: null, tooltip: { pointFormat: "{point.x}, {point.y}: {point.value}<br/>" }, states: { hover: { halo: !1, brightness: .2 } }, legendSymbol: "rectangle" }), Um(Fi, "afterDataClassLegendClick", function () { this.isDirtyCanvas = !0, this.drawPoints() }), jm(Fi.prototype, { axisTypes: xt.seriesMembers.axisTypes, colorKey: xt.seriesMembers.colorKey, directTouch: !0, getExtremesFromAll: !0, keysAffectYAxis: ["y"], parallelArrays: xt.seriesMembers.parallelArrays, pointArrayMap: ["y", "value"], pointClass: xh, specialGroup: "group", trackerGroups: xt.seriesMembers.trackerGroups, alignDataLabel: Nm.prototype.alignDataLabel, colorAttribs: xt.seriesMembers.colorAttribs, getSymbol: ti.prototype.getSymbol }), xt.compose(Fi), G.registerSeriesType("heatmap", Fi), C.ColorMapComposition = xt, C.MapChart = C.MapChart || Rs, C.MapNavigation = C.MapNavigation || js, C.MapView = C.MapView || Ht, C.Projection = C.Projection || bt, C.mapChart = C.Map = C.MapChart.mapChart, C.maps = C.MapChart.maps, C.geojson = Ws.geojson, C.topo2geo = Ws.topo2geo, Ws.compose(C.Chart), Ks.compose(C.Axis, C.Chart, C.Legend), js.compose(Rs, C.Pointer, C.SVGRenderer), Ht.compose(Rs), C.product = "Highmaps"; let Ym = C; return ta.default
        })())
    }(to)), to.exports
} var Km = $m(); const qm = Hm(Km), _m = "United States of America", Jm = "2.3.1", Qm = "FeatureCollection", t1 = "Copyright (c) 2025 Highsoft AS, Based on data from Natural Earth", e1 = "Natural Earth", i1 = "http://www.naturalearthdata.com", s1 = { type: "name", properties: { name: "urn:ogc:def:crs:EPSG:102004" } }, o1 = JSON.parse('[{"type":"Feature","id":"US.MA","properties":{"hc-group":"admin1","hc-middle-x":0.36,"hc-middle-y":0.47,"hc-key":"us-ma","hc-a2":"MA","labelrank":"0","hasc":"US.MA","woe-id":"2347580","state-fips":"25","fips":"US25","postal-code":"MA","name":"Massachusetts","country":"United States of America","region":"Northeast","longitude":"-71.99930000000001","woe-name":"Massachusetts","latitude":"42.3739","woe-label":"Massachusetts, US, United States","type":"State"},"geometry":{"type":"MultiPolygon","coordinates":[[[[9430,7889],[9476,7878],[9436,7864],[9417,7844],[9430,7889]]],[[[9314,7915],[9312,7927],[9304,7921],[9278,7938],[9254,7990],[9177,7968],[8997,7925],[8860,7896],[8853,7901],[8856,8080],[8922,8096],[9005,8115],[9005,8115],[9222,8166],[9242,8201],[9300,8236],[9318,8197],[9357,8186],[9312,8147],[9299,8081],[9324,8091],[9365,8074],[9428,7985],[9483,7974],[9525,8007],[9501,8067],[9535,8028],[9549,7982],[9504,7965],[9420,7906],[9411,7955],[9371,7921],[9373,7898],[9339,7878],[9327,7915],[9314,7915]]]]}},{"type":"Feature","id":"US.WA","properties":{"hc-group":"admin1","hc-middle-x":0.56,"hc-middle-y":0.52,"hc-key":"us-wa","hc-a2":"WA","labelrank":"0","hasc":"US.WA","woe-id":"2347606","state-fips":"53","fips":"US53","postal-code":"WA","name":"Washington","country":"United States of America","region":"West","longitude":"-120.361","woe-name":"Washington","latitude":"47.4865","woe-label":"Washington, US, United States","type":"State"},"geometry":{"type":"MultiPolygon","coordinates":[[[[-77,9797],[-56,9768],[-91,9757],[-86,9712],[-136,9751],[-111,9756],[-77,9797]]],[[[-52,9689],[-85,9658],[-66,9645],[-43,9568],[-77,9588],[-74,9635],[-89,9664],[-52,9690],[-60,9697],[-61,9737],[-31,9701],[-12,9731],[-9,9774],[-33,9788],[-46,9839],[-32,9851],[926,9593],[767,8925],[779,8870],[774,8822],[398,8914],[378,8905],[289,8922],[163,8905],[94,8923],[38,8914],[-10,8925],[-22,8950],[-113,8979],[-207,8965],[-283,9014],[-271,9096],[-280,9134],[-321,9167],[-357,9171],[-365,9207],[-400,9226],[-436,9219],[-460,9259],[-436,9333],[-441,9279],[-416,9297],[-401,9347],[-434,9357],[-429,9395],[-369,9396],[-424,9436],[-424,9523],[-410,9624],[-433,9678],[-428,9749],[-385,9790],[-313,9713],[-183,9655],[-161,9666],[-146,9623],[-100,9637],[-95,9567],[-135,9518],[-77,9566],[-112,9491],[-89,9426],[-154,9433],[-175,9394],[-167,9449],[-222,9394],[-157,9376],[-124,9418],[-82,9426],[-82,9476],[-66,9527],[-18,9570],[-37,9644],[-24,9661],[-52,9689]]]]}},{"type":"Feature","id":"US.CA","properties":{"hc-group":"admin1","hc-middle-x":0.51,"hc-middle-y":0.67,"hc-key":"us-ca","hc-a2":"CA","labelrank":"0","hasc":"US.CA","woe-id":"2347563","state-fips":"6","fips":"US06","postal-code":"CA","name":"California","country":"United States of America","region":"West","longitude":"-119.591","woe-name":"California","latitude":"36.7496","woe-label":"California, US, United States","type":"State"},"geometry":{"type":"Polygon","coordinates":[[[-833,8186],[-50,7955],[-253,7203],[32,6779],[261,6430],[593,5936],[620,5788],[660,5730],[598,5702],[559,5661],[555,5605],[510,5537],[489,5536],[476,5452],[519,5416],[492,5355],[451,5357],[-76,5426],[-69,5467],[-95,5476],[-84,5583],[-110,5649],[-224,5792],[-276,5799],[-265,5822],[-284,5881],[-342,5885],[-417,5946],[-422,5975],[-484,6035],[-539,6046],[-588,6077],[-659,6091],[-686,6135],[-647,6273],[-691,6316],[-672,6333],[-720,6428],[-742,6442],[-793,6601],[-820,6637],[-816,6709],[-775,6726],[-761,6756],[-778,6807],[-821,6819],[-855,6888],[-842,6929],[-853,6979],[-833,7041],[-810,7042],[-816,6985],[-764,6931],[-772,6991],[-797,7030],[-787,7089],[-738,7083],[-782,7126],[-806,7122],[-833,7050],[-892,7126],[-903,7243],[-983,7395],[-967,7420],[-969,7507],[-943,7553],[-936,7629],[-964,7712],[-999,7766],[-993,7813],[-890,7943],[-849,8038],[-844,8118],[-860,8134],[-833,8186]]]}},{"type":"Feature","id":"US.OR","properties":{"hc-group":"admin1","hc-middle-x":0.47,"hc-middle-y":0.52,"hc-key":"us-or","hc-a2":"OR","labelrank":"0","hasc":"US.OR","woe-id":"2347596","state-fips":"41","fips":"US41","postal-code":"OR","name":"Oregon","country":"United States of America","region":"West","longitude":"-120.386","woe-name":"Oregon","latitude":"43.8333","woe-label":"Oregon, US, United States","type":"State"},"geometry":{"type":"Polygon","coordinates":[[[-50,7955],[-833,8186],[-851,8223],[-847,8281],[-817,8362],[-827,8415],[-793,8455],[-756,8527],[-714,8570],[-672,8648],[-594,8829],[-582,8877],[-494,9051],[-493,9108],[-468,9158],[-460,9216],[-396,9192],[-367,9202],[-359,9169],[-321,9167],[-280,9134],[-271,9096],[-283,9014],[-207,8965],[-113,8979],[-22,8950],[-10,8925],[38,8914],[94,8923],[163,8905],[289,8922],[378,8905],[398,8914],[774,8822],[785,8775],[821,8744],[823,8698],[776,8646],[718,8545],[624,8450],[615,8403],[662,8361],[616,8265],[510,7813],[-50,7955]]]}},{"type":"Feature","id":"US.WI","properties":{"hc-group":"admin1","hc-middle-x":0.41,"hc-middle-y":0.38,"hc-key":"us-wi","hc-a2":"WI","labelrank":"0","hasc":"US.WI","woe-id":"2347608","state-fips":"55","fips":"US55","postal-code":"WI","name":"Wisconsin","country":"United States of America","region":"Midwest","longitude":"-89.5831","woe-name":"Wisconsin","latitude":"44.3709","woe-label":"Wisconsin, US, United States","type":"State"},"geometry":{"type":"MultiPolygon","coordinates":[[[[6206,8297],[6197,8237],[6159,8156],[6136,8180],[6161,8249],[6206,8297]]],[[[5575,7508],[5561,7544],[5494,7563],[5465,7670],[5479,7702],[5445,7758],[5431,7866],[5405,7892],[5360,7903],[5273,7994],[5217,8029],[5181,8035],[5136,8072],[5146,8117],[5144,8214],[5158,8253],[5117,8285],[5116,8322],[5147,8375],[5220,8422],[5214,8573],[5245,8603],[5303,8589],[5410,8635],[5449,8660],[5489,8656],[5481,8617],[5508,8583],[5554,8572],[5588,8553],[5611,8510],[5795,8473],[5849,8447],[5968,8437],[5993,8394],[6045,8372],[6042,8286],[6080,8287],[6071,8242],[6096,8224],[6058,8180],[6028,8078],[6049,8076],[6099,8156],[6129,8170],[6153,8151],[6124,8019],[6136,7996],[6101,7916],[6110,7860],[6082,7742],[6089,7679],[6116,7626],[6119,7543],[5780,7519],[5606,7509],[5575,7508]]]]}},{"type":"Feature","id":"US.ME","properties":{"hc-group":"admin1","hc-middle-x":0.43,"hc-middle-y":0.4,"hc-key":"us-me","hc-a2":"ME","labelrank":"0","hasc":"US.ME","woe-id":"2347578","state-fips":"23","fips":"US23","postal-code":"ME","name":"Maine","country":"United States of America","region":"Northeast","longitude":"-69.1973","woe-name":"Maine","latitude":"45.148","woe-label":"Maine, US, United States","type":"State"},"geometry":{"type":"MultiPolygon","coordinates":[[[[9623,8727],[9643,8763],[9665,8747],[9641,8690],[9623,8727]]],[[[9225,8399],[9079,8830],[9115,8824],[9130,8917],[9168,8971],[9177,9035],[9160,9062],[9160,9140],[9176,9161],[9166,9236],[9238,9459],[9272,9467],[9292,9423],[9319,9415],[9428,9491],[9519,9435],[9630,9097],[9697,9099],[9717,9017],[9747,8995],[9778,9009],[9851,8939],[9818,8875],[9789,8883],[9784,8851],[9706,8811],[9712,8773],[9690,8747],[9669,8782],[9611,8766],[9590,8707],[9615,8647],[9554,8716],[9552,8761],[9517,8719],[9529,8622],[9505,8581],[9483,8586],[9467,8544],[9433,8531],[9420,8493],[9387,8524],[9346,8471],[9362,8439],[9314,8347],[9298,8291],[9235,8354],[9225,8399]]]]}},{"type":"Feature","id":"US.MI","properties":{"hc-group":"admin1","hc-middle-x":0.71,"hc-middle-y":0.67,"hc-key":"us-mi","hc-a2":"MI","labelrank":"0","hasc":"US.MI","woe-id":"2347581","state-fips":"26","fips":"US26","postal-code":"MI","name":"Michigan","country":"United States of America","region":"Midwest","longitude":"-84.9479","woe-name":"Michigan","latitude":"43.4343","woe-label":"Michigan, US, United States","type":"State"},"geometry":{"type":"MultiPolygon","coordinates":[[[[6802,8561],[6808,8523],[6764,8521],[6774,8565],[6802,8561]]],[[[5863,9010],[5834,8966],[5759,8913],[5758,8947],[5863,9010]]],[[[6976,7443],[6815,7415],[6718,7400],[6716,7416],[6323,7372],[6364,7423],[6399,7509],[6417,7630],[6409,7695],[6330,7861],[6345,7903],[6322,7979],[6361,8059],[6352,8141],[6381,8159],[6381,8204],[6423,8217],[6453,8283],[6469,8252],[6460,8196],[6479,8180],[6501,8221],[6497,8298],[6533,8342],[6567,8348],[6542,8410],[6593,8461],[6646,8436],[6627,8469],[6669,8467],[6654,8434],[6698,8433],[6726,8400],[6837,8377],[6863,8359],[6884,8307],[6860,8285],[6902,8213],[6903,8115],[6872,8094],[6868,8040],[6821,8014],[6824,7934],[6868,7920],[6900,7950],[6937,8030],[6993,8059],[7042,8027],[7097,7866],[7128,7802],[7124,7704],[7066,7697],[7061,7631],[7021,7590],[7008,7500],[6976,7443]]],[[[5874,8741],[5900,8700],[5901,8651],[5938,8693],[6017,8689],[6049,8673],[6107,8596],[6174,8609],[6192,8589],[6244,8596],[6318,8663],[6430,8674],[6485,8705],[6529,8713],[6518,8645],[6560,8631],[6591,8646],[6609,8627],[6633,8653],[6688,8665],[6692,8589],[6745,8536],[6723,8521],[6631,8516],[6606,8530],[6598,8476],[6541,8514],[6480,8529],[6444,8521],[6426,8490],[6320,8470],[6302,8429],[6244,8388],[6264,8448],[6227,8437],[6192,8395],[6185,8444],[6096,8224],[6071,8242],[6080,8287],[6042,8286],[6045,8372],[5993,8394],[5968,8437],[5849,8447],[5795,8473],[5611,8510],[5588,8553],[5554,8572],[5623,8604],[5661,8642],[5731,8656],[5776,8696],[5805,8702],[5860,8764],[5868,8750],[5893,8802],[5958,8837],[6017,8829],[5931,8757],[5903,8703],[5900,8738],[5874,8741]]]]}},{"type":"Feature","id":"US.NV","properties":{"hc-group":"admin1","hc-middle-x":0.46,"hc-middle-y":0.38,"hc-key":"us-nv","hc-a2":"NV","labelrank":"0","hasc":"US.NV","woe-id":"2347587","state-fips":"32","fips":"US32","postal-code":"NV","name":"Nevada","country":"United States of America","region":"West","longitude":"-117.02","woe-name":"Nevada","latitude":"39.4299","woe-label":"Nevada, US, United States","type":"State"},"geometry":{"type":"Polygon","coordinates":[[[-50,7955],[510,7813],[897,7727],[1073,7690],[929,6975],[818,6420],[777,6221],[752,6180],[669,6227],[631,6217],[631,6159],[611,6068],[614,5982],[593,5936],[261,6430],[32,6779],[-253,7203],[-50,7955]]]}},{"type":"Feature","id":"US.NM","properties":{"hc-group":"admin1","hc-middle-x":0.51,"hc-middle-y":0.5,"hc-key":"us-nm","hc-a2":"NM","labelrank":"0","hasc":"US.NM","woe-id":"2347590","state-fips":"35","fips":"US35","postal-code":"NM","name":"New Mexico","country":"United States of America","region":"West","longitude":"-106.024","woe-name":"New Mexico","latitude":"34.5002","woe-label":"New Mexico, US, United States","type":"State"},"geometry":{"type":"Polygon","coordinates":[[[1841,6242],[3091,6104],[3083,6007],[3081,5975],[3072,5970],[2976,4810],[2181,4887],[2208,4823],[1830,4873],[1815,4756],[1630,4782],[1736,5514],[1841,6242]]]}},{"type":"Feature","id":"US.CO","properties":{"hc-group":"admin1","hc-middle-x":0.51,"hc-middle-y":0.5,"hc-key":"us-co","hc-a2":"CO","labelrank":"0","hasc":"US.CO","woe-id":"2347564","state-fips":"8","fips":"US08","postal-code":"CO","name":"Colorado","country":"United States of America","region":"West","longitude":"-105.543","woe-name":"Colorado","latitude":"38.9998","woe-label":"Colorado, US, United States","type":"State"},"geometry":{"type":"Polygon","coordinates":[[[3091,6104],[1841,6242],[1966,7108],[1990,7269],[2964,7155],[3357,7124],[3339,6866],[3329,6696],[3290,6089],[3091,6104]]]}},{"type":"Feature","id":"US.WY","properties":{"hc-group":"admin1","hc-middle-x":0.51,"hc-middle-y":0.5,"hc-key":"us-wy","hc-a2":"WY","labelrank":"0","hasc":"US.WY","woe-id":"2347609","state-fips":"56","fips":"US56","postal-code":"WY","name":"Wyoming","country":"United States of America","region":"West","longitude":"-107.552","woe-name":"Wyoming","latitude":"42.9999","woe-label":"Wyoming, US, United States","type":"State"},"geometry":{"type":"Polygon","coordinates":[[[2964,7155],[1990,7269],[1600,7329],[1643,7585],[1677,7785],[1750,8226],[1772,8355],[3056,8191],[3019,7770],[3010,7672],[3002,7575],[2964,7155]]]}},{"type":"Feature","id":"US.KS","properties":{"hc-group":"admin1","hc-middle-x":0.3,"hc-middle-y":0.49,"hc-key":"us-ks","hc-a2":"KS","labelrank":"0","hasc":"US.KS","woe-id":"2347575","state-fips":"20","fips":"US20","postal-code":"KS","name":"Kansas","country":"United States of America","region":"Midwest","longitude":"-98.3309","woe-name":"Kansas","latitude":"38.5","woe-label":"Kansas, US, United States","type":"State"},"geometry":{"type":"Polygon","coordinates":[[[3339,6866],[4682,6826],[4769,6780],[4726,6705],[4767,6667],[4781,6624],[4824,6600],[4833,6050],[3290,6089],[3329,6696],[3339,6866]]]}},{"type":"Feature","id":"US.NE","properties":{"hc-group":"admin1","hc-middle-x":0.43,"hc-middle-y":0.5,"hc-key":"us-ne","hc-a2":"NE","labelrank":"0","hasc":"US.NE","woe-id":"2347586","state-fips":"31","fips":"US31","postal-code":"NE","name":"Nebraska","country":"United States of America","region":"Midwest","longitude":"-99.68550000000001","woe-name":"Nebraska","latitude":"41.5002","woe-label":"Nebraska, US, United States","type":"State"},"geometry":{"type":"Polygon","coordinates":[[[4682,6826],[3339,6866],[3357,7124],[2964,7155],[3002,7575],[3010,7672],[4071,7611],[4148,7558],[4194,7574],[4297,7577],[4330,7551],[4409,7521],[4453,7479],[4469,7474],[4478,7398],[4515,7341],[4533,7291],[4529,7228],[4559,7206],[4571,7165],[4579,7031],[4592,6986],[4592,6981],[4592,6981],[4591,6981],[4591,6981],[4619,6915],[4682,6826]]]}},{"type":"Feature","id":"US.OK","properties":{"hc-group":"admin1","hc-middle-x":0.78,"hc-middle-y":0.52,"hc-key":"us-ok","hc-a2":"OK","labelrank":"0","hasc":"US.OK","woe-id":"2347595","state-fips":"40","fips":"US40","postal-code":"OK","name":"Oklahoma","country":"United States of America","region":"South","longitude":"-97.1309","woe-name":"Oklahoma","latitude":"35.452","woe-label":"Oklahoma, US, United States","type":"State"},"geometry":{"type":"Polygon","coordinates":[[[3290,6089],[4833,6050],[4833,6017],[4835,5920],[4877,5632],[4875,5180],[4790,5207],[4714,5260],[4685,5235],[4632,5257],[4595,5233],[4559,5242],[4474,5191],[4405,5248],[4360,5237],[4347,5258],[4312,5234],[4304,5199],[4283,5247],[4248,5227],[4181,5268],[4121,5246],[4093,5310],[4007,5296],[3908,5334],[3856,5341],[3842,5388],[3753,5388],[3686,5437],[3707,5936],[3081,5975],[3083,6007],[3091,6104],[3290,6089]]]}},{"type":"Feature","id":"US.MO","properties":{"hc-group":"admin1","hc-middle-x":0.48,"hc-middle-y":0.51,"hc-key":"us-mo","hc-a2":"MO","labelrank":"0","hasc":"US.MO","woe-id":"2347584","state-fips":"29","fips":"US29","postal-code":"MO","name":"Missouri","country":"United States of America","region":"Midwest","longitude":"-92.446","woe-name":"Missouri","latitude":"38.5487","woe-label":"Missouri, US, United States","type":"State"},"geometry":{"type":"Polygon","coordinates":[[[4835,5920],[4833,6017],[4833,6050],[4824,6600],[4781,6624],[4767,6667],[4726,6705],[4769,6780],[4682,6826],[4619,6915],[4591,6981],[4591,6981],[4592,6981],[4846,6977],[5120,6985],[5389,7006],[5449,6947],[5449,6947],[5449,6947],[5436,6893],[5454,6813],[5475,6774],[5540,6711],[5588,6679],[5616,6596],[5642,6567],[5672,6592],[5735,6561],[5692,6420],[5752,6350],[5792,6336],[5873,6276],[5898,6211],[5886,6165],[5918,6121],[5975,6097],[5976,6033],[5956,5988],[5932,6005],[5921,5968],[5911,5955],[5907,5967],[5890,5980],[5893,5966],[5901,5936],[5869,5898],[5888,5872],[5868,5834],[5731,5821],[5790,5904],[5767,5957],[4835,5920]]]}},{"type":"Feature","id":"US.IL","properties":{"hc-group":"admin1","hc-middle-x":0.56,"hc-middle-y":0.45,"hc-key":"us-il","hc-a2":"IL","labelrank":"0","hasc":"US.IL","woe-id":"2347572","state-fips":"17","fips":"US17","postal-code":"IL","name":"Illinois","country":"United States of America","region":"Midwest","longitude":"-89.1991","woe-name":"Illinois","latitude":"39.946","woe-label":"Illinois, US, United States","type":"State"},"geometry":{"type":"Polygon","coordinates":[[[6119,7543],[6121,7488],[6192,7351],[6247,6739],[6226,6674],[6254,6638],[6266,6585],[6244,6520],[6222,6503],[6194,6422],[6176,6404],[6179,6328],[6159,6283],[6171,6241],[6102,6218],[6105,6131],[6015,6162],[5987,6157],[5962,6117],[5975,6097],[5918,6121],[5886,6165],[5898,6211],[5873,6276],[5792,6336],[5752,6350],[5692,6420],[5735,6561],[5672,6592],[5642,6567],[5616,6596],[5588,6679],[5540,6711],[5475,6774],[5454,6813],[5436,6893],[5449,6947],[5449,6947],[5449,6947],[5458,7004],[5496,7020],[5535,7098],[5536,7132],[5509,7160],[5523,7224],[5579,7232],[5646,7276],[5671,7332],[5672,7411],[5625,7441],[5575,7508],[5575,7508],[5606,7509],[5848,7523],[6119,7543]]]}},{"type":"Feature","id":"US.IN","properties":{"hc-group":"admin1","hc-middle-x":0.49,"hc-middle-y":0.43,"hc-key":"us-in","hc-a2":"IN","labelrank":"0","hasc":"US.IN","woe-id":"2347573","state-fips":"18","fips":"US18","postal-code":"IN","name":"Indiana","country":"United States of America","region":"Midwest","longitude":"-86.1396","woe-name":"Indiana","latitude":"39.8874","woe-label":"Indiana, US, United States","type":"State"},"geometry":{"type":"Polygon","coordinates":[[[6192,7351],[6239,7329],[6323,7372],[6716,7416],[6718,7400],[6732,7296],[6797,6730],[6792,6683],[6808,6651],[6737,6617],[6682,6619],[6693,6572],[6657,6540],[6652,6507],[6622,6498],[6608,6438],[6583,6411],[6531,6450],[6485,6413],[6485,6390],[6444,6379],[6426,6401],[6359,6356],[6303,6376],[6269,6350],[6209,6363],[6179,6328],[6176,6404],[6194,6422],[6222,6503],[6244,6520],[6266,6585],[6254,6638],[6226,6674],[6247,6739],[6192,7351]]]}},{"type":"Feature","id":"US.VT","properties":{"hc-group":"admin1","hc-middle-x":0.42,"hc-middle-y":0.43,"hc-key":"us-vt","hc-a2":"VT","labelrank":"0","hasc":"US.VT","woe-id":"2347604","state-fips":"50","fips":"US50","postal-code":"VT","name":"Vermont","country":"United States of America","region":"Northeast","longitude":"-72.7317","woe-name":"Vermont","latitude":"44.0886","woe-label":"Vermont, US, United States","type":"State"},"geometry":{"type":"Polygon","coordinates":[[[8922,8096],[8856,8080],[8807,8284],[8772,8287],[8772,8328],[8740,8402],[8748,8453],[8739,8514],[8720,8537],[8695,8646],[8811,8677],[9024,8736],[9020,8661],[9045,8629],[9033,8585],[8978,8526],[8986,8490],[8981,8392],[8964,8320],[8979,8261],[8979,8148],[9005,8115],[9005,8115],[8922,8096]]]}},{"type":"Feature","id":"US.AR","properties":{"hc-group":"admin1","hc-middle-x":0.47,"hc-middle-y":0.43,"hc-key":"us-ar","hc-a2":"AR","labelrank":"0","hasc":"US.AR","woe-id":"2347562","state-fips":"5","fips":"US05","postal-code":"AR","name":"Arkansas","country":"United States of America","region":"South","longitude":"-92.14279999999999","woe-name":"Arkansas","latitude":"34.7563","woe-label":"Arkansas, US, United States","type":"State"},"geometry":{"type":"Polygon","coordinates":[[[4975,5016],[4971,5157],[4910,5157],[4875,5180],[4877,5632],[4835,5920],[5767,5957],[5790,5904],[5731,5821],[5868,5834],[5871,5791],[5827,5763],[5835,5714],[5798,5670],[5802,5602],[5762,5567],[5770,5547],[5730,5520],[5706,5470],[5709,5414],[5635,5340],[5647,5309],[5609,5297],[5620,5250],[5583,5215],[5607,5162],[5598,5120],[5618,5077],[5605,5041],[5563,5038],[4975,5016]]]}},{"type":"Feature","id":"US.TX","properties":{"hc-group":"admin1","hc-middle-x":0.69,"hc-middle-y":0.52,"hc-key":"us-tx","hc-a2":"TX","labelrank":"0","hasc":"US.TX","woe-id":"2347602","state-fips":"48","fips":"US48","postal-code":"TX","name":"Texas","country":"United States of America","region":"South","longitude":"-98.7607","woe-name":"Texas","latitude":"31.131","woe-label":"Texas, US, United States","type":"State"},"geometry":{"type":"MultiPolygon","coordinates":[[[[4875,5180],[4910,5157],[4971,5157],[4975,5016],[4980,4752],[5033,4679],[5031,4646],[5105,4506],[5093,4447],[5059,4380],[5065,4253],[5047,4228],[5018,4172],[5032,4146],[4989,4147],[4854,4084],[4875,4116],[4831,4102],[4842,4162],[4778,4141],[4769,4106],[4839,4052],[4789,4023],[4801,4063],[4739,3976],[4638,3901],[4557,3881],[4544,3857],[4451,3804],[4448,3787],[4381,3749],[4308,3672],[4340,3735],[4307,3756],[4261,3721],[4306,3712],[4263,3655],[4221,3658],[4249,3617],[4213,3527],[4195,3545],[4141,3510],[4206,3511],[4178,3442],[4232,3206],[4272,3164],[4203,3135],[4114,3192],[4013,3198],[3979,3230],[3915,3245],[3878,3279],[3810,3292],[3795,3375],[3727,3467],[3715,3534],[3721,3603],[3677,3628],[3595,3762],[3548,3801],[3525,3881],[3477,3970],[3469,4021],[3393,4097],[3411,4119],[3365,4132],[3310,4204],[3150,4220],[3103,4248],[3082,4218],[3018,4214],[2959,4096],[2967,4083],[2896,4024],[2861,4031],[2754,4113],[2695,4134],[2651,4187],[2595,4230],[2567,4305],[2573,4370],[2512,4503],[2437,4557],[2309,4714],[2275,4731],[2239,4806],[2208,4823],[2181,4887],[2976,4810],[3072,5970],[3081,5975],[3707,5936],[3686,5437],[3753,5388],[3842,5388],[3856,5341],[3908,5334],[4007,5296],[4093,5310],[4121,5246],[4181,5268],[4248,5227],[4283,5247],[4304,5199],[4312,5234],[4347,5258],[4360,5237],[4405,5248],[4474,5191],[4559,5242],[4595,5233],[4632,5257],[4685,5235],[4714,5260],[4790,5207],[4875,5180]]],[[[4269,3610],[4220,3493],[4219,3420],[4245,3297],[4214,3394],[4222,3530],[4269,3610]]]]}},{"type":"Feature","id":"US.RI","properties":{"hc-group":"admin1","hc-middle-x":0.55,"hc-middle-y":0.78,"hc-key":"us-ri","hc-a2":"RI","labelrank":"0","hasc":"US.RI","woe-id":"2347598","state-fips":"44","fips":"US44","postal-code":"RI","name":"Rhode Island","country":"United States of America","region":"Northeast","longitude":"-71.5082","woe-name":"Rhode Island","latitude":"41.6242","woe-label":"Rhode Island, US, United States","type":"State"},"geometry":{"type":"MultiPolygon","coordinates":[[[[9339,7878],[9325,7871],[9314,7915],[9327,7915],[9339,7878]]],[[[9177,7968],[9254,7990],[9278,7938],[9304,7921],[9320,7866],[9285,7851],[9279,7822],[9216,7790],[9212,7845],[9177,7968]]]]}},{"type":"Feature","id":"US.AL","properties":{"hc-group":"admin1","hc-middle-x":0.47,"hc-middle-y":0.42,"hc-key":"us-al","hc-a2":"AL","labelrank":"0","hasc":"US.AL","woe-id":"2347559","state-fips":"1","fips":"US01","postal-code":"AL","name":"Alabama","country":"United States of America","region":"South","longitude":"-86.7184","woe-name":"Alabama","latitude":"32.8551","woe-label":"Alabama, US, United States","type":"State"},"geometry":{"type":"Polygon","coordinates":[[[6487,4443],[6440,4378],[6291,4361],[6336,4375],[6317,4398],[6267,4399],[6216,4788],[6236,5574],[6215,5600],[6213,5603],[6762,5652],[6912,5135],[6947,5053],[6998,4970],[6970,4930],[6958,4846],[6990,4774],[6983,4704],[7015,4637],[6436,4574],[6431,4541],[6487,4486],[6487,4443]]]}},{"type":"Feature","id":"US.MS","properties":{"hc-group":"admin1","hc-middle-x":0.51,"hc-middle-y":0.48,"hc-key":"us-ms","hc-a2":"MS","labelrank":"0","hasc":"US.MS","woe-id":"2347583","state-fips":"28","fips":"US28","postal-code":"MS","name":"Mississippi","country":"United States of America","region":"South","longitude":"-89.71890000000001","woe-name":"Mississippi","latitude":"32.8657","woe-label":"Mississippi, US, United States","type":"State"},"geometry":{"type":"Polygon","coordinates":[[[6267,4399],[6164,4396],[6059,4360],[6017,4328],[5936,4451],[5955,4536],[5523,4510],[5540,4526],[5522,4581],[5545,4585],[5545,4642],[5565,4662],[5584,4738],[5636,4781],[5670,4868],[5629,4895],[5611,4977],[5627,5018],[5605,5041],[5618,5077],[5598,5120],[5607,5162],[5583,5215],[5620,5250],[5609,5297],[5647,5309],[5635,5340],[5709,5414],[5706,5470],[5730,5520],[5770,5547],[5762,5567],[6122,5592],[6215,5600],[6236,5574],[6216,4788],[6267,4399]]]}},{"type":"Feature","id":"US.NC","properties":{"hc-group":"admin1","hc-middle-x":0.62,"hc-middle-y":0.5,"hc-key":"us-nc","hc-a2":"NC","labelrank":"0","hasc":"US.NC","woe-id":"2347592","state-fips":"37","fips":"US37","postal-code":"NC","name":"North Carolina","country":"United States of America","region":"South","longitude":"-78.866","woe-name":"North Carolina","latitude":"35.6152","woe-label":"North Carolina, US, United States","type":"State"},"geometry":{"type":"MultiPolygon","coordinates":[[[[8716,6394],[8720,6381],[8694,6389],[8694,6389],[8704,6391],[8705,6390],[8709,6392],[8712,6393],[8716,6394]]],[[[8727,6396],[8756,6332],[8852,6203],[8782,6278],[8722,6395],[8724,6396],[8727,6396]]],[[[7532,6183],[7623,6187],[7858,6219],[8691,6388],[8768,6281],[8670,6318],[8707,6291],[8620,6230],[8584,6234],[8581,6204],[8719,6244],[8742,6161],[8737,6222],[8760,6252],[8795,6220],[8797,6153],[8772,6164],[8750,6091],[8709,6073],[8638,6097],[8638,6070],[8551,6078],[8664,6053],[8635,6009],[8661,6003],[8610,5957],[8551,5988],[8590,5949],[8631,5940],[8676,5955],[8686,5995],[8721,5956],[8670,5890],[8565,5865],[8469,5764],[8443,5714],[8432,5616],[8368,5624],[8302,5600],[8029,5790],[7791,5756],[7782,5790],[7714,5830],[7457,5802],[7290,5724],[7210,5711],[7034,5685],[7038,5756],[7073,5762],[7085,5807],[7131,5847],[7188,5859],[7269,5928],[7298,5973],[7352,6010],[7365,5989],[7437,6050],[7464,6038],[7490,6093],[7523,6123],[7532,6183]]]]}},{"type":"Feature","id":"US.VA","properties":{"hc-group":"admin1","hc-middle-x":0.64,"hc-middle-y":0.54,"hc-key":"us-va","hc-a2":"VA","labelrank":"0","hasc":"US.VA","woe-id":"2347605","state-fips":"51","fips":"US51","postal-code":"VA","name":"Virginia","country":"United States of America","region":"South","longitude":"-78.2431","woe-name":"Virginia","latitude":"37.7403","woe-label":"Virginia, US, United States","type":"State"},"geometry":{"type":"MultiPolygon","coordinates":[[[[8722,6395],[8696,6432],[8704,6391],[8694,6389],[8694,6389],[8686,6398],[8691,6388],[7858,6219],[7623,6187],[7532,6183],[7472,6170],[7116,6120],[7221,6173],[7268,6217],[7309,6294],[7363,6332],[7431,6411],[7470,6351],[7530,6341],[7567,6378],[7595,6360],[7649,6382],[7664,6419],[7690,6412],[7773,6459],[7767,6505],[7840,6674],[7857,6759],[7932,6729],[7974,6848],[7998,6837],[8048,6900],[8072,6952],[8076,7028],[8188,6969],[8198,7020],[8256,7009],[8251,6984],[8341,6945],[8347,6939],[8353,6939],[8367,6892],[8334,6870],[8323,6802],[8347,6786],[8385,6812],[8429,6763],[8484,6768],[8507,6740],[8571,6721],[8572,6647],[8536,6648],[8499,6683],[8431,6711],[8532,6636],[8597,6606],[8561,6578],[8558,6548],[8577,6545],[8611,6494],[8586,6478],[8526,6534],[8449,6533],[8518,6510],[8580,6459],[8619,6482],[8679,6482],[8727,6396],[8724,6396],[8722,6395]],[[8558,6548],[8552,6548],[8552,6548],[8552,6548],[8484,6605],[8532,6551],[8552,6548],[8552,6548],[8552,6548],[8557,6544],[8558,6548]]],[[[8709,6392],[8713,6400],[8716,6394],[8712,6393],[8709,6392]]],[[[8765,6797],[8756,6760],[8761,6796],[8765,6797]]],[[[8688,6764],[8691,6772],[8739,6789],[8726,6737],[8674,6599],[8696,6561],[8678,6528],[8652,6583],[8652,6652],[8688,6764]]]]}},{"type":"Feature","id":"US.IA","properties":{"hc-group":"admin1","hc-middle-x":0.35,"hc-middle-y":0.49,"hc-key":"us-ia","hc-a2":"IA","labelrank":"0","hasc":"US.IA","woe-id":"2347574","state-fips":"19","fips":"US19","postal-code":"IA","name":"Iowa","country":"United States of America","region":"Midwest","longitude":"-93.3891","woe-name":"Iowa","latitude":"42.0423","woe-label":"Iowa, US, United States","type":"State"},"geometry":{"type":"Polygon","coordinates":[[[5575,7508],[5625,7441],[5672,7411],[5671,7332],[5646,7276],[5579,7232],[5523,7224],[5509,7160],[5536,7132],[5535,7098],[5496,7020],[5458,7004],[5449,6947],[5449,6947],[5449,6947],[5389,7006],[5120,6985],[4846,6977],[4592,6981],[4591,6981],[4579,7031],[4571,7165],[4559,7206],[4529,7228],[4533,7291],[4515,7341],[4478,7398],[4469,7474],[4453,7479],[4423,7540],[4459,7636],[4438,7663],[4433,7734],[4459,7735],[5137,7745],[5445,7758],[5479,7702],[5465,7670],[5494,7563],[5561,7544],[5577,7513],[5575,7508],[5575,7508]]]}},{"type":"Feature","id":"US.MD","properties":{"hc-group":"admin1","hc-middle-x":0.61,"hc-middle-y":0.27,"hc-key":"us-md","hc-a2":"MD","labelrank":"0","hasc":"US.MD","woe-id":"2347579","state-fips":"24","fips":"US24","postal-code":"MD","name":"Maryland","country":"United States of America","region":"South","longitude":"-77.0454","woe-name":"Maryland","latitude":"39.3874","woe-label":"Maryland, US, United States","type":"State"},"geometry":{"type":"MultiPolygon","coordinates":[[[[8761,6796],[8769,6819],[8765,6797],[8761,6796]]],[[[8779,6915],[8779,6884],[8777,6914],[8777,6914],[8779,6915]]],[[[8739,6789],[8691,6772],[8688,6764],[8647,6746],[8650,6806],[8590,6833],[8592,6815],[8525,6862],[8581,6899],[8555,6926],[8511,6936],[8544,6974],[8512,6986],[8496,7036],[8530,7108],[8537,7165],[8497,7093],[8472,7099],[8469,7056],[8432,7052],[8471,7014],[8458,6959],[8483,6868],[8513,6820],[8462,6849],[8543,6778],[8548,6753],[8491,6782],[8433,6785],[8382,6834],[8354,6797],[8335,6827],[8370,6891],[8367,6916],[8385,6943],[8341,6945],[8251,6984],[8256,7009],[8198,7020],[8162,7087],[8101,7099],[8046,7067],[8043,7043],[8000,7038],[7977,7057],[7949,7003],[7928,7007],[7857,6922],[7835,7053],[8176,7119],[8559,7201],[8650,6887],[8771,6913],[8770,6856],[8753,6848],[8739,6789]]]]}},{"type":"Feature","id":"US.DE","properties":{"hc-group":"admin1","hc-middle-x":0.91,"hc-middle-y":0.77,"hc-key":"us-de","hc-a2":"DE","labelrank":"0","hasc":"US.DE","woe-id":"2347566","state-fips":"10","fips":"US10","postal-code":"DE","name":"Delaware","country":"United States of America","region":"South","longitude":"-75.41119999999999","woe-name":"Delaware","latitude":"38.8657","woe-label":"Delaware, US, United States","type":"State"},"geometry":{"type":"Polygon","coordinates":[[[8777,6914],[8771,6915],[8771,6913],[8650,6887],[8559,7201],[8589,7239],[8625,7239],[8601,7183],[8613,7145],[8652,7114],[8675,7051],[8735,6995],[8751,6999],[8779,6915],[8777,6914],[8777,6914]]]}},{"type":"Feature","id":"US.PA","properties":{"hc-group":"admin1","hc-middle-x":0.5,"hc-middle-y":0.49,"hc-key":"us-pa","hc-a2":"PA","labelrank":"0","hasc":"US.PA","woe-id":"2347597","state-fips":"42","fips":"US42","postal-code":"PA","name":"Pennsylvania","country":"United States of America","region":"Northeast","longitude":"-77.60939999999999","woe-name":"Pennsylvania","latitude":"40.8601","woe-label":"Pennsylvania, US, United States","type":"State"},"geometry":{"type":"Polygon","coordinates":[[[8611,7549],[8632,7530],[8615,7490],[8627,7443],[8646,7444],[8739,7361],[8691,7310],[8673,7276],[8625,7239],[8589,7239],[8559,7201],[8176,7119],[7835,7053],[7630,7017],[7589,7253],[7589,7253],[7530,7595],[7556,7610],[7662,7693],[7674,7625],[8514,7797],[8573,7765],[8588,7712],[8673,7663],[8673,7663],[8611,7549]]]}},{"type":"Feature","id":"US.NJ","properties":{"hc-group":"admin1","hc-middle-x":0.68,"hc-middle-y":0.64,"hc-key":"us-nj","hc-a2":"NJ","labelrank":"0","hasc":"US.NJ","woe-id":"2347589","state-fips":"34","fips":"US34","postal-code":"NJ","name":"New Jersey","country":"United States of America","region":"Northeast","longitude":"-74.4653","woe-name":"New Jersey","latitude":"40.0449","woe-label":"New Jersey, US, United States","type":"State"},"geometry":{"type":"Polygon","coordinates":[[[8611,7549],[8673,7663],[8759,7635],[8846,7608],[8840,7532],[8810,7504],[8805,7466],[8866,7456],[8875,7438],[8886,7281],[8853,7228],[8849,7172],[8812,7122],[8784,7047],[8766,7040],[8769,7097],[8716,7095],[8623,7151],[8610,7186],[8624,7231],[8676,7269],[8691,7310],[8739,7361],[8646,7444],[8627,7443],[8615,7490],[8632,7530],[8611,7549]]]}},{"type":"Feature","id":"US.NY","properties":{"hc-group":"admin1","hc-middle-x":0.54,"hc-middle-y":0.49,"hc-key":"us-ny","hc-a2":"NY","labelrank":"0","hasc":"US.NY","woe-id":"2347591","state-fips":"36","fips":"US36","postal-code":"NY","name":"New York","country":"United States of America","region":"Northeast","longitude":"-75.32420000000001","woe-name":"New York","latitude":"43.1988","woe-label":"New York, US, United States","type":"State"},"geometry":{"type":"Polygon","coordinates":[[[8673,7663],[8588,7712],[8573,7765],[8514,7797],[7674,7625],[7662,7693],[7763,7795],[7803,7872],[7754,7932],[7747,7976],[7812,8010],[7918,8040],[7988,8041],[8031,8026],[8061,8043],[8133,8055],[8180,8080],[8224,8141],[8264,8164],[8243,8232],[8257,8274],[8225,8259],[8202,8296],[8230,8345],[8280,8379],[8297,8437],[8358,8526],[8422,8581],[8453,8585],[8695,8646],[8720,8537],[8739,8514],[8748,8453],[8740,8402],[8772,8328],[8772,8287],[8807,8284],[8856,8080],[8853,7901],[8860,7896],[8896,7702],[8912,7685],[8874,7645],[8896,7623],[8881,7575],[8930,7617],[8982,7620],[9002,7641],[9094,7671],[9134,7722],[9173,7697],[9177,7721],[9184,7702],[9231,7730],[9141,7649],[9083,7619],[9032,7570],[8936,7519],[8857,7498],[8812,7468],[8814,7503],[8840,7506],[8858,7554],[8843,7544],[8846,7608],[8759,7635],[8695,7656],[8673,7663],[8673,7663]]]}},{"type":"Feature","id":"US.ID","properties":{"hc-group":"admin1","hc-middle-x":0.51,"hc-middle-y":0.75,"hc-key":"us-id","hc-a2":"ID","labelrank":"0","hasc":"US.ID","woe-id":"2347571","state-fips":"16","fips":"US16","postal-code":"ID","name":"Idaho","country":"United States of America","region":"West","longitude":"-114.133","woe-name":"Idaho","latitude":"43.7825","woe-label":"Idaho, US, United States","type":"State"},"geometry":{"type":"Polygon","coordinates":[[[926,9593],[1093,9555],[1036,9301],[1076,9210],[1061,9142],[1117,9085],[1172,8979],[1170,8959],[1219,8896],[1258,8897],[1253,8859],[1219,8796],[1204,8727],[1211,8698],[1177,8675],[1167,8620],[1200,8590],[1278,8630],[1303,8596],[1303,8522],[1338,8434],[1326,8419],[1347,8377],[1374,8375],[1391,8331],[1392,8280],[1415,8254],[1451,8281],[1508,8261],[1536,8282],[1614,8258],[1671,8261],[1686,8296],[1713,8295],[1750,8226],[1677,7785],[1643,7585],[1393,7629],[1073,7690],[897,7727],[510,7813],[616,8265],[662,8361],[615,8403],[624,8450],[718,8545],[776,8646],[823,8698],[821,8744],[785,8775],[774,8822],[779,8870],[767,8925],[926,9593]]]}},{"type":"Feature","id":"US.SD","properties":{"hc-group":"admin1","hc-middle-x":0.51,"hc-middle-y":0.44,"hc-key":"us-sd","hc-a2":"SD","labelrank":"0","hasc":"US.SD","woe-id":"2347600","state-fips":"46","fips":"US46","postal-code":"SD","name":"South Dakota","country":"United States of America","region":"Midwest","longitude":"-100.255","woe-name":"South Dakota","latitude":"44.4711","woe-label":"South Dakota, US, United States","type":"State"},"geometry":{"type":"Polygon","coordinates":[[[3010,7672],[3019,7770],[3056,8191],[3059,8191],[3080,8436],[4231,8374],[4444,8372],[4429,8325],[4387,8283],[4419,8232],[4462,8203],[4459,7735],[4433,7734],[4438,7663],[4459,7636],[4423,7540],[4453,7479],[4409,7521],[4330,7551],[4297,7577],[4194,7574],[4148,7558],[4071,7611],[3010,7672]]]}},{"type":"Feature","id":"US.CT","properties":{"hc-group":"admin1","hc-middle-x":0.48,"hc-middle-y":0.5,"hc-key":"us-ct","hc-a2":"CT","labelrank":"0","hasc":"US.CT","woe-id":"2347565","state-fips":"9","fips":"US09","postal-code":"CT","name":"Connecticut","country":"United States of America","region":"Northeast","longitude":"-72.7594","woe-name":"Connecticut","latitude":"41.6486","woe-label":"Connecticut, US, United States","type":"State"},"geometry":{"type":"Polygon","coordinates":[[[9216,7790],[9204,7796],[9095,7743],[9023,7721],[8972,7689],[8896,7623],[8874,7645],[8912,7685],[8896,7702],[8860,7896],[8997,7925],[9177,7968],[9212,7845],[9216,7790]]]}},{"type":"Feature","id":"US.NH","properties":{"hc-group":"admin1","hc-middle-x":0.38,"hc-middle-y":0.57,"hc-key":"us-nh","hc-a2":"NH","labelrank":"0","hasc":"US.NH","woe-id":"2347588","state-fips":"33","fips":"US33","postal-code":"NH","name":"New Hampshire","country":"United States of America","region":"Northeast","longitude":"-71.6301","woe-name":"New Hampshire","latitude":"43.5993","woe-label":"New Hampshire, US, United States","type":"State"},"geometry":{"type":"Polygon","coordinates":[[[9298,8291],[9306,8288],[9300,8236],[9242,8201],[9222,8166],[9005,8115],[9005,8115],[8979,8148],[8979,8261],[8964,8320],[8981,8392],[8986,8490],[8978,8526],[9033,8585],[9045,8629],[9020,8661],[9024,8736],[9036,8814],[9079,8830],[9225,8399],[9235,8354],[9298,8291]]]}},{"type":"Feature","id":"US.KY","properties":{"hc-group":"admin1","hc-middle-x":0.65,"hc-middle-y":0.5,"hc-key":"us-ky","hc-a2":"KY","labelrank":"0","hasc":"US.KY","woe-id":"2347576","state-fips":"21","fips":"US21","postal-code":"KY","name":"Kentucky","country":"United States of America","region":"South","longitude":"-85.5729","woe-name":"Kentucky","latitude":"37.3994","woe-label":"Kentucky, US, United States","type":"State"},"geometry":{"type":"MultiPolygon","coordinates":[[[[5893,5966],[5890,5980],[5907,5967],[5893,5966]]],[[[5921,5968],[5932,6005],[5956,5988],[5976,6033],[5975,6097],[5962,6117],[5987,6157],[6015,6162],[6105,6131],[6102,6218],[6171,6241],[6159,6283],[6179,6328],[6209,6363],[6269,6350],[6303,6376],[6359,6356],[6426,6401],[6444,6379],[6485,6390],[6485,6413],[6531,6450],[6583,6411],[6608,6438],[6622,6498],[6652,6507],[6657,6540],[6693,6572],[6682,6619],[6737,6617],[6808,6651],[6792,6683],[6797,6730],[6873,6741],[6900,6725],[6933,6672],[7001,6669],[7036,6641],[7069,6664],[7119,6643],[7198,6692],[7216,6653],[7270,6617],[7270,6617],[7270,6617],[7272,6548],[7358,6439],[7431,6411],[7363,6332],[7309,6294],[7268,6217],[7221,6173],[7116,6120],[7104,6113],[6814,6086],[6751,6077],[6516,6061],[6250,6032],[6200,6040],[6210,5991],[5921,5968]]],[[[7270,6617],[7271,6617],[7270,6617],[7270,6617],[7270,6617],[7270,6617]]]]}},{"type":"Feature","id":"US.OH","properties":{"hc-group":"admin1","hc-middle-x":0.45,"hc-middle-y":0.53,"hc-key":"us-oh","hc-a2":"OH","labelrank":"0","hasc":"US.OH","woe-id":"2347594","state-fips":"39","fips":"US39","postal-code":"OH","name":"Ohio","country":"United States of America","region":"Midwest","longitude":"-82.67189999999999","woe-name":"Ohio","latitude":"40.0924","woe-label":"Ohio, US, United States","type":"State"},"geometry":{"type":"Polygon","coordinates":[[[6718,7400],[6815,7415],[6976,7443],[7095,7408],[7082,7394],[7173,7383],[7258,7426],[7329,7440],[7383,7503],[7530,7595],[7589,7253],[7561,7233],[7587,7158],[7558,7018],[7564,6981],[7504,6911],[7454,6903],[7419,6863],[7399,6809],[7416,6775],[7391,6755],[7354,6783],[7333,6723],[7346,6679],[7321,6631],[7271,6617],[7270,6617],[7216,6653],[7198,6692],[7119,6643],[7069,6664],[7036,6641],[7001,6669],[6933,6672],[6900,6725],[6873,6741],[6797,6730],[6732,7296],[6718,7400]]]}},{"type":"Feature","id":"US.TN","properties":{"hc-group":"admin1","hc-middle-x":0.43,"hc-middle-y":0.54,"hc-key":"us-tn","hc-a2":"TN","labelrank":"0","hasc":"US.TN","woe-id":"2347601","state-fips":"47","fips":"US47","postal-code":"TN","name":"Tennessee","country":"United States of America","region":"South","longitude":"-86.3415","woe-name":"Tennessee","latitude":"35.7514","woe-label":"Tennessee, US, United States","type":"State"},"geometry":{"type":"Polygon","coordinates":[[[6215,5600],[6122,5592],[5762,5567],[5802,5602],[5798,5670],[5835,5714],[5827,5763],[5871,5791],[5868,5834],[5888,5872],[5869,5898],[5901,5936],[5893,5966],[5907,5967],[5911,5955],[5921,5968],[6210,5991],[6200,6040],[6250,6032],[6516,6061],[6751,6077],[6814,6086],[7104,6113],[7116,6120],[7472,6170],[7532,6183],[7523,6123],[7490,6093],[7464,6038],[7437,6050],[7365,5989],[7352,6010],[7298,5973],[7269,5928],[7188,5859],[7131,5847],[7085,5807],[7073,5762],[7038,5756],[7034,5685],[6918,5671],[6762,5652],[6213,5603],[6215,5600]]]}},{"type":"Feature","id":"US.WV","properties":{"hc-group":"admin1","hc-middle-x":0.35,"hc-middle-y":0.56,"hc-key":"us-wv","hc-a2":"WV","labelrank":"0","hasc":"US.WV","woe-id":"2347607","state-fips":"54","fips":"US54","postal-code":"WV","name":"West Virginia","country":"United States of America","region":"South","longitude":"-80.7128","woe-name":"West Virginia","latitude":"38.6422","woe-label":"West Virginia, US, United States","type":"State"},"geometry":{"type":"Polygon","coordinates":[[[7270,6617],[7271,6617],[7321,6631],[7346,6679],[7333,6723],[7354,6783],[7391,6755],[7416,6775],[7399,6809],[7419,6863],[7454,6903],[7504,6911],[7564,6981],[7558,7018],[7587,7158],[7561,7233],[7589,7253],[7630,7017],[7835,7053],[7857,6922],[7928,7007],[7949,7003],[7977,7057],[8000,7038],[8043,7043],[8046,7067],[8101,7099],[8162,7087],[8198,7020],[8188,6969],[8076,7028],[8072,6952],[8048,6900],[7998,6837],[7974,6848],[7932,6729],[7857,6759],[7840,6674],[7767,6505],[7773,6459],[7690,6412],[7664,6419],[7649,6382],[7595,6360],[7567,6378],[7530,6341],[7470,6351],[7431,6411],[7358,6439],[7272,6548],[7270,6617],[7270,6617],[7270,6617],[7270,6617],[7270,6617]]]}},{"type":"Feature","id":"US.DC","properties":{"hc-group":"admin1","hc-middle-x":0.57,"hc-middle-y":0.14,"hc-key":"us-dc","hc-a2":"DC","labelrank":"9","hasc":"US.DC","woe-id":"2347567","state-fips":"11","fips":"US11","postal-code":"DC","name":"District of Columbia","country":"United States of America","region":"South","longitude":"-77.01130000000001","woe-name":"District of Columbia","latitude":"38.8922","woe-label":"District of Columbia, US, United States","type":"Federal District"},"geometry":{"type":"Polygon","coordinates":[[[8367,6916],[8366,6929],[8353,6939],[8347,6939],[8341,6945],[8385,6943],[8367,6916]]]}},{"type":"Feature","id":"US.LA","properties":{"hc-group":"admin1","hc-middle-x":0.34,"hc-middle-y":0.46,"hc-key":"us-la","hc-a2":"LA","labelrank":"0","hasc":"US.LA","woe-id":"2347577","state-fips":"22","fips":"US22","postal-code":"LA","name":"Louisiana","country":"United States of America","region":"South","longitude":"-91.9991","woe-name":"Louisiana","latitude":"30.5274","woe-label":"Louisiana, US, United States","type":"State"},"geometry":{"type":"Polygon","coordinates":[[[6017,4328],[5915,4340],[5856,4368],[5812,4302],[5834,4283],[5904,4280],[5937,4313],[5992,4313],[5957,4259],[6001,4245],[6035,4298],[6067,4259],[5982,4181],[6027,4123],[6107,4114],[6148,4081],[6125,4035],[6070,4042],[6042,4077],[5966,4094],[5980,4115],[5902,4141],[5913,4064],[5876,4028],[5860,4066],[5811,4082],[5780,4036],[5724,4031],[5620,4068],[5631,4121],[5569,4128],[5532,4184],[5493,4173],[5494,4203],[5430,4175],[5437,4145],[5478,4154],[5526,4139],[5500,4112],[5431,4136],[5399,4121],[5305,4135],[5186,4176],[5128,4173],[5042,4153],[5047,4228],[5065,4253],[5059,4380],[5093,4447],[5105,4506],[5031,4646],[5033,4679],[4980,4752],[4975,5016],[5563,5038],[5605,5041],[5627,5018],[5611,4977],[5629,4895],[5670,4868],[5636,4781],[5584,4738],[5565,4662],[5545,4642],[5545,4585],[5522,4581],[5540,4526],[5523,4510],[5955,4536],[5936,4451],[6017,4328]]]}},{"type":"Feature","id":"US.FL","properties":{"hc-group":"admin1","hc-middle-x":0.77,"hc-middle-y":0.5,"hc-key":"us-fl","hc-a2":"FL","labelrank":"0","hasc":"US.FL","woe-id":"2347568","state-fips":"12","fips":"US12","postal-code":"FL","name":"Florida","country":"United States of America","region":"South","longitude":"-81.6228","woe-name":"Florida","latitude":"28.1568","woe-label":"Florida, US, United States","type":"State"},"geometry":{"type":"Polygon","coordinates":[[[6487,4443],[6487,4486],[6431,4541],[6436,4574],[7015,4637],[7055,4568],[7649,4609],[7670,4559],[7699,4566],[7687,4660],[7713,4686],[7808,4673],[7822,4672],[7849,4570],[7908,4430],[8008,4269],[8125,4130],[8113,4109],[8144,4012],[8198,3936],[8297,3758],[8321,3651],[8331,3476],[8302,3361],[8313,3273],[8270,3209],[8291,3273],[8273,3290],[8230,3255],[8194,3260],[8141,3234],[8115,3258],[8115,3303],[8070,3379],[7979,3429],[7953,3420],[7907,3543],[7846,3536],[7839,3654],[7796,3674],[7819,3634],[7779,3640],[7675,3779],[7722,3884],[7712,3915],[7671,3899],[7670,3851],[7622,3872],[7618,3966],[7635,4045],[7626,4157],[7576,4229],[7525,4222],[7473,4277],[7425,4302],[7349,4395],[7265,4433],[7186,4403],[7198,4370],[7162,4370],[7148,4336],[7067,4277],[6979,4284],[6986,4316],[6958,4349],[6892,4391],[6798,4429],[6694,4444],[6468,4388],[6505,4431],[6487,4443]]]}},{"type":"Feature","id":"US.GA","properties":{"hc-group":"admin1","hc-middle-x":0.43,"hc-middle-y":0.52,"hc-key":"us-ga","hc-a2":"GA","labelrank":"0","hasc":"US.GA","woe-id":"2347569","state-fips":"13","fips":"US13","postal-code":"GA","name":"Georgia","country":"United States of America","region":"South","longitude":"-83.4078","woe-name":"Georgia","latitude":"32.8547","woe-label":"Georgia, US, United States","type":"State"},"geometry":{"type":"Polygon","coordinates":[[[7713,4686],[7687,4660],[7699,4566],[7670,4559],[7649,4609],[7055,4568],[7015,4637],[6983,4704],[6990,4774],[6958,4846],[6970,4930],[6998,4970],[6947,5053],[6912,5135],[6762,5652],[6918,5671],[7034,5685],[7210,5711],[7290,5724],[7249,5641],[7323,5596],[7364,5593],[7401,5526],[7444,5475],[7523,5430],[7538,5402],[7600,5369],[7606,5340],[7651,5293],[7708,5272],[7750,5169],[7800,5140],[7844,5042],[7887,5035],[7901,5029],[7811,4893],[7836,4826],[7798,4798],[7817,4730],[7808,4673],[7713,4686]]]}},{"type":"Feature","id":"US.SC","properties":{"hc-group":"admin1","hc-middle-x":0.54,"hc-middle-y":0.35,"hc-key":"us-sc","hc-a2":"SC","labelrank":"0","hasc":"US.SC","woe-id":"2347599","state-fips":"45","fips":"US45","postal-code":"SC","name":"South Carolina","country":"United States of America","region":"South","longitude":"-80.6471","woe-name":"South Carolina","latitude":"33.8578","woe-label":"South Carolina, US, United States","type":"State"},"geometry":{"type":"Polygon","coordinates":[[[8302,5600],[8236,5523],[8205,5458],[8206,5396],[8173,5348],[8140,5346],[8131,5311],[8056,5219],[7989,5173],[7913,5166],[7971,5149],[7887,5035],[7844,5042],[7800,5140],[7750,5169],[7708,5272],[7651,5293],[7606,5340],[7600,5369],[7538,5402],[7523,5430],[7444,5475],[7401,5526],[7364,5593],[7323,5596],[7249,5641],[7290,5724],[7457,5802],[7714,5830],[7782,5790],[7791,5756],[8029,5790],[8302,5600]]]}},{"type":"Feature","id":"US.MN","properties":{"hc-group":"admin1","hc-middle-x":0.38,"hc-middle-y":0.6,"hc-key":"us-mn","hc-a2":"MN","labelrank":"0","hasc":"US.MN","woe-id":"2347582","state-fips":"27","fips":"US27","postal-code":"MN","name":"Minnesota","country":"United States of America","region":"Midwest","longitude":"-93.364","woe-name":"Minnesota","latitude":"46.0592","woe-label":"Minnesota, US, United States","type":"State"},"geometry":{"type":"Polygon","coordinates":[[[4333,9174],[4688,9173],[4690,9272],[4748,9253],[4770,9125],[4791,9104],[4854,9085],[4916,9083],[4938,9052],[4984,9060],[5024,9084],[5073,9082],[5132,9063],[5181,8985],[5194,9006],[5240,9014],[5304,8955],[5351,8941],[5438,8996],[5463,8964],[5570,8974],[5607,8949],[5668,8950],[5592,8895],[5514,8864],[5432,8802],[5349,8700],[5245,8603],[5214,8573],[5220,8422],[5147,8375],[5116,8322],[5117,8285],[5158,8253],[5144,8214],[5146,8117],[5136,8072],[5181,8035],[5217,8029],[5273,7994],[5360,7903],[5405,7892],[5431,7866],[5445,7758],[5137,7745],[4459,7735],[4462,8203],[4419,8232],[4387,8283],[4429,8325],[4444,8372],[4436,8472],[4402,8555],[4409,8628],[4397,8650],[4394,8777],[4347,8957],[4343,9053],[4353,9083],[4333,9174]]]}},{"type":"Feature","id":"US.MT","properties":{"hc-group":"admin1","hc-middle-x":0.55,"hc-middle-y":0.53,"hc-key":"us-mt","hc-a2":"MT","labelrank":"0","hasc":"US.MT","woe-id":"2347585","state-fips":"30","fips":"US30","postal-code":"MT","name":"Montana","country":"United States of America","region":"West","longitude":"-110.044","woe-name":"Montana","latitude":"46.9965","woe-label":"Montana, US, United States","type":"State"},"geometry":{"type":"Polygon","coordinates":[[[1093,9555],[1689,9433],[3150,9234],[3084,8486],[3080,8436],[3059,8191],[3056,8191],[1772,8355],[1750,8226],[1713,8295],[1686,8296],[1671,8261],[1614,8258],[1536,8282],[1508,8261],[1451,8281],[1415,8254],[1392,8280],[1391,8331],[1374,8375],[1347,8377],[1326,8419],[1338,8434],[1303,8522],[1303,8596],[1278,8630],[1200,8590],[1167,8620],[1177,8675],[1211,8698],[1204,8727],[1219,8796],[1253,8859],[1258,8897],[1219,8896],[1170,8959],[1172,8979],[1117,9085],[1061,9142],[1076,9210],[1036,9301],[1093,9555]]]}},{"type":"Feature","id":"US.ND","properties":{"hc-group":"admin1","hc-middle-x":0.47,"hc-middle-y":0.5,"hc-key":"us-nd","hc-a2":"ND","labelrank":"0","hasc":"US.ND","woe-id":"2347593","state-fips":"38","fips":"US38","postal-code":"ND","name":"North Dakota","country":"United States of America","region":"Midwest","longitude":"-100.302","woe-name":"North Dakota","latitude":"47.4675","woe-label":"North Dakota, US, United States","type":"State"},"geometry":{"type":"Polygon","coordinates":[[[3080,8436],[3084,8486],[3150,9234],[3468,9209],[4333,9174],[4353,9083],[4343,9053],[4347,8957],[4394,8777],[4397,8650],[4409,8628],[4402,8555],[4436,8472],[4444,8372],[4231,8374],[3080,8436]]]}},{"type":"Feature","id":"US.AZ","properties":{"hc-group":"admin1","hc-middle-x":0.51,"hc-middle-y":0.45,"hc-key":"us-az","hc-a2":"AZ","labelrank":"0","hasc":"US.AZ","woe-id":"2347561","state-fips":"4","fips":"US04","postal-code":"AZ","name":"Arizona","country":"United States of America","region":"West","longitude":"-111.935","woe-name":"Arizona","latitude":"34.3046","woe-label":"Arizona, US, United States","type":"State"},"geometry":{"type":"Polygon","coordinates":[[[1630,4782],[1196,4850],[1092,4906],[418,5307],[451,5357],[492,5355],[519,5416],[476,5452],[489,5536],[510,5537],[555,5605],[559,5661],[598,5702],[660,5730],[620,5788],[593,5936],[614,5982],[611,6068],[631,6159],[631,6217],[669,6227],[752,6180],[777,6221],[818,6420],[1488,6297],[1841,6242],[1736,5514],[1630,4782]]]}},{"type":"Feature","id":"US.UT","properties":{"hc-group":"admin1","hc-middle-x":0.52,"hc-middle-y":0.59,"hc-key":"us-ut","hc-a2":"UT","labelrank":"0","hasc":"US.UT","woe-id":"2347603","state-fips":"49","fips":"US49","postal-code":"UT","name":"Utah","country":"United States of America","region":"West","longitude":"-111.544","woe-name":"Utah","latitude":"39.5007","woe-label":"Utah, US, United States","type":"State"},"geometry":{"type":"Polygon","coordinates":[[[1841,6242],[1488,6297],[818,6420],[929,6975],[1073,7690],[1393,7629],[1643,7585],[1600,7329],[1990,7269],[1966,7108],[1841,6242]]]}},{"type":"Feature","id":"US.HI","properties":{"hc-group":"admin1","hc-middle-x":0.87,"hc-middle-y":0.79,"hc-key":"us-hi","hc-a2":"HI","labelrank":"0","hasc":"US.HI","woe-id":"2347570","state-fips":"15","fips":"US15","postal-code":"HI","name":"Hawaii","country":"United States of America","region":"West","longitude":"-157.999","woe-name":"Hawaii","latitude":"21.4919","woe-label":"Hawaii, US, United States","type":"State"},"geometry":{"type":"MultiPolygon","coordinates":[[[[2871.1,2945.9],[2875.2,2942.7],[2879.9,2943.9],[2887,2943.5],[2908.4,2936],[2926.2,2927],[2959.3,2906.2],[2969.8,2895.8],[2975.6,2888.1],[2975.6,2868.8],[2976.2,2860.2],[2981.8,2860.4],[2989.5,2864.1],[2995.3,2860.2],[2998,2855.8],[2997.4,2846.7],[3000.1,2841.1],[3003.5,2836],[3013.7,2826.7],[3024.4,2822.1],[3028.7,2818.5],[3031,2814.1],[3030.4,2808.4],[3019,2794.3],[3010.1,2790.9],[2997.5,2778.6],[2988.9,2776],[2988.6,2773.6],[2981.4,2771.8],[2975.3,2767.2],[2953.3,2760.6],[2944.8,2762.6],[2939.9,2762.7],[2935.5,2761.3],[2924.6,2753.9],[2920.9,2749.4],[2913.7,2747.3],[2906.4,2742.2],[2896.2,2736.4],[2893.2,2735.4],[2884.5,2727],[2883,2723.6],[2883.3,2715.9],[2873.3,2705.7],[2870.1,2696.8],[2867.2,2693.6],[2858.8,2686.4],[2857,2687.4],[2857.1,2692],[2852.9,2695.4],[2844.7,2699.6],[2830,2708.8],[2817.8,2712.1],[2815.1,2719.8],[2812.5,2720.6],[2810.9,2726.2],[2809.3,2735.1],[2811.5,2745.8],[2816,2776.4],[2815.6,2781.7],[2812.9,2786.6],[2805.6,2807.3],[2801.6,2814.3],[2802.1,2818.9],[2799.7,2823.2],[2796.3,2833.9],[2792.8,2839.1],[2789.8,2841.4],[2785.4,2846.6],[2780.6,2859.9],[2784.8,2870.8],[2795.1,2879.5],[2796.2,2883.5],[2799,2885.8],[2807.4,2888.9],[2813.4,2898.4],[2817.9,2906.3],[2822.3,2911.4],[2825.4,2911.5],[2827.7,2920.9],[2826.3,2924.9],[2822.9,2928.1],[2815.9,2938.7],[2813,2947.9],[2812.4,2962.2],[2816.2,2969.6],[2818.8,2972],[2826,2972],[2844.7,2968],[2850,2958],[2857.7,2955],[2862.8,2952.2],[2866.3,2948],[2871.1,2945.9]]],[[[2685.2,3028],[2683.1,3024.1],[2677.4,3024.1],[2672.1,3025],[2662.7,3023],[2656.2,3022.3],[2651.9,3026.6],[2654.3,3029.7],[2658.6,3033.4],[2670.2,3040.4],[2675.5,3042.3],[2679.6,3041.9],[2684.7,3036.2],[2682.1,3030],[2685.2,3028]]],[[[2609.3,3070.6],[2599.6,3070.1],[2595.6,3075.8],[2594.6,3080.7],[2594.3,3089.5],[2593.6,3094],[2590.2,3096],[2581.9,3099.3],[2579.4,3103.3],[2581,3107.7],[2585.7,3110.1],[2594,3111.1],[2613.5,3108.3],[2622.3,3100.4],[2628.7,3093.1],[2631.3,3086.9],[2630,3083.4],[2625.7,3076.7],[2616.7,3072.6],[2609.3,3070.6]]],[[[2673.9,3132.2],[2675.6,3130.2],[2683.4,3127.1],[2684.3,3124.4],[2686.7,3123.7],[2687.2,3118.4],[2690,3115.9],[2695.5,3106.3],[2699,3106.6],[2701.3,3109.2],[2705.1,3109.1],[2716.1,3110.5],[2722.5,3115.1],[2725.7,3116.2],[2732.1,3116.5],[2743.2,3114.2],[2746.4,3112.2],[2747.4,3109.8],[2752.3,3104.5],[2758.6,3099.6],[2758.8,3097.7],[2762.9,3098.7],[2765.5,3096.6],[2767.9,3092.2],[2774.8,3091.2],[2781.6,3088],[2791.4,3084.8],[2795.9,3075.7],[2794.9,3067.4],[2791.3,3060.7],[2786.3,3059.3],[2782.2,3053.3],[2776.8,3053.2],[2766,3047.7],[2754.9,3048.2],[2751.2,3048],[2731.5,3038.5],[2721.5,3040.8],[2718.9,3040.1],[2710.5,3039.7],[2704.9,3044.9],[2701.6,3049.9],[2703.3,3051.3],[2703.4,3055.1],[2701.8,3068.9],[2700.2,3072.7],[2700.3,3077],[2699,3080.5],[2694.8,3083.7],[2688.7,3082.3],[2687.7,3079.4],[2685.2,3078.9],[2679.4,3082.6],[2675,3083.4],[2670.7,3086.1],[2667.9,3085.8],[2660.5,3094.3],[2655,3101.5],[2654.7,3106.1],[2652.7,3108.6],[2654.7,3118.8],[2656.5,3123.8],[2658.6,3127.1],[2661.1,3127.3],[2664.7,3132],[2668.7,3131.6],[2672.3,3133.2],[2673.9,3132.2]]],[[[2542.4,3172.8],[2550.3,3172.5],[2552.8,3171.9],[2554.4,3169.4],[2557.4,3169.4],[2586.4,3165],[2594.1,3164.7],[2596.9,3170.6],[2598.9,3171.1],[2601.5,3167.6],[2602.5,3163.6],[2612.6,3161],[2622.6,3161.3],[2627,3161.9],[2631.9,3163.6],[2637.2,3163.5],[2642.1,3162.2],[2644.1,3162.6],[2646.1,3160.1],[2650.7,3159.2],[2646.9,3152.3],[2640.8,3146.4],[2633.3,3142.2],[2625.8,3139.1],[2618.1,3137.5],[2610.3,3138.3],[2602.5,3139.8],[2587.1,3143.9],[2577.6,3147.2],[2554.7,3145.6],[2547.6,3144.5],[2537.6,3144.7],[2533.7,3146.2],[2531.4,3149.3],[2531.3,3153.2],[2535.1,3159.1],[2538.7,3160.4],[2541.9,3164.2],[2542.9,3168.2],[2540.2,3172.9],[2542.4,3172.8]]],[[[2414.1,3252.1],[2415.3,3248.5],[2417.5,3247.3],[2418.6,3243.6],[2422.1,3243.3],[2425.5,3238.6],[2425.5,3233.8],[2422.8,3232.6],[2424.3,3223.3],[2428.6,3221.7],[2432,3216.6],[2435,3215.5],[2437.4,3213.2],[2440.6,3217.4],[2437.6,3219.4],[2437.9,3221.8],[2440.1,3222.8],[2448,3221.2],[2445.1,3218.3],[2444.8,3211.6],[2448.1,3209.6],[2451.4,3205.2],[2450.5,3202.8],[2453.3,3197.1],[2461.8,3192],[2463,3190.8],[2453.8,3181.6],[2451.7,3180.9],[2451.1,3184.2],[2449.4,3185.6],[2439.8,3183.8],[2433.5,3180],[2429,3180.6],[2426.4,3184.7],[2416.6,3189.1],[2413.7,3194.2],[2413.7,3196.2],[2409.6,3193],[2411.6,3190.7],[2403.3,3190.2],[2404.6,3191.8],[2399.9,3193],[2399.1,3199.7],[2405.5,3202.8],[2406.3,3204.6],[2400.6,3208.2],[2398.9,3204.7],[2394.5,3208.7],[2395.9,3202.7],[2394.8,3202],[2388.7,3207.1],[2390.1,3203.7],[2397.6,3196.7],[2396.6,3193.5],[2393,3192],[2373.9,3188.4],[2369.7,3190.8],[2368,3197.9],[2365.9,3203.5],[2361.4,3209.6],[2357.7,3211.5],[2356.8,3217.1],[2355.5,3220.1],[2349.9,3224.5],[2347.5,3228.2],[2347.2,3238.6],[2345.9,3240.5],[2337.4,3247.6],[2345.9,3249.6],[2354.3,3250],[2368.8,3249.7],[2370.5,3253.5],[2374.1,3255.5],[2379.9,3260.1],[2379.6,3261.3],[2382.9,3267.5],[2390.2,3273.8],[2396.5,3275.6],[2400.5,3274.5],[2406.2,3268.8],[2409.8,3262],[2408.9,3258.2],[2414.1,3252.1]]],[[[1955.8,3294.7],[1953.2,3293.9],[1948.4,3296.6],[1946,3304.1],[1946.6,3308.8],[1948.8,3313.7],[1956.7,3321.5],[1963,3326.1],[1971.1,3330.6],[1973.3,3335.9],[1973.1,3339.8],[1976.7,3341.3],[1980.1,3341.2],[1983.8,3339.7],[1985.5,3336],[1981.3,3331.1],[1979.8,3326.6],[1981.2,3321],[1978.5,3317.4],[1972.1,3314.3],[1968.3,3313.2],[1961.2,3308.2],[1959.7,3305],[1955.8,3294.7]]],[[[2117.8,3386.1],[2120.7,3384.6],[2123.8,3384.8],[2127.6,3382.7],[2129.1,3379.5],[2132.9,3376.7],[2134.9,3369.7],[2136.6,3368.7],[2136.1,3360.5],[2134.2,3358],[2131.3,3350.1],[2128.4,3348.5],[2128,3342.6],[2128.8,3334.9],[2128,3329.3],[2123,3328.3],[2125.2,3324.9],[2121.7,3323.7],[2118.3,3320.9],[2116.9,3318.4],[2109.4,3313],[2107.3,3310.8],[2098.5,3314],[2089,3314.5],[2078.6,3316.4],[2076.9,3318],[2074,3315.9],[2073.1,3317.6],[2068.2,3320.6],[2065.1,3326.1],[2062.8,3326.7],[2060,3329.4],[2056.1,3330],[2050.6,3332.5],[2043.4,3334.4],[2041.2,3340.1],[2038.1,3343],[2038.3,3352.8],[2040.3,3353.5],[2048.5,3363],[2049.2,3368.3],[2052.4,3371.8],[2062.1,3374.2],[2067.8,3377.5],[2071.4,3380.6],[2076.1,3382.7],[2077.8,3384.8],[2086,3386.8],[2088.1,3384.2],[2095.7,3382.1],[2095.7,3385.2],[2099.3,3386.6],[2107.5,3385.9],[2111.6,3384.7],[2115.5,3387.5],[2117.8,3386.1]]]]}},{"type":"Feature","id":"US.AK","properties":{"hc-group":"admin1","hc-middle-x":0.53,"hc-middle-y":0.33,"hc-key":"us-ak","hc-a2":"AK","labelrank":"0","hasc":"US.AK","woe-id":"2347560","state-fips":"2","fips":"US02","postal-code":"AK","name":"Alaska","country":"United States of America","region":"West","longitude":"-151.604","woe-name":"Alaska","latitude":"65.3609","woe-label":"Alaska, US, United States","type":"State"},"geometry":{"type":"MultiPolygon","coordinates":[[[[322,4275],[321,4280],[339,4292],[360,4283],[392,4281],[424,4297],[443,4318],[478,4297],[476,4285],[459,4279],[461,4263],[472,4263],[490,4288],[507,4272],[503,4256],[519,4248],[528,4258],[548,4257],[582,4240],[564,4217],[594,4212],[584,4202],[611,4198],[655,4200],[684,4194],[704,4174],[712,4178],[723,4165],[746,4156],[788,4155],[808,4136],[832,4134],[851,4144],[877,4147],[901,4136],[913,4120],[929,4117],[943,4100],[957,4101],[989,3159],[1039,3148],[1057,3163],[1084,3166],[1081,3138],[1107,3121],[1113,3108],[1167,3060],[1180,3028],[1208,3055],[1220,3056],[1229,3102],[1271,3127],[1297,3104],[1295,3091],[1335,3059],[1347,3039],[1367,3031],[1397,3002],[1477,2890],[1491,2875],[1490,2858],[1504,2853],[1511,2833],[1523,2836],[1613,2802],[1622,2783],[1617,2766],[1636,2722],[1622,2680],[1606,2663],[1592,2664],[1577,2702],[1585,2718],[1577,2755],[1555,2778],[1526,2764],[1520,2723],[1499,2746],[1510,2753],[1513,2796],[1473,2829],[1468,2844],[1424,2880],[1406,2878],[1414,2903],[1397,2917],[1390,2938],[1366,2963],[1364,2998],[1355,2976],[1348,2979],[1354,2974],[1334,2977],[1331,2984],[1344,2982],[1324,2991],[1283,3075],[1286,3041],[1310,2985],[1307,2971],[1288,2985],[1264,2982],[1266,2998],[1249,3031],[1245,3018],[1199,3046],[1202,3028],[1224,3026],[1254,2995],[1255,2977],[1229,2976],[1225,2963],[1169,2999],[1134,3041],[1085,3062],[1050,3083],[1069,3102],[1060,3119],[1025,3098],[969,3113],[977,3128],[953,3122],[899,3136],[842,3125],[826,3141],[792,3157],[802,3194],[788,3179],[783,3158],[761,3173],[742,3174],[759,3196],[727,3195],[706,3205],[716,3212],[705,3227],[679,3222],[658,3229],[636,3221],[637,3247],[620,3199],[631,3213],[642,3184],[628,3167],[614,3132],[576,3140],[552,3130],[545,3108],[537,3114],[509,3089],[521,3115],[493,3078],[478,3071],[455,3077],[433,3070],[426,3086],[455,3099],[483,3126],[457,3115],[438,3133],[464,3170],[478,3204],[473,3223],[491,3228],[524,3249],[543,3235],[554,3240],[588,3228],[544,3260],[549,3268],[527,3271],[524,3284],[490,3256],[469,3252],[424,3205],[428,3196],[407,3182],[408,3170],[377,3133],[343,3131],[339,3114],[317,3109],[309,3075],[334,3075],[352,3048],[305,3020],[308,3008],[287,2998],[271,2977],[246,2981],[222,2955],[212,2964],[200,2941],[186,2947],[152,2925],[163,2924],[146,2893],[133,2901],[107,2879],[96,2891],[89,2869],[73,2877],[24,2852],[40,2842],[7,2817],[-44,2808],[-61,2821],[-118,2794],[-130,2803],[-155,2792],[-167,2799],[-155,2816],[-167,2823],[-200,2781],[-223,2772],[-230,2808],[-252,2775],[-262,2795],[-286,2772],[-278,2800],[-223,2823],[-171,2853],[-115,2850],[-113,2838],[-84,2825],[-99,2845],[-80,2870],[-38,2892],[12,2907],[27,2896],[31,2922],[57,2946],[97,2964],[126,3051],[154,3072],[156,3089],[95,3074],[79,3099],[90,3123],[60,3099],[61,3072],[44,3066],[28,3121],[8,3111],[-6,3123],[-7,3147],[-37,3132],[-62,3132],[-69,3120],[-112,3131],[-85,3135],[-82,3162],[-87,3191],[-63,3208],[-76,3277],[-72,3305],[-89,3269],[-149,3267],[-172,3278],[-167,3295],[-184,3332],[-198,3342],[-212,3370],[-166,3383],[-134,3368],[-125,3345],[-109,3358],[-131,3376],[-161,3385],[-185,3401],[-173,3407],[-186,3433],[-191,3419],[-205,3460],[-194,3469],[-211,3484],[-189,3485],[-198,3504],[-175,3498],[-170,3526],[-130,3555],[-118,3553],[-108,3582],[-85,3606],[-61,3612],[-46,3602],[-34,3577],[-22,3576],[7,3591],[28,3609],[31,3600],[76,3594],[100,3613],[106,3664],[92,3688],[125,3701],[117,3734],[102,3721],[73,3725],[45,3711],[20,3709],[8,3729],[-28,3742],[-59,3740],[-101,3771],[-108,3789],[-98,3804],[-111,3837],[-95,3829],[-73,3837],[-119,3868],[-138,3897],[-124,3909],[-95,3914],[-87,3908],[-68,3921],[-2,3935],[36,3937],[67,3929],[47,3893],[52,3877],[111,3858],[119,3845],[140,3868],[162,3859],[147,3882],[128,3880],[135,3893],[119,3943],[132,3945],[139,3923],[133,3914],[145,3887],[163,3891],[175,3870],[196,3867],[201,3879],[179,3900],[152,3894],[142,3915],[154,3949],[129,3950],[86,3976],[89,4000],[86,4032],[55,4092],[40,4106],[27,4135],[45,4151],[57,4180],[76,4171],[124,4160],[156,4170],[182,4190],[189,4216],[201,4233],[224,4253],[229,4246],[253,4268],[256,4258],[287,4258],[317,4277],[322,4275]],[[322,4275],[323,4272],[323,4272],[323,4272],[311,4248],[326,4263],[323,4272],[323,4272],[323,4272],[324,4274],[322,4275]]],[[[-905,2721],[-922,2724],[-904,2733],[-898,2724],[-905,2721]]],[[[-739,2715],[-724,2712],[-729,2702],[-734,2709],[-739,2715]]],[[[-645,2693],[-651,2700],[-684,2693],[-643,2725],[-634,2718],[-623,2738],[-597,2740],[-595,2719],[-626,2714],[-645,2693]]],[[[-439,2748],[-458,2742],[-469,2755],[-457,2762],[-439,2748]]],[[[-268,2722],[-267,2733],[-255,2724],[-252,2715],[-268,2722]]],[[[-303,2804],[-293,2800],[-290,2768],[-309,2757],[-338,2767],[-359,2754],[-385,2761],[-386,2779],[-369,2783],[-354,2800],[-335,2796],[-303,2804]]],[[[-59,2737],[-58,2733],[-70,2740],[-62,2746],[-59,2737]]],[[[1485,2651],[1482,2635],[1455,2672],[1458,2688],[1473,2659],[1485,2651]]],[[[1568,2687],[1567,2665],[1547,2678],[1548,2705],[1568,2687]]],[[[-81,2759],[-83,2747],[-107,2735],[-88,2750],[-81,2759]]],[[[-100,2783],[-114,2781],[-119,2759],[-135,2762],[-131,2784],[-100,2783]]],[[[1530,2716],[1542,2706],[1538,2690],[1528,2711],[1530,2716]]],[[[1427,2708],[1429,2706],[1439,2711],[1430,2683],[1427,2708]]],[[[1439,2743],[1430,2731],[1420,2735],[1421,2742],[1439,2743]]],[[[1555,2775],[1573,2753],[1578,2721],[1569,2699],[1529,2721],[1537,2731],[1531,2760],[1555,2775]]],[[[1408,2747],[1414,2765],[1435,2776],[1437,2763],[1408,2747]]],[[[1480,2788],[1503,2783],[1494,2762],[1468,2778],[1475,2803],[1480,2788]]],[[[1467,2811],[1469,2795],[1445,2798],[1451,2810],[1467,2811]]],[[[1495,2807],[1510,2793],[1504,2784],[1485,2797],[1482,2819],[1495,2807]]],[[[253,2834],[251,2826],[235,2816],[239,2829],[253,2834]]],[[[276,2825],[279,2820],[259,2824],[263,2832],[276,2825]]],[[[1448,2845],[1470,2828],[1458,2816],[1449,2816],[1448,2845]]],[[[333,2880],[345,2878],[321,2864],[319,2872],[333,2880]]],[[[1295,2870],[1295,2846],[1283,2843],[1288,2862],[1295,2870]]],[[[1246,2943],[1241,2926],[1234,2942],[1237,2951],[1246,2943]]],[[[345,2973],[360,2960],[353,2961],[333,2971],[345,2973]]],[[[370,2989],[380,3007],[393,2992],[407,2995],[413,2978],[404,2970],[365,2959],[347,2974],[353,2990],[370,2989]]],[[[389,3006],[380,3014],[397,3021],[396,3012],[389,3006]]],[[[-42,3112],[-58,3105],[-53,3120],[-31,3126],[-42,3112]]],[[[643,3141],[641,3133],[628,3129],[639,3150],[643,3141]]],[[[683,3167],[692,3162],[662,3126],[639,3113],[651,3133],[678,3156],[683,3167]]],[[[-250,3366],[-233,3350],[-243,3328],[-239,3312],[-272,3312],[-294,3323],[-315,3350],[-321,3371],[-293,3362],[-286,3369],[-250,3366]]],[[[712,3177],[732,3173],[708,3154],[714,3166],[712,3177]]],[[[655,3184],[659,3177],[651,3159],[646,3171],[655,3184]]],[[[-553,3496],[-557,3490],[-570,3515],[-566,3524],[-553,3496]]],[[[735,3177],[725,3175],[725,3181],[752,3187],[735,3177]]],[[[-478,2741],[-509,2724],[-476,2727],[-492,2716],[-574,2704],[-597,2711],[-551,2713],[-526,2758],[-501,2752],[-507,2737],[-487,2749],[-478,2741]]],[[[1452,2689],[1461,2728],[1438,2724],[1443,2751],[1435,2778],[1419,2778],[1414,2794],[1439,2796],[1449,2769],[1468,2766],[1516,2700],[1532,2652],[1522,2641],[1495,2679],[1475,2669],[1476,2693],[1452,2689]]],[[[1292,2882],[1302,2902],[1330,2883],[1354,2825],[1358,2769],[1323,2816],[1325,2832],[1311,2830],[1320,2852],[1308,2856],[1308,2872],[1292,2882]]],[[[362,2955],[355,2938],[381,2954],[386,2936],[380,2918],[395,2917],[382,2900],[349,2913],[366,2899],[363,2889],[337,2894],[303,2868],[278,2838],[275,2849],[298,2883],[281,2883],[271,2862],[256,2873],[259,2892],[247,2904],[253,2919],[284,2939],[295,2933],[298,2909],[306,2934],[302,2950],[318,2956],[321,2936],[329,2963],[348,2946],[340,2965],[362,2955]]],[[[1277,2920],[1294,2891],[1278,2884],[1270,2906],[1243,2925],[1247,2941],[1271,2972],[1321,2953],[1323,2931],[1299,2928],[1309,2919],[1325,2926],[1333,2899],[1320,2896],[1277,2920]]],[[[1355,2884],[1341,2912],[1326,2962],[1314,2989],[1331,2969],[1358,2968],[1379,2937],[1376,2926],[1357,2961],[1361,2939],[1379,2919],[1383,2888],[1350,2853],[1347,2875],[1355,2884]]],[[[-347,3767],[-339,3759],[-322,3764],[-307,3758],[-307,3734],[-290,3713],[-256,3692],[-266,3681],[-286,3692],[-315,3679],[-313,3698],[-337,3738],[-353,3750],[-371,3746],[-381,3757],[-379,3773],[-362,3796],[-362,3776],[-347,3767]]],[[[1402,2834],[1394,2792],[1400,2779],[1385,2761],[1377,2790],[1389,2804],[1373,2811],[1364,2838],[1379,2842],[1395,2828],[1402,2835],[1401,2839],[1383,2863],[1396,2866],[1441,2858],[1445,2825],[1422,2845],[1441,2817],[1439,2809],[1410,2805],[1402,2834]]]]}},{"type":"Feature","properties":{"hc-group":"__separator_lines__"},"geometry":{"type":"MultiLineString","coordinates":[[[-707,5188],[3651,2950]],[[1747,2584],[1747,3799]]]}}]'), Ah = { title: _m, version: Jm, type: Qm, copyright: t1, copyrightShort: e1, copyrightUrl: i1, crs: s1, "hc-transform": { default: { crs: "+proj=lcc +lat_1=33 +lat_2=45 +lat_0=39 +lon_0=-96 +x_0=0 +y_0=0 +datum=NAD83 +units=m +no_defs", scale: .000151481324748, jsonres: 15.5, jsonmarginX: -999, jsonmarginY: 9851, xoffset: -236135609818e-5, yoffset: 139899677886e-5 }, "us-all-hawaii": { xpan: 190, ypan: 417, hitZone: { type: "Polygon", coordinates: [[[1747, 3920], [3651, 2950], [3651, -999], [1747, -999], [1747, 3920]]] }, crs: "+proj=aea +lat_1=8 +lat_2=18 +lat_0=13 +lon_0=-157 +x_0=0 +y_0=0 +datum=NAD83 +units=m +no_defs", scale: .000123090941806, jsonres: 15.5, jsonmarginX: -999, jsonmarginY: 9851, xoffset: -338610.47557, yoffset: 102275431736e-5 }, "us-all-alaska": { rotation: -.0174532925199, xpan: 5, ypan: 357, hitZone: { type: "Polygon", coordinates: [[[-999, 5188], [-707, 5188], [1747, 3920], [1747, -999], [-999, -999], [-999, 5188]]] }, crs: "+proj=tmerc +lat_0=54 +lon_0=-142 +k=0.9999 +x_0=500000 +y_0=0 +ellps=GRS80 +towgs84=0,0,0,0,0,0,0 +units=m +no_defs", scale: 584397059179e-16, jsonres: 15.5, jsonmarginX: -999, jsonmarginY: 9851, xoffset: -156615400853e-5, yoffset: 199267114918e-5 } }, features: o1 }, r1 = Q => ({ 100: { lat: 40.7128, lon: -74.006 }, 200: { lat: 38.9072, lon: -77.0369 }, 300: { lat: 33.749, lon: -84.388 }, 400: { lat: 36.1627, lon: -86.7816 }, 600: { lat: 41.8781, lon: -87.6298 }, 700: { lat: 32.7767, lon: -96.797 }, 800: { lat: 39.7392, lon: -104.9903 }, 900: { lat: 34.0522, lon: -118.2437 } })[Q] || { lat: 39.8283, lon: -98.5795 }, a1 = Q => Q >= 1e5 ? "#22c55e" : Q >= 5e4 ? "#3b82f6" : Q >= 25e3 ? "#f59e0b" : Q >= 1e4 ? "#ef4444" : "#6b7280", n1 = Q => Q >= 1e5 ? "Very High ($100K+)" : Q >= 5e4 ? "High ($50K-$100K)" : Q >= 25e3 ? "Medium ($25K-$50K)" : Q >= 1e4 ? "Low ($10K-$25K)" : "Very Low (<$10K)"; function y1() { var Oe; const { summary: Q } = Gm(), ii = Mh.useRef(null); Mh.useEffect(() => { if (!ii.current || !(Q != null && Q.scf_data)) return; const gt = Q.scf_data.map(St => { const Ee = r1(St.scf); return { name: `SCF ${St.scf}`, lat: Ee.lat, lon: Ee.lon, z: St.current_12m.spend, color: a1(St.current_12m.spend), custom: { scf: St.scf, category: n1(St.current_12m.spend), consumers: St.current_12m.consumers, orders: St.current_12m.orders, units: St.current_12m.units, spendChange: St.percent_change.spend, consumerChange: St.percent_change.consumers } } }); qm.mapChart({ chart: { renderTo: ii.current, map: Ah, backgroundColor: "#f8fafc", height: 600 }, title: { text: "Revenue by SCF (Service Classification Facility)" }, subtitle: { text: "Customer spending by 3-digit ZIP code areas - Last 12 months" }, legend: { enabled: !1 }, mapNavigation: { enabled: !0, buttonOptions: { verticalAlign: "bottom" } }, colorAxis: { min: 0, stops: [[0, "#6b7280"], [.2, "#ef4444"], [.4, "#f59e0b"], [.7, "#3b82f6"], [1, "#22c55e"]] }, series: [{ type: "map", name: "US States", mapData: Ah, borderColor: "#9ca3af", borderWidth: 1, nullColor: "#e5e7eb" }, { type: "mappoint", name: "SCF Areas", data: gt, marker: { fillOpacity: .8, lineWidth: 2, lineColor: "#ffffff" }, tooltip: { pointFormat: "<b>SCF {point.custom.scf}</b><br/>Total Spend: <b>${point.z:,.0f}</b><br/>Customers: <b>{point.custom.consumers}</b><br/>Orders: <b>{point.custom.orders}</b><br/>Units: <b>{point.custom.units}</b><br/>Category: <b>{point.custom.category}</b><br/>{#if point.custom.spendChange}Spend Change: <b>{#if (gt point.custom.spendChange 0)}+{/if}{point.custom.spendChange}%</b><br/>{/if}{#if point.custom.consumerChange}Customer Change: <b>{#if (gt point.custom.consumerChange 0)}+{/if}{point.custom.consumerChange}%</b>{/if}" } }], credits: { enabled: !1 } }) }, [Q]); const Pt = (Q == null ? void 0 : Q.scf_data) || [], ce = Pt.filter(gt => gt.current_12m.spend >= 1e5).length, Le = Pt.filter(gt => gt.current_12m.spend >= 5e4 && gt.current_12m.spend < 1e5).length, si = Pt.filter(gt => gt.current_12m.spend >= 25e3 && gt.current_12m.spend < 5e4).length, oi = Pt.filter(gt => gt.current_12m.spend >= 1e4 && gt.current_12m.spend < 25e3).length, ri = Pt.filter(gt => gt.current_12m.spend < 1e4).length, Jt = (Oe = Q == null ? void 0 : Q.summary) == null ? void 0 : Oe.current_12m_totals; return Y.jsx(Vm, { title: "Customer Geolocation by SCF", children: Y.jsxs(Qs, { children: [Y.jsx(Qs.Section, { children: Y.jsxs("div", { style: { display: "grid", gridTemplateColumns: "repeat(auto-fit, minmax(180px, 1fr))", gap: "1rem", marginBottom: "2rem" }, children: [Y.jsx(Gt, { children: Y.jsxs("div", { style: { textAlign: "center" }, children: [Y.jsx("h3", { style: { fontSize: "2rem", color: "#22c55e" }, children: ce }), Y.jsx("p", { style: { color: "#6b7280" }, children: "Very High ($100K+)" })] }) }), Y.jsx(Gt, { children: Y.jsxs("div", { style: { textAlign: "center" }, children: [Y.jsx("h3", { style: { fontSize: "2rem", color: "#3b82f6" }, children: Le }), Y.jsx("p", { style: { color: "#6b7280" }, children: "High ($50K-$100K)" })] }) }), Y.jsx(Gt, { children: Y.jsxs("div", { style: { textAlign: "center" }, children: [Y.jsx("h3", { style: { fontSize: "2rem", color: "#f59e0b" }, children: si }), Y.jsx("p", { style: { color: "#6b7280" }, children: "Medium ($25K-$50K)" })] }) }), Y.jsx(Gt, { children: Y.jsxs("div", { style: { textAlign: "center" }, children: [Y.jsx("h3", { style: { fontSize: "2rem", color: "#ef4444" }, children: oi }), Y.jsx("p", { style: { color: "#6b7280" }, children: "Low ($10K-$25K)" })] }) }), Y.jsx(Gt, { children: Y.jsxs("div", { style: { textAlign: "center" }, children: [Y.jsx("h3", { style: { fontSize: "2rem", color: "#6b7280" }, children: ri }), Y.jsx("p", { style: { color: "#6b7280" }, children: "Very Low (<$10K)" })] }) })] }) }), Jt && Y.jsx(Qs.Section, { children: Y.jsxs("div", { style: { display: "grid", gridTemplateColumns: "repeat(auto-fit, minmax(200px, 1fr))", gap: "1rem", marginBottom: "2rem" }, children: [Y.jsx(Gt, { children: Y.jsxs("div", { style: { textAlign: "center" }, children: [Y.jsxs("h3", { style: { fontSize: "1.5rem", color: "#1f2937" }, children: ["$", Math.round(Jt.spend).toLocaleString()] }), Y.jsx("p", { style: { color: "#6b7280" }, children: "Total Revenue" })] }) }), Y.jsx(Gt, { children: Y.jsxs("div", { style: { textAlign: "center" }, children: [Y.jsx("h3", { style: { fontSize: "1.5rem", color: "#1f2937" }, children: Jt.consumers.toLocaleString() }), Y.jsx("p", { style: { color: "#6b7280" }, children: "Total Customers" })] }) }), Y.jsx(Gt, { children: Y.jsxs("div", { style: { textAlign: "center" }, children: [Y.jsx("h3", { style: { fontSize: "1.5rem", color: "#1f2937" }, children: Jt.orders.toLocaleString() }), Y.jsx("p", { style: { color: "#6b7280" }, children: "Total Orders" })] }) }), Y.jsx(Gt, { children: Y.jsxs("div", { style: { textAlign: "center" }, children: [Y.jsx("h3", { style: { fontSize: "1.5rem", color: "#1f2937" }, children: Q.summary.total_scfs }), Y.jsx("p", { style: { color: "#6b7280" }, children: "Active SCFs" })] }) })] }) }), Y.jsx(Qs.Section, { children: Y.jsx(Gt, { children: Y.jsx("div", { ref: ii, style: { width: "100%", height: "600px" } }) }) })] }) }) } export { y1 as default };
